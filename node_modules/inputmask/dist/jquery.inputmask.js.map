{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///./bundle.jquery.js","webpack:///./bundle.js","webpack:///./lib/extensions/inputmask.extensions.js","webpack:///./lib/inputmask.js","webpack:///./lib/dependencyLibs/inputmask.dependencyLib.jquery.js","webpack:///external {\"commonjs\":\"jquery\",\"commonjs2\":\"jquery\",\"amd\":\"jquery\",\"root\":\"jQuery\"}","webpack:///./lib/global/window.js","webpack:///./lib/maskset.js","webpack:///./lib/maskScope.js","webpack:///./lib/extensions/inputmask.date.extensions.js","webpack:///./lib/extensions/inputmask.numeric.extensions.js","webpack:///./lib/jquery.inputmask.js","webpack:///webpack/bootstrap"],"names":["webpackUniversalModuleDefinition","root","factory","exports","module","require","define","amd","a","i","window","__WEBPACK_EXTERNAL_MODULE__5__","im","jQuery","dependencyLib","Inputmask","extendDefinitions","A","validator","casing","&","#","extendAliases","cssunit","regex","url","autoUnmask","ip","mask","definitions","chrs","maskset","pos","strict","opts","buffer","RegExp","test","onUnMask","maskedValue","unmaskedValue","inputmode","email","greedy","onBeforePaste","pastedValue","toLowerCase","replace","*","-","mac","vin","V","clearIncomplete","$","document","generateMaskSet","analyseMask","maskScope","alias","options","internal","this","el","undefined","events","refreshValue","isPlainObject","extend","defaults","noMasksCache","userOptions","resolveAlias","isRTL","numericInput","aliasStr","aliasDefinition","prototype","aliases","importAttributeOptions","npt","dataAttribute","importOption","option","optionData","getAttribute","indexOf","importDataAttributes","attrOptions","dataoptions","p","JSON","parse","dir","rightAlign","style","textAlign","removeAttribute","Object","keys","length","placeholder","optionalmarker","quantifiermarker","groupmarker","alternatormarker","escapeChar","oncomplete","noop","onincomplete","oncleared","repeat","removeMaskOnSubmit","clearMaskOnLostFocus","insertMode","onKeyDown","onBeforeMask","isFunction","call","onBeforeWrite","showMaskOnFocus","showMaskOnHover","onKeyValidation","skipOptionalPartCharacter","undoOnEscape","radixPoint","_radixDance","groupSeparator","keepStatic","positionCaretOnTab","tabThrough","supportsInputType","ignorables","isComplete","preValidation","postValidation","staticDefinitionSymbol","jitMasking","nullable","inputEventOnly","noValuePatching","positionCaretOnClick","colorMask","disablePredictiveText","shiftPositions","9","definitionSymbol","masksCache","elems","that","getElementById","querySelectorAll","nodeName","each","ndx","scopedOpts","inputmask","remove","data","action","noremask","_typeof","unmaskedvalue","value","getemptymask","hasMaskedValue","getmetadata","isValid","format","metadata","setValue","trigger","positionColorMask","input","template","left","offsetLeft","extendDefaults","definition","unmask","escapeRegex","str","specials","join","keyCode","BACKSPACE","BACKSPACE_SAFARI","DELETE","DOWN","END","ENTER","ESCAPE","HOME","INSERT","LEFT","PAGE_DOWN","PAGE_UP","RIGHT","SPACE","TAB","UP","X","CONTROL","eval","__webpack_require__","__WEBPACK_AMD_DEFINE_RESULT__","nocache","ms","generateMask","regexMask","masksetDefinition","maskdefKey","repeatStart","split","reverse","maskToken","validPositions","_buffer","tests","excludes","maskLength","jitOffset","isArray","charAt","altMask","msk","pop","tokenizer","regexTokenizer","escaped","currentToken","MaskToken","match","m","openenings","maskTokens","openingToken","currentOpeningToken","alternator","lastMatch","closeRegexGroup","isGroup","isOptional","isQuantifier","isAlternator","matches","openGroup","alternatorGroup","quantifier","min","max","insertTestDefinition","mtoken","element","position","prevMatch","splice","fn","static","optionality","newBlockMarker","def","nativeDef","lmnt","maskdef","verifyGroupMarker","token","nextToken","defaultCase","mndx","push","reverseTokens","reverseStatic","st","hasOwnProperty","intMatch","parseInt","qt","groupify","groupToken","closeGroup","groupQuantifier","exec","altRegexGroup","mqj","mq","mq0","isNaN","mq1","jit","tmpMatch","subToken","ua","navigator","userAgent","ie","mobile","isInputEventSupported","iemobile","iphone","eventName","createElement","evName","isSupported","setAttribute","actionObj","undoValue","$el","skipKeyPressEvent","skipInputEvent","ignorable","maxLength","mouseEnter","originalPlaceholder","focusDelay","getMaskTemplate","baseOnInput","minimalPos","includeMode","noJit","clearOptionalTail","maskTemplate","ndxIntlzr","testPos","generatedInput","determineTestTemplate","getTests","locator","slice","getPlaceholder","getTestTemplate","isFinite","resetMaskSet","soft","getLastValidPosition","closestTo","before","after","valids","posNdx","psNdx","getDecisionTaker","tst","decisionTaker","alternation","toString","getLocator","align","mloc","altTest","getTest","targetLocator","tstLocator","closest","bestMatch","distance","Math","abs","optionalQuantifier","tstPs","positionCanMatchDefinition","valid","tndx","ndxInitializer","insertStop","latestMatch","cacheDependency","resolveTestFromToken","loopNdx","quantifierRecurse","handleMatch","isFirstMatch","tokenGroup","firstMatch","inArray","resolveNdxInitializer","alternateNdx","targetAlternation","indexPos","ndxPos","bestMatchAltIndex","isSubsetOf","source","target","expand","pattern","expanded","start","end","l","charCodeAt","String","fromCharCode","staticCanMatchDefinition","sloc","tloc","canMatch","setMergeLocators","targetMatch","altMatch","locNdx","cd","optionalToken","mtchsNdx","mtch","alternateToken","malternateMatches","maltMatches","currentMatches","loopNdxCnt","altIndex","shift","currentPos","ndxInitializerClone","altIndexArr","amndx","altIndexArrClone","unMatchedAlternation","concat","ndx1","dropMatch","ndx2","altMatch2","qndx","mergeLocators","previousPos","mtndx","getBufferTemplate","getBuffer","noCache","refreshFromBuffer","valResult","negationSymbol","front","caret","elem","toUpperCase","posBefore","args","Array","arguments","apply","checkAlternationMatch","altArr1","altArr2","na","altArrC","isMatch","naArr","naNdx","alndx","alternate","c","fromIsValid","rAltPos","validPsClone","lastAlt","isValidRslt","returnRslt","altPos","prevAltPos","validPos","decisionPos","lAltPos","insertPosition","insert","targetLvp","posOffset","validInputsClone","staticInputsBeforePos","validInputs","fromAlternate","validateOnly","isSelection","posObj","begin","maskPos","processCommandObject","commandObj","sort","b","revalidateMask","refresh","rewritePosition","_isValid","rslt","validatedPos","result","positionsClone","currentPosValid","seekNext","skip","isMask","nPos","snPos","trackbackPositions","postResult","endResult","originalPos","newPos","fillOnly","ps","vp","np","cvpInput","validTest","IsEnclosedStatic","selection","posMatch","nextMatch","lvp","j","needsValidation","t","newBlock","seekPrevious","writeBuffer","caretPos","event","triggerEvents","_valueSet","type","renderColorMask","$input","nptVal","_valueGet","setTimeout","returnPL","staticAlternations","prevTest","HandleNativePlaceholder","nptValue","determineNewCaretPosition","selectedCaret","tabbed","doRadixFocus","clickPos","vps","radixPos","clickPosition","lvclickPosition","lastPosition","tt","EventRuler","on","eventHandler","ev","e","imOpts","off","disabled","readOnly","ctrlKey","preventDefault","returnVal","stopPropagation","form","evArr","EventHandlers","keydownEvent","k","kdResult","handleRemove","shiftKey","altKey","checkVal","keypressEvent","checkval","writeOut","which","charCode","metaKey","forwardPosition","writeOutBuffer","pasteEvent","originalEvent","inputValue","tempValue","valueBeforeCaret","substr","valueAfterCaret","clipboardData","getData","pasteValue","inputFallBackEvent","radixPointHandler","ieMobileHandler","inputChar","iv","offset","frontPart","backPart","frontBufferPart","backBufferPart","entries","isEntry","fpl","entry","keypress","Event","keydown","beforeInputEvent","cancelable","inputType","setValueEvent","detail","applyInputValue","focusEvent","clickEvent","mouseleaveEvent","activeElement","newCaretPosition","cutEvent","clipData","setData","execCommand","blurEvent","mouseenterEvent","submitEvent","resetEvent","invalidEvent","valueBuffer","nptvl","initiatingEvent","charCodes","initialNdx","isTemplateMatch","targetTemplate","charCodeNdx","staticMatches","prevCaretPos","sndx","nextValid","nextSndx","umValue","pndx","bufferValue","notranslate","translatePosition","range","selectionStart","selectionEnd","getSelection","getRangeAt","commonAncestorContainer","parentNode","startOffset","endOffset","createRange","duplicate","moveStart","text","scrollCalc","ownerDocument","defaultView","getComputedStyle","currentStyle","fontSize","scrollLeft","scrollWidth","setSelectionRange","firstChild","textNode","createTextNode","appendChild","setStart","setEnd","collapse","sel","removeAllRanges","addRange","createTextRange","moveEnd","select","determineLastRequiredPosition","returnDefinition","bl","positions","lvTest","lvTestAlt","complete","lrp","aml","pend","initializeColorMask","computedStyle","findCaretPos","clientx","textTransform","letterSpacing","height","width","visibility","whiteSpace","body","inputText","previousWidth","itl","innerHTML","offsetWidth","offset1","offset2","removeChild","className","insertBefore","clientX","clear","isStatic","setEntry","mtl","setCaret","getElementsByTagName","isElementTypeSupported","patchValueProperty","valueGet","valueSet","patchValhook","valHooks","inputmaskpatch","valhookGet","get","valhookSet","set","getter","setter","installNativeValueSetFallback","__valueGet","getOwnPropertyDescriptor","getPrototypeOf","__proto__","object","constructor","valueProperty","defineProperty","configurable","tagName","textContent","__lookupGetter__","__lookupSetter__","__defineGetter__","__defineSetter__","__valueSet","overruleRTL","elementType","isContentEditable","autocorrect","initialValue","rl","lmib","cv","maskTarget","mtdt","formatCode","d","Date","setDate","getDate","dd","pad","ddd","dddd","setMonth","getMonth","mm","mmm","mmmm","yy","setFullYear","getFullYear","yyyy","h","setHours","getHours","hh","hhh","H","HH","HHH","M","setMinutes","getMinutes","MM","s","setSeconds","getSeconds","ss","setMilliseconds","getMilliseconds","L","T","TT","Z","o","S","formatAlias","isoDate","isoTime","isoDateTime","isoUtcDateTime","getTokenizer","tokens","isValidDate","dateParts","currentResult","rawday","day","rawyear","date","rawmonth","month","isDateInRange","rawYear","minYear","year","getTime","dateObjValue","raw","getFn","val","len","maskString","dateObj","targetProp","dateOperation","extendProperty","correctedValue","datetime","i18n","ordinalSuffix","inputFormat","displayFormat","outputFormat","dayNames","monthNames","calcPos","fuzzy","today","getYear","autoEscape","txt","escapedTxt","alignDigits","digits","digitsOptional","radixPosition","findValidator","symbol","tstNdx","ndxl","findValid","ret","parseMinMaxOptions","parseFloat","NaN","Number","MIN_VALUE","MAX_VALUE","genMask","decimalDef","__financeInput","prefix","_mask","dq","suffix","hanndleRadixDance","decimalValidator","numeric","enforceDigitsOnBlur","allowMinus","back","step","unmaskAsNumber","0","1","+","isNegative","unmasked","processValue","valueParts","integerPart","decimalPart","digitsFactor","pow","round","substring","numberMatches","number","groups","leadingzeroes","buf","caretNdx","newCaretPos","bffr","currency","decimal","integer","percentage","indianns","nptmask","installedModules","modules","name","enumerable","r","Symbol","toStringTag","mode","__esModule","ns","create","key","bind","n","getDefault","getModuleExports","property","moduleId"],"mappings":"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","file":"dist/jquery.inputmask.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"jquery\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"jquery\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"jquery\")) : factory(root[\"jQuery\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function(__WEBPACK_EXTERNAL_MODULE__5__) {\nreturn ","var im = require(\"./bundle\");\r\nvar jQuery = require(\"jquery\");\r\nif (im.dependencyLib === jQuery) {\r\n\trequire(\"./lib/jquery.inputmask\");\r\n}\r\n\r\nmodule.exports = im;\r\n\r\n","// import \"./css/inputmask.css\";\r\n\r\nrequire(\"./lib/extensions/inputmask.extensions\");\r\nrequire(\"./lib/extensions/inputmask.date.extensions\");\r\nrequire(\"./lib/extensions/inputmask.numeric.extensions\");\r\nmodule.exports = require(\"./lib/inputmask.js\");\r\n","/*\r\n Input Mask plugin extensions\r\n http://github.com/RobinHerbots/jquery.inputmask\r\n Copyright (c) Robin Herbots\r\n Licensed under the MIT license\r\n */\r\nvar Inputmask = require(\"../inputmask\");\r\n//extra definitions\r\nInputmask.extendDefinitions({\r\n\t\"A\": {\r\n\t\tvalidator: \"[A-Za-z\\u0410-\\u044F\\u0401\\u0451\\u00C0-\\u00FF\\u00B5]\",\r\n\t\tcasing: \"upper\" //auto uppercasing\r\n\t},\r\n\t\"&\": { //alfanumeric uppercasing\r\n\t\tvalidator: \"[0-9A-Za-z\\u0410-\\u044F\\u0401\\u0451\\u00C0-\\u00FF\\u00B5]\",\r\n\t\tcasing: \"upper\"\r\n\t},\r\n\t\"#\": { //hexadecimal\r\n\t\tvalidator: \"[0-9A-Fa-f]\",\r\n\t\tcasing: \"upper\"\r\n\t}\r\n});\r\nInputmask.extendAliases({\r\n\t\"cssunit\": {\r\n\t\tregex: \"[+-]?[0-9]+\\\\.?([0-9]+)?(px|em|rem|ex|%|in|cm|mm|pt|pc)\"\r\n\t},\r\n\t\"url\": { //needs update => https://en.wikipedia.org/wiki/URL\r\n\t\tregex: \"(https?|ftp)//.*\",\r\n\t\tautoUnmask: false\r\n\t},\r\n\t\"ip\": { //ip-address mask\r\n\t\tmask: \"i[i[i]].i[i[i]].i[i[i]].i[i[i]]\",\r\n\t\tdefinitions: {\r\n\t\t\t\"i\": {\r\n\t\t\t\tvalidator: function (chrs, maskset, pos, strict, opts) {\r\n\t\t\t\t\tif (pos - 1 > -1 && maskset.buffer[pos - 1] !== \".\") {\r\n\t\t\t\t\t\tchrs = maskset.buffer[pos - 1] + chrs;\r\n\t\t\t\t\t\tif (pos - 2 > -1 && maskset.buffer[pos - 2] !== \".\") {\r\n\t\t\t\t\t\t\tchrs = maskset.buffer[pos - 2] + chrs;\r\n\t\t\t\t\t\t} else chrs = \"0\" + chrs;\r\n\t\t\t\t\t} else chrs = \"00\" + chrs;\r\n\t\t\t\t\treturn new RegExp(\"25[0-5]|2[0-4][0-9]|[01][0-9][0-9]\").test(chrs);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tonUnMask: function (maskedValue, unmaskedValue, opts) {\r\n\t\t\treturn maskedValue;\r\n\t\t},\r\n\t\tinputmode: \"numeric\",\r\n\t},\r\n\t\"email\": {\r\n\t\t//https://en.wikipedia.org/wiki/Domain_name#Domain_name_space\r\n\t\t//https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_host_names\r\n\t\t//should be extended with the toplevel domains at the end\r\n\t\tmask: \"*{1,64}[.*{1,64}][.*{1,64}][.*{1,63}]@-{1,63}.-{1,63}[.-{1,63}][.-{1,63}]\",\r\n\t\tgreedy: false,\r\n\t\tcasing: \"lower\",\r\n\t\tonBeforePaste: function (pastedValue, opts) {\r\n\t\t\tpastedValue = pastedValue.toLowerCase();\r\n\t\t\treturn pastedValue.replace(\"mailto:\", \"\");\r\n\t\t},\r\n\t\tdefinitions: {\r\n\t\t\t\"*\": {\r\n\t\t\t\tvalidator: \"[0-9\\uFF11-\\uFF19A-Za-z\\u0410-\\u044F\\u0401\\u0451\\u00C0-\\u00FF\\u00B5!#$%&'*+/=?^_`{|}~-]\"\r\n\t\t\t},\r\n\t\t\t\"-\": {\r\n\t\t\t\tvalidator: \"[0-9A-Za-z-]\"\r\n\t\t\t}\r\n\t\t},\r\n\t\tonUnMask: function (maskedValue, unmaskedValue, opts) {\r\n\t\t\treturn maskedValue;\r\n\t\t},\r\n\t\tinputmode: \"email\"\r\n\t},\r\n\t\"mac\": {\r\n\t\tmask: \"##:##:##:##:##:##\"\r\n\t},\r\n\t//https://en.wikipedia.org/wiki/Vehicle_identification_number\r\n\t// see issue #1199\r\n\t\"vin\": {\r\n\t\tmask: \"V{13}9{4}\",\r\n\t\tdefinitions: {\r\n\t\t\t\"V\": {\r\n\t\t\t\tvalidator: \"[A-HJ-NPR-Za-hj-npr-z\\\\d]\",\r\n\t\t\t\tcasing: \"upper\"\r\n\t\t\t}\r\n\t\t},\r\n\t\tclearIncomplete: true,\r\n\t\tautoUnmask: true\r\n\t}\r\n});\r\nmodule.exports = Inputmask;\r\n","/*\r\n * Input Mask Core\r\n * http://github.com/RobinHerbots/jquery.inputmask\r\n * Copyright (c) Robin Herbots\r\n * Licensed under the MIT license\r\n */\r\nvar $ = require(\"./dependencyLibs/inputmask.dependencyLib\"), window = require(\"./global/window\"),\r\n\tdocument = window.document,\r\n\tgenerateMaskSet = require(\"./maskset\").generateMaskSet,\r\n\tanalyseMask = require(\"./maskset\").analyseMask,\r\n\tmaskScope = require(\"./maskScope\");\r\n\r\n\r\nfunction Inputmask(alias, options, internal) {\r\n\t//allow instanciating without new\r\n\tif (!(this instanceof Inputmask)) {\r\n\t\treturn new Inputmask(alias, options, internal);\r\n\t}\r\n\r\n\tthis.el = undefined;\r\n\tthis.events = {};\r\n\tthis.maskset = undefined;\r\n\tthis.refreshValue = false; //indicate a refresh from the inputvalue is needed (form.reset)\r\n\r\n\tif (internal !== true) {\r\n\t\t//init options\r\n\t\tif ($.isPlainObject(alias)) {\r\n\t\t\toptions = alias;\r\n\t\t} else {\r\n\t\t\toptions = options || {};\r\n\t\t\tif (alias) options.alias = alias;\r\n\t\t}\r\n\t\tthis.opts = $.extend(true, {}, this.defaults, options);\r\n\t\tthis.noMasksCache = options && options.definitions !== undefined;\r\n\t\tthis.userOptions = options || {}; //user passed options\r\n\t\tresolveAlias(this.opts.alias, options, this.opts);\r\n\t\tthis.isRTL = this.opts.numericInput;\r\n\t}\r\n}\r\n\r\nInputmask.prototype = {\r\n\tdataAttribute: \"data-inputmask\", //data attribute prefix used for attribute binding\r\n\t//options default\r\n\tdefaults: {\r\n\t\tplaceholder: \"_\",\r\n\t\toptionalmarker: [\"[\", \"]\"],\r\n\t\tquantifiermarker: [\"{\", \"}\"],\r\n\t\tgroupmarker: [\"(\", \")\"],\r\n\t\talternatormarker: \"|\",\r\n\t\tescapeChar: \"\\\\\",\r\n\t\tmask: null, //needs tobe null instead of undefined as the extend method does not consider props with the undefined value\r\n\t\tregex: null, //regular expression as a mask\r\n\t\toncomplete: $.noop, //executes when the mask is complete\r\n\t\tonincomplete: $.noop, //executes when the mask is incomplete and focus is lost\r\n\t\toncleared: $.noop, //executes when the mask is cleared\r\n\t\trepeat: 0, //repetitions of the mask: * ~ forever, otherwise specify an integer\r\n\t\tgreedy: false, //true: allocated buffer for the mask and repetitions - false: allocate only if needed\r\n\t\tautoUnmask: false, //automatically unmask when retrieving the value with $.fn.val or value if the browser supports __lookupGetter__ or getOwnPropertyDescriptor\r\n\t\tremoveMaskOnSubmit: false, //remove the mask before submitting the form.\r\n\t\tclearMaskOnLostFocus: true,\r\n\t\tinsertMode: true, //insert the input or overwrite the input\r\n\t\tclearIncomplete: false, //clear the incomplete input on blur\r\n\t\talias: null,\r\n\t\tonKeyDown: $.noop, //callback to implement autocomplete on certain keys for example. args => event, buffer, caretPos, opts\r\n\t\tonBeforeMask: null, //executes before masking the initial value to allow preprocessing of the initial value.\targs => initialValue, opts => return processedValue\r\n\t\tonBeforePaste: function (pastedValue, opts) {\r\n\t\t\treturn $.isFunction(opts.onBeforeMask) ? opts.onBeforeMask.call(this, pastedValue, opts) : pastedValue;\r\n\t\t}, //executes before masking the pasted value to allow preprocessing of the pasted value.\targs => pastedValue, opts => return processedValue\r\n\t\tonBeforeWrite: null, //executes before writing to the masked element. args => event, opts\r\n\t\tonUnMask: null, //executes after unmasking to allow postprocessing of the unmaskedvalue.\targs => maskedValue, unmaskedValue, opts\r\n\t\tshowMaskOnFocus: true, //show the mask-placeholder when the input has focus\r\n\t\tshowMaskOnHover: true, //show the mask-placeholder when hovering the empty input\r\n\t\tonKeyValidation: $.noop, //executes on every key-press with the result of isValid. Params: key, result, opts\r\n\t\tskipOptionalPartCharacter: \" \", //a character which can be used to skip an optional part of a mask\r\n\t\tnumericInput: false, //numericInput input direction style (input shifts to the left while holding the caret position)\r\n\t\trightAlign: false, //align to the right\r\n\t\tundoOnEscape: true, //pressing escape reverts the value to the value before focus\r\n\t\t//numeric basic properties\r\n\t\tradixPoint: \"\", //\".\", // | \",\"\r\n\t\t_radixDance: false, //dance around the radixPoint\r\n\t\tgroupSeparator: \"\", //\",\", // | \".\"\r\n\t\t//numeric basic properties\r\n\t\tkeepStatic: null, //try to keep the mask static while typing. Decisions to alter the mask will be posponed if possible - null see auto selection for multi masks\r\n\t\tpositionCaretOnTab: true, //when enabled the caret position is set after the latest valid position on TAB\r\n\t\ttabThrough: false, //allows for tabbing through the different parts of the masked field\r\n\t\tsupportsInputType: [\"text\", \"tel\", \"url\", \"password\", \"search\"], //list with the supported input types\r\n\t\t//specify keyCodes which should not be considered in the keypress event, otherwise the preventDefault will stop their default behavior especially in FF\r\n\t\tignorables: [8, 9, 13, 19, 27, 33, 34, 35, 36, 37, 38, 39, 40, 45, 46, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 0, 229],\r\n\t\tisComplete: null, //override for isComplete - args => buffer, opts - return true || false\r\n\t\tpreValidation: null, //hook to preValidate the input.  Usefull for validating regardless the definition.\targs => buffer, pos, char, isSelection, opts => return true/false/command object\r\n\t\tpostValidation: null, //hook to postValidate the result from isValid.\tUsefull for validating the entry as a whole.\targs => buffer, pos, currentResult, opts => return true/false/json\r\n\t\tstaticDefinitionSymbol: undefined, //specify a definitionSymbol for static content, used to make matches for alternators\r\n\t\tjitMasking: false, //just in time masking ~ only mask while typing, can n (number), true or false\r\n\t\tnullable: true, //return nothing instead of the buffertemplate when the user hasn't entered anything.\r\n\t\tinputEventOnly: false, //dev option - testing inputfallback behavior\r\n\t\tnoValuePatching: false, //disable value property patching\r\n\t\tpositionCaretOnClick: \"lvp\", //none, lvp (based on the last valid position (default), radixFocus (position caret to radixpoint on initial click), select (select the whole input), ignore (ignore the click and continue the mask)\r\n\t\tcasing: null, //mask-level casing. Options: null, \"upper\", \"lower\" or \"title\" or callback args => elem, test, pos, validPositions return charValue\r\n\t\tinputmode: \"verbatim\", //specify the inputmode  - already in place for when browsers will support it\r\n\t\tcolorMask: false, //enable css styleable mask\r\n\t\tdisablePredictiveText: false, //disable Predictive Text on mobile devices\r\n\t\timportDataAttributes: true, //import data-inputmask attributes\r\n\t\tshiftPositions: true //shift position of the mask entries on entry and deletion.\r\n\t},\r\n\tdefinitions: {\r\n\t\t\"9\": { //\\uFF11-\\uFF19 #1606\r\n\t\t\tvalidator: \"[0-9\\uFF11-\\uFF19]\",\r\n\t\t\tdefinitionSymbol: \"*\"\r\n\t\t},\r\n\t\t\"a\": { //\\u0410-\\u044F\\u0401\\u0451\\u00C0-\\u00FF\\u00B5 #76\r\n\t\t\tvalidator: \"[A-Za-z\\u0410-\\u044F\\u0401\\u0451\\u00C0-\\u00FF\\u00B5]\",\r\n\t\t\tdefinitionSymbol: \"*\"\r\n\t\t},\r\n\t\t\"*\": {\r\n\t\t\tvalidator: \"[0-9\\uFF11-\\uFF19A-Za-z\\u0410-\\u044F\\u0401\\u0451\\u00C0-\\u00FF\\u00B5]\"\r\n\t\t}\r\n\t},\r\n\taliases: {}, //aliases definitions\r\n\tmasksCache: {},\r\n\tmask: function (elems) {\r\n\t\tvar that = this;\r\n\t\tif (typeof elems === \"string\") {\r\n\t\t\telems = document.getElementById(elems) || document.querySelectorAll(elems);\r\n\t\t}\r\n\t\telems = elems.nodeName ? [elems] : elems;\r\n\t\t$.each(elems, function (ndx, el) {\r\n\t\t\tvar scopedOpts = $.extend(true, {}, that.opts);\r\n\t\t\tif (importAttributeOptions(el, scopedOpts, $.extend(true, {}, that.userOptions), that.dataAttribute)) {\r\n\t\t\t\tvar maskset = generateMaskSet(scopedOpts, that.noMasksCache);\r\n\t\t\t\tif (maskset !== undefined) {\r\n\t\t\t\t\tif (el.inputmask !== undefined) {\r\n\t\t\t\t\t\tel.inputmask.opts.autoUnmask = true; //force autounmasking when remasking\r\n\t\t\t\t\t\tel.inputmask.remove();\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//store inputmask instance on the input with element reference\r\n\t\t\t\t\tel.inputmask = new Inputmask(undefined, undefined, true);\r\n\t\t\t\t\tel.inputmask.opts = scopedOpts;\r\n\t\t\t\t\tel.inputmask.noMasksCache = that.noMasksCache;\r\n\t\t\t\t\tel.inputmask.userOptions = $.extend(true, {}, that.userOptions);\r\n\t\t\t\t\tel.inputmask.isRTL = scopedOpts.isRTL || scopedOpts.numericInput;\r\n\t\t\t\t\tel.inputmask.el = el;\r\n\t\t\t\t\tel.inputmask.maskset = maskset;\r\n\r\n\t\t\t\t\t$.data(el, \"_inputmask_opts\", scopedOpts);\r\n\r\n\t\t\t\t\tmaskScope.call(el.inputmask, {\r\n\t\t\t\t\t\t\"action\": \"mask\"\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn elems && elems[0] ? (elems[0].inputmask || this) : this;\r\n\t},\r\n\toption: function (options, noremask) { //set extra options || retrieve value of a current option\r\n\t\tif (typeof options === \"string\") {\r\n\t\t\treturn this.opts[options];\r\n\t\t} else if (typeof options === \"object\") {\r\n\t\t\t$.extend(this.userOptions, options); //user passed options\r\n\t\t\t//remask\r\n\t\t\tif (this.el && noremask !== true) {\r\n\t\t\t\tthis.mask(this.el);\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t}\r\n\t},\r\n\tunmaskedvalue: function (value) {\r\n\t\tthis.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);\r\n\t\treturn maskScope.call(this, {\r\n\t\t\t\"action\": \"unmaskedvalue\",\r\n\t\t\t\"value\": value\r\n\t\t});\r\n\t},\r\n\tremove: function () {\r\n\t\treturn maskScope.call(this, {\r\n\t\t\t\"action\": \"remove\"\r\n\t\t});\r\n\t},\r\n\tgetemptymask: function () { //return the default (empty) mask value, usefull for setting the default value in validation\r\n\t\tthis.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);\r\n\t\treturn maskScope.call(this, {\r\n\t\t\t\"action\": \"getemptymask\"\r\n\t\t});\r\n\t},\r\n\thasMaskedValue: function () { //check wheter the returned value is masked or not; currently only works reliable when using jquery.val fn to retrieve the value\r\n\t\treturn !this.opts.autoUnmask;\r\n\t},\r\n\tisComplete: function () {\r\n\t\tthis.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);\r\n\t\treturn maskScope.call(this, {\r\n\t\t\t\"action\": \"isComplete\"\r\n\t\t});\r\n\t},\r\n\tgetmetadata: function () { //return mask metadata if exists\r\n\t\tthis.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);\r\n\t\treturn maskScope.call(this, {\r\n\t\t\t\"action\": \"getmetadata\"\r\n\t\t});\r\n\t},\r\n\tisValid: function (value) {\r\n\t\tthis.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);\r\n\t\treturn maskScope.call(this, {\r\n\t\t\t\"action\": \"isValid\",\r\n\t\t\t\"value\": value\r\n\t\t});\r\n\t},\r\n\tformat: function (value, metadata) {\r\n\t\tthis.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);\r\n\t\treturn maskScope.call(this, {\r\n\t\t\t\"action\": \"format\",\r\n\t\t\t\"value\": value,\r\n\t\t\t\"metadata\": metadata //true/false getmetadata\r\n\t\t});\r\n\t},\r\n\tsetValue: function (value) {\r\n\t\tif (this.el) {\r\n\t\t\t$(this.el).trigger(\"setvalue\", [value]);\r\n\t\t}\r\n\t},\r\n\tanalyseMask: analyseMask,\r\n\tpositionColorMask: function (input, template) {\r\n\t\tinput.style.left = template.offsetLeft + \"px\";\r\n\t}\r\n};\r\n\r\nfunction resolveAlias(aliasStr, options, opts) {\r\n\tvar aliasDefinition = Inputmask.prototype.aliases[aliasStr];\r\n\tif (aliasDefinition) {\r\n\t\tif (aliasDefinition.alias) resolveAlias(aliasDefinition.alias, undefined, opts); //alias is another alias\r\n\t\t$.extend(true, opts, aliasDefinition); //merge alias definition in the options\r\n\t\t$.extend(true, opts, options); //reapply extra given options\r\n\t\treturn true;\r\n\t} else //alias not found - try as mask\r\n\tif (opts.mask === null) {\r\n\t\topts.mask = aliasStr;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nfunction importAttributeOptions(npt, opts, userOptions, dataAttribute) {\r\n\tfunction importOption(option, optionData) {\r\n\t\toptionData = optionData !== undefined ? optionData : npt.getAttribute(dataAttribute + \"-\" + option);\r\n\t\tif (optionData !== null) {\r\n\t\t\tif (typeof optionData === \"string\") {\r\n\t\t\t\tif (option.indexOf(\"on\") === 0) {\r\n\t\t\t\t\toptionData = window[optionData];\r\n\t\t\t\t}//get function definition\r\n\t\t\t\telse if (optionData === \"false\") {\r\n\t\t\t\t\toptionData = false;\r\n\t\t\t\t} else if (optionData === \"true\") optionData = true;\r\n\t\t\t}\r\n\t\t\tuserOptions[option] = optionData;\r\n\t\t}\r\n\t}\r\n\r\n\tif (opts.importDataAttributes === true) {\r\n\t\tvar attrOptions = npt.getAttribute(dataAttribute), option, dataoptions, optionData, p;\r\n\r\n\t\tif (attrOptions && attrOptions !== \"\") {\r\n\t\t\tattrOptions = attrOptions.replace(/'/g, \"\\\"\");\r\n\t\t\tdataoptions = JSON.parse(\"{\" + attrOptions + \"}\");\r\n\t\t}\r\n\r\n\t\t//resolve aliases\r\n\t\tif (dataoptions) { //pickup alias from dataAttribute\r\n\t\t\toptionData = undefined;\r\n\t\t\tfor (p in dataoptions) {\r\n\t\t\t\tif (p.toLowerCase() === \"alias\") {\r\n\t\t\t\t\toptionData = dataoptions[p];\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\timportOption(\"alias\", optionData); //pickup alias from dataAttribute-alias\r\n\t\tif (userOptions.alias) {\r\n\t\t\tresolveAlias(userOptions.alias, userOptions, opts);\r\n\t\t}\r\n\r\n\t\tfor (option in opts) {\r\n\t\t\tif (dataoptions) {\r\n\t\t\t\toptionData = undefined;\r\n\t\t\t\tfor (p in dataoptions) {\r\n\t\t\t\t\tif (p.toLowerCase() === option.toLowerCase()) {\r\n\t\t\t\t\t\toptionData = dataoptions[p];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\timportOption(option, optionData);\r\n\t\t}\r\n\t}\r\n\t$.extend(true, opts, userOptions);\r\n\r\n\t//handle dir=rtl\r\n\tif (npt.dir === \"rtl\" || opts.rightAlign) {\r\n\t\tnpt.style.textAlign = \"right\";\r\n\t}\r\n\r\n\tif (npt.dir === \"rtl\" || opts.numericInput) {\r\n\t\tnpt.dir = \"ltr\";\r\n\t\tnpt.removeAttribute(\"dir\");\r\n\t\topts.isRTL = true;\r\n\t}\r\n\r\n\treturn Object.keys(userOptions).length;\r\n}\r\n\r\n//apply defaults, definitions, aliases\r\nInputmask.extendDefaults = function (options) {\r\n\t$.extend(true, Inputmask.prototype.defaults, options);\r\n};\r\nInputmask.extendDefinitions = function (definition) {\r\n\t$.extend(true, Inputmask.prototype.definitions, definition);\r\n};\r\nInputmask.extendAliases = function (alias) {\r\n\t$.extend(true, Inputmask.prototype.aliases, alias);\r\n};\r\n//static fn on inputmask\r\nInputmask.format = function (value, options, metadata) {\r\n\treturn Inputmask(options).format(value, metadata);\r\n};\r\nInputmask.unmask = function (value, options) {\r\n\treturn Inputmask(options).unmaskedvalue(value);\r\n};\r\nInputmask.isValid = function (value, options) {\r\n\treturn Inputmask(options).isValid(value);\r\n};\r\nInputmask.remove = function (elems) {\r\n\tif (typeof elems === \"string\") {\r\n\t\telems = document.getElementById(elems) || document.querySelectorAll(elems);\r\n\t}\r\n\telems = elems.nodeName ? [elems] : elems;\r\n\t$.each(elems, function (ndx, el) {\r\n\t\tif (el.inputmask) el.inputmask.remove();\r\n\t});\r\n};\r\nInputmask.setValue = function (elems, value) {\r\n\tif (typeof elems === \"string\") {\r\n\t\telems = document.getElementById(elems) || document.querySelectorAll(elems);\r\n\t}\r\n\telems = elems.nodeName ? [elems] : elems;\r\n\t$.each(elems, function (ndx, el) {\r\n\t\tif (el.inputmask) el.inputmask.setValue(value); else $(el).trigger(\"setvalue\", [value]);\r\n\t});\r\n};\r\nInputmask.escapeRegex = function (str) {\r\n\tvar specials = [\"/\", \".\", \"*\", \"+\", \"?\", \"|\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", \"\\\\\", \"$\", \"^\"];\r\n\treturn str.replace(new RegExp(\"(\\\\\" + specials.join(\"|\\\\\") + \")\", \"gim\"), \"\\\\$1\");\r\n};\r\nInputmask.keyCode = {\r\n\tBACKSPACE: 8,\r\n\tBACKSPACE_SAFARI: 127,\r\n\tDELETE: 46,\r\n\tDOWN: 40,\r\n\tEND: 35,\r\n\tENTER: 13,\r\n\tESCAPE: 27,\r\n\tHOME: 36,\r\n\tINSERT: 45,\r\n\tLEFT: 37,\r\n\tPAGE_DOWN: 34,\r\n\tPAGE_UP: 33,\r\n\tRIGHT: 39,\r\n\tSPACE: 32,\r\n\tTAB: 9,\r\n\tUP: 38,\r\n\tX: 88,\r\n\tCONTROL: 17\r\n};\r\nInputmask.dependencyLib = $;\r\n\r\n//make inputmask available\r\nwindow.Inputmask = Inputmask;\r\nmodule.exports = Inputmask;\r\n","/*\r\n Input Mask plugin dependencyLib\r\n http://github.com/RobinHerbots/jquery.inputmask\r\n Copyright (c) Robin Herbots\r\n Licensed under the MIT license\r\n */\r\n\r\nmodule.exports = require(\"jquery\");\r\n","module.exports = __WEBPACK_EXTERNAL_MODULE__5__;","if (typeof define === \"function\" && define.amd)\r\n\tdefine(function () {\r\n\t\treturn typeof window !== \"undefined\" ? window : new (eval(\"require('jsdom').JSDOM\"))(\"\").window;\r\n\t});\r\nelse if (typeof exports === \"object\")\r\n\tmodule.exports = typeof window !== \"undefined\" ? window : new (eval(\"require('jsdom').JSDOM\"))(\"\").window;\r\n\r\n","var $ = require(\"./dependencyLibs/inputmask.dependencyLib\");\r\n\r\nfunction generateMaskSet(opts, nocache) {\r\n\tvar ms;\r\n\r\n\tfunction generateMask(mask, metadata, opts) {\r\n\t\tvar regexMask = false;\r\n\t\tif (mask === null || mask === \"\") {\r\n\t\t\tregexMask = opts.regex !== null;\r\n\t\t\tif (regexMask) {\r\n\t\t\t\tmask = opts.regex;\r\n\t\t\t\tmask = mask.replace(/^(\\^)(.*)(\\$)$/, \"$2\");\r\n\t\t\t} else {\r\n\t\t\t\tregexMask = true;\r\n\t\t\t\tmask = \".*\";\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (mask.length === 1 && opts.greedy === false && opts.repeat !== 0) {\r\n\t\t\topts.placeholder = \"\";\r\n\t\t} //hide placeholder with single non-greedy mask\r\n\t\tif (opts.repeat > 0 || opts.repeat === \"*\" || opts.repeat === \"+\") {\r\n\t\t\tvar repeatStart = opts.repeat === \"*\" ? 0 : (opts.repeat === \"+\" ? 1 : opts.repeat);\r\n\t\t\tmask = opts.groupmarker[0] + mask + opts.groupmarker[1] + opts.quantifiermarker[0] + repeatStart + \",\" + opts.repeat + opts.quantifiermarker[1];\r\n\t\t}\r\n\r\n\t\t// console.log(mask);\r\n\t\tvar masksetDefinition, maskdefKey;\r\n\t\tmaskdefKey = regexMask ? \"regex_\" + opts.regex : opts.numericInput ? mask.split(\"\").reverse().join(\"\") : mask;\r\n\t\tif (opts.keepStatic !== false) { //keepstatic modifies the output from the testdefinitions ~ so differentiate in the maskcache\r\n\t\t\tmaskdefKey = \"ks_\" + maskdefKey;\r\n\t\t}\r\n\r\n\t\tif (Inputmask.prototype.masksCache[maskdefKey] === undefined || nocache === true) {\r\n\t\t\tmasksetDefinition = {\r\n\t\t\t\t\"mask\": mask,\r\n\t\t\t\t\"maskToken\": Inputmask.prototype.analyseMask(mask, regexMask, opts),\r\n\t\t\t\t\"validPositions\": {},\r\n\t\t\t\t\"_buffer\": undefined,\r\n\t\t\t\t\"buffer\": undefined,\r\n\t\t\t\t\"tests\": {},\r\n\t\t\t\t\"excludes\": {}, //excluded alternations\r\n\t\t\t\t\"metadata\": metadata,\r\n\t\t\t\t\"maskLength\": undefined,\r\n\t\t\t\t\"jitOffset\": {}\r\n\t\t\t};\r\n\t\t\tif (nocache !== true) {\r\n\t\t\t\tInputmask.prototype.masksCache[maskdefKey] = masksetDefinition;\r\n\t\t\t\tmasksetDefinition = $.extend(true, {}, Inputmask.prototype.masksCache[maskdefKey]);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tmasksetDefinition = $.extend(true, {}, Inputmask.prototype.masksCache[maskdefKey]);\r\n\t\t}\r\n\r\n\t\treturn masksetDefinition;\r\n\t}\r\n\r\n\tif ($.isFunction(opts.mask)) { //allow mask to be a preprocessing fn - should return a valid mask\r\n\t\topts.mask = opts.mask(opts);\r\n\t}\r\n\tif ($.isArray(opts.mask)) {\r\n\t\tif (opts.mask.length > 1) {\r\n\t\t\tif (opts.keepStatic === null) { //enable by default when passing multiple masks when the option is not explicitly specified\r\n\t\t\t\topts.keepStatic = \"auto\";\r\n\t\t\t\tfor (var i = 0; i < opts.mask.length; i++) {\r\n\t\t\t\t\tif (opts.mask[i].charAt(0) !== opts.mask[0].charAt(0)) {\r\n\t\t\t\t\t\topts.keepStatic = true;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar altMask = opts.groupmarker[0];\r\n\t\t\t$.each(opts.isRTL ? opts.mask.reverse() : opts.mask, function (ndx, msk) {\r\n\t\t\t\tif (altMask.length > 1) {\r\n\t\t\t\t\taltMask += opts.groupmarker[1] + opts.alternatormarker + opts.groupmarker[0];\r\n\t\t\t\t}\r\n\t\t\t\tif (msk.mask !== undefined && !$.isFunction(msk.mask)) {\r\n\t\t\t\t\taltMask += msk.mask;\r\n\t\t\t\t} else {\r\n\t\t\t\t\taltMask += msk;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\taltMask += opts.groupmarker[1];\r\n\t\t\t// console.log(altMask);\r\n\t\t\treturn generateMask(altMask, opts.mask, opts);\r\n\t\t} else {\r\n\t\t\topts.mask = opts.mask.pop();\r\n\t\t}\r\n\t}\r\n\r\n\tif (opts.mask && opts.mask.mask !== undefined && !$.isFunction(opts.mask.mask)) {\r\n\t\tms = generateMask(opts.mask.mask, opts.mask, opts);\r\n\t} else {\r\n\t\tms = generateMask(opts.mask, opts.mask, opts);\r\n\t}\r\n\r\n\treturn ms;\r\n}\r\n\r\nfunction analyseMask(mask, regexMask, opts) {\r\n\tvar tokenizer = /(?:[?*+]|\\{[0-9+*]+(?:,[0-9+*]*)?(?:\\|[0-9+*]*)?\\})|[^.?*+^${[]()|\\\\]+|./g,\r\n\t\t//Thx to https://github.com/slevithan/regex-colorizer for the regexTokenizer regex\r\n\t\tregexTokenizer = /\\[\\^?]?(?:[^\\\\\\]]+|\\\\[\\S\\s]?)*]?|\\\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\\S\\s]?)|\\((?:\\?[:=!]?)?|(?:[?*+]|\\{[0-9]+(?:,[0-9]*)?\\})\\??|[^.?*+^${[()|\\\\]+|./g,\r\n\t\tescaped = false,\r\n\t\tcurrentToken = new MaskToken(),\r\n\t\tmatch,\r\n\t\tm,\r\n\t\topenenings = [],\r\n\t\tmaskTokens = [],\r\n\t\topeningToken,\r\n\t\tcurrentOpeningToken,\r\n\t\talternator,\r\n\t\tlastMatch,\r\n\t\tcloseRegexGroup = false;\r\n\r\n\tfunction MaskToken(isGroup, isOptional, isQuantifier, isAlternator) {\r\n\t\tthis.matches = [];\r\n\t\tthis.openGroup = isGroup || false;\r\n\t\tthis.alternatorGroup = false;\r\n\t\tthis.isGroup = isGroup || false;\r\n\t\tthis.isOptional = isOptional || false;\r\n\t\tthis.isQuantifier = isQuantifier || false;\r\n\t\tthis.isAlternator = isAlternator || false;\r\n\t\tthis.quantifier = {\r\n\t\t\tmin: 1,\r\n\t\t\tmax: 1\r\n\t\t};\r\n\t}\r\n\r\n\t//test definition => {fn: RegExp/function, static: true/false optionality: bool, newBlockMarker: bool, casing: null/upper/lower, def: definitionSymbol, placeholder: placeholder, mask: real maskDefinition}\r\n\tfunction insertTestDefinition(mtoken, element, position) {\r\n\t\tposition = position !== undefined ? position : mtoken.matches.length;\r\n\t\tvar prevMatch = mtoken.matches[position - 1];\r\n\t\tif (regexMask) {\r\n\t\t\tif (element.indexOf(\"[\") === 0 || (escaped && /\\\\d|\\\\s|\\\\w]/i.test(element)) || element === \".\") {\r\n\t\t\t\tmtoken.matches.splice(position++, 0, {\r\n\t\t\t\t\tfn: new RegExp(element, opts.casing ? \"i\" : \"\"),\r\n\t\t\t\t\tstatic: false,\r\n\t\t\t\t\toptionality: false,\r\n\t\t\t\t\tnewBlockMarker: prevMatch === undefined ? \"master\" : prevMatch.def !== element,\r\n\t\t\t\t\tcasing: null,\r\n\t\t\t\t\tdef: element,\r\n\t\t\t\t\tplaceholder: undefined,\r\n\t\t\t\t\tnativeDef: element\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\tif (escaped) element = element[element.length - 1];\r\n\t\t\t\t$.each(element.split(\"\"), function (ndx, lmnt) {\r\n\t\t\t\t\tprevMatch = mtoken.matches[position - 1];\r\n\t\t\t\t\tmtoken.matches.splice(position++, 0, {\r\n\t\t\t\t\t\tfn: /[a-z]/i.test((opts.staticDefinitionSymbol || lmnt)) ? new RegExp(\"[\" + (opts.staticDefinitionSymbol || lmnt) + \"]\", opts.casing ? \"i\" : \"\") : null,\r\n\t\t\t\t\t\tstatic: true,\r\n\t\t\t\t\t\toptionality: false,\r\n\t\t\t\t\t\tnewBlockMarker: prevMatch === undefined ? \"master\" : (prevMatch.def !== lmnt && prevMatch.static !== true),\r\n\t\t\t\t\t\tcasing: null,\r\n\t\t\t\t\t\tdef: opts.staticDefinitionSymbol || lmnt,\r\n\t\t\t\t\t\tplaceholder: opts.staticDefinitionSymbol !== undefined ? lmnt : undefined,\r\n\t\t\t\t\t\tnativeDef: (escaped ? \"'\" : \"\") + lmnt\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tescaped = false;\r\n\t\t} else {\r\n\t\t\tvar maskdef = (opts.definitions ? opts.definitions[element] : undefined) || Inputmask.prototype.definitions[element];\r\n\t\t\tif (maskdef && !escaped) {\r\n\t\t\t\tmtoken.matches.splice(position++, 0, {\r\n\t\t\t\t\tfn: maskdef.validator ? typeof maskdef.validator == \"string\" ? new RegExp(maskdef.validator, opts.casing ? \"i\" : \"\") : new function () {\r\n\t\t\t\t\t\tthis.test = maskdef.validator;\r\n\t\t\t\t\t} : new RegExp(\".\"),\r\n\t\t\t\t\tstatic: false,\r\n\t\t\t\t\toptionality: false,\r\n\t\t\t\t\tnewBlockMarker: prevMatch === undefined ? \"master\" : prevMatch.def !== (maskdef.definitionSymbol || element),\r\n\t\t\t\t\tcasing: maskdef.casing,\r\n\t\t\t\t\tdef: maskdef.definitionSymbol || element,\r\n\t\t\t\t\tplaceholder: maskdef.placeholder,\r\n\t\t\t\t\tnativeDef: element\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\tmtoken.matches.splice(position++, 0, {\r\n\t\t\t\t\tfn: /[a-z]/i.test((opts.staticDefinitionSymbol || element)) ? new RegExp(\"[\" + (opts.staticDefinitionSymbol || element) + \"]\", opts.casing ? \"i\" : \"\") : null,\r\n\t\t\t\t\tstatic: true,\r\n\t\t\t\t\toptionality: false,\r\n\t\t\t\t\tnewBlockMarker: prevMatch === undefined ? \"master\" : (prevMatch.def !== element && prevMatch.static !== true),\r\n\t\t\t\t\tcasing: null,\r\n\t\t\t\t\tdef: opts.staticDefinitionSymbol || element,\r\n\t\t\t\t\tplaceholder: opts.staticDefinitionSymbol !== undefined ? element : undefined,\r\n\t\t\t\t\tnativeDef: (escaped ? \"'\" : \"\") + element\r\n\t\t\t\t});\r\n\t\t\t\tescaped = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction verifyGroupMarker(maskToken) {\r\n\t\tif (maskToken && maskToken.matches) {\r\n\t\t\t$.each(maskToken.matches, function (ndx, token) {\r\n\t\t\t\tvar nextToken = maskToken.matches[ndx + 1];\r\n\t\t\t\tif ((nextToken === undefined || (nextToken.matches === undefined || nextToken.isQuantifier === false)) && token && token.isGroup) { //this is not a group but a normal mask => convert\r\n\t\t\t\t\ttoken.isGroup = false;\r\n\t\t\t\t\tif (!regexMask) {\r\n\t\t\t\t\t\tinsertTestDefinition(token, opts.groupmarker[0], 0);\r\n\t\t\t\t\t\tif (token.openGroup !== true) {\r\n\t\t\t\t\t\t\tinsertTestDefinition(token, opts.groupmarker[1]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tverifyGroupMarker(token);\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\tfunction defaultCase() {\r\n\t\tif (openenings.length > 0) {\r\n\t\t\tcurrentOpeningToken = openenings[openenings.length - 1];\r\n\t\t\tinsertTestDefinition(currentOpeningToken, m);\r\n\t\t\tif (currentOpeningToken.isAlternator) { //handle alternator a | b case\r\n\t\t\t\talternator = openenings.pop();\r\n\t\t\t\tfor (var mndx = 0; mndx < alternator.matches.length; mndx++) {\r\n\t\t\t\t\tif (alternator.matches[mndx].isGroup) alternator.matches[mndx].isGroup = false; //don't mark alternate groups as group\r\n\t\t\t\t}\r\n\t\t\t\tif (openenings.length > 0) {\r\n\t\t\t\t\tcurrentOpeningToken = openenings[openenings.length - 1];\r\n\t\t\t\t\tcurrentOpeningToken.matches.push(alternator);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcurrentToken.matches.push(alternator);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tinsertTestDefinition(currentToken, m);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction reverseTokens(maskToken) {\r\n\t\tfunction reverseStatic(st) {\r\n\t\t\tif (st === opts.optionalmarker[0]) {\r\n\t\t\t\tst = opts.optionalmarker[1];\r\n\t\t\t} else if (st === opts.optionalmarker[1]) {\r\n\t\t\t\tst = opts.optionalmarker[0];\r\n\t\t\t} else if (st === opts.groupmarker[0]) {\r\n\t\t\t\tst = opts.groupmarker[1];\r\n\t\t\t} else if (st === opts.groupmarker[1]) st = opts.groupmarker[0];\r\n\r\n\t\t\treturn st;\r\n\t\t}\r\n\r\n\t\tmaskToken.matches = maskToken.matches.reverse();\r\n\t\tfor (var match in maskToken.matches) {\r\n\t\t\tif (maskToken.matches.hasOwnProperty(match)) {\r\n\t\t\t\tvar intMatch = parseInt(match);\r\n\t\t\t\tif (maskToken.matches[match].isQuantifier && maskToken.matches[intMatch + 1] && maskToken.matches[intMatch + 1].isGroup) { //reposition quantifier\r\n\t\t\t\t\tvar qt = maskToken.matches[match];\r\n\t\t\t\t\tmaskToken.matches.splice(match, 1);\r\n\t\t\t\t\tmaskToken.matches.splice(intMatch + 1, 0, qt);\r\n\t\t\t\t}\r\n\t\t\t\tif (maskToken.matches[match].matches !== undefined) {\r\n\t\t\t\t\tmaskToken.matches[match] = reverseTokens(maskToken.matches[match]);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tmaskToken.matches[match] = reverseStatic(maskToken.matches[match]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn maskToken;\r\n\t}\r\n\r\n\tfunction groupify(matches) {\r\n\t\tvar groupToken = new MaskToken(true);\r\n\t\tgroupToken.openGroup = false;\r\n\t\tgroupToken.matches = matches;\r\n\t\treturn groupToken;\r\n\t}\r\n\r\n\tfunction closeGroup() {\r\n\t\t// Group closing\r\n\t\topeningToken = openenings.pop();\r\n\t\topeningToken.openGroup = false; //mark group as complete\r\n\t\tif (openingToken !== undefined) {\r\n\t\t\tif (openenings.length > 0) {\r\n\t\t\t\tcurrentOpeningToken = openenings[openenings.length - 1];\r\n\t\t\t\tcurrentOpeningToken.matches.push(openingToken);\r\n\t\t\t\tif (currentOpeningToken.isAlternator) { //handle alternator (a) | (b) case\r\n\t\t\t\t\talternator = openenings.pop();\r\n\t\t\t\t\tfor (var mndx = 0; mndx < alternator.matches.length; mndx++) {\r\n\t\t\t\t\t\talternator.matches[mndx].isGroup = false; //don't mark alternate groups as group\r\n\t\t\t\t\t\talternator.matches[mndx].alternatorGroup = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (openenings.length > 0) {\r\n\t\t\t\t\t\tcurrentOpeningToken = openenings[openenings.length - 1];\r\n\t\t\t\t\t\tcurrentOpeningToken.matches.push(alternator);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tcurrentToken.matches.push(alternator);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tcurrentToken.matches.push(openingToken);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tdefaultCase();\r\n\t\t}\r\n\t}\r\n\r\n\tfunction groupQuantifier(matches) {\r\n\t\tvar lastMatch = matches.pop();\r\n\t\tif (lastMatch.isQuantifier) {\r\n\t\t\tlastMatch = groupify([matches.pop(), lastMatch]);\r\n\t\t}\r\n\t\treturn lastMatch;\r\n\t}\r\n\r\n\tif (regexMask) {\r\n\t\topts.optionalmarker[0] = undefined;\r\n\t\topts.optionalmarker[1] = undefined;\r\n\t}\r\n\twhile ((match = regexMask ? regexTokenizer.exec(mask) : tokenizer.exec(mask))) {\r\n\t\tm = match[0];\r\n\r\n\t\tif (regexMask) {\r\n\t\t\tswitch (m.charAt(0)) {\r\n\t\t\t\t//Quantifier\r\n\t\t\t\tcase \"?\":\r\n\t\t\t\t\tm = \"{0,1}\";\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"+\":\r\n\t\t\t\tcase \"*\":\r\n\t\t\t\t\tm = \"{\" + m + \"}\";\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"|\":\r\n\t\t\t\t\t//regex mask alternator  ex: [01][0-9]|2[0-3] => ([01][0-9]|2[0-3])\r\n\t\t\t\t\tif (openenings.length === 0) { //wrap the mask in a group to form a regex alternator  ([01][0-9]|2[0-3])\r\n\t\t\t\t\t\tvar altRegexGroup = groupify(currentToken.matches);\r\n\t\t\t\t\t\taltRegexGroup.openGroup = true;\r\n\t\t\t\t\t\topenenings.push(altRegexGroup);\r\n\t\t\t\t\t\tcurrentToken.matches = [];\r\n\t\t\t\t\t\tcloseRegexGroup = true;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (escaped) {\r\n\t\t\tdefaultCase();\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tswitch (m.charAt(0)) {\r\n\t\t\tcase \"(?=\": //lookahead\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"(?!\": //negative lookahead\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"(?<=\": //lookbehind\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"(?<!\": //negative lookbehind\r\n\t\t\t\tbreak;\r\n\t\t\tcase opts.escapeChar:\r\n\t\t\t\tescaped = true;\r\n\t\t\t\tif (regexMask) {\r\n\t\t\t\t\tdefaultCase();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t// optional closing\r\n\t\t\tcase opts.optionalmarker[1]:\r\n\t\t\tcase opts.groupmarker[1]:\r\n\t\t\t\tcloseGroup();\r\n\t\t\t\tbreak;\r\n\t\t\tcase opts.optionalmarker[0]:\r\n\t\t\t\t// optional opening\r\n\t\t\t\topenenings.push(new MaskToken(false, true));\r\n\t\t\t\tbreak;\r\n\t\t\tcase opts.groupmarker[0]:\r\n\t\t\t\t// Group opening\r\n\t\t\t\topenenings.push(new MaskToken(true));\r\n\t\t\t\tbreak;\r\n\t\t\tcase opts.quantifiermarker[0]:\r\n\t\t\t\t//Quantifier\r\n\t\t\t\tvar quantifier = new MaskToken(false, false, true);\r\n\r\n\t\t\t\tm = m.replace(/[{}]/g, \"\");\r\n\t\t\t\tvar mqj = m.split(\"|\"),\r\n\t\t\t\t\tmq = mqj[0].split(\",\"),\r\n\t\t\t\t\tmq0 = isNaN(mq[0]) ? mq[0] : parseInt(mq[0]),\r\n\t\t\t\t\tmq1 = mq.length === 1 ? mq0 : (isNaN(mq[1]) ? mq[1] : parseInt(mq[1]));\r\n\t\t\t\tif (mq0 === \"*\" || mq0 === \"+\") {\r\n\t\t\t\t\tmq0 = mq1 === \"*\" ? 0 : 1;\r\n\t\t\t\t}\r\n\t\t\t\tquantifier.quantifier = {\r\n\t\t\t\t\tmin: mq0,\r\n\t\t\t\t\tmax: mq1,\r\n\t\t\t\t\tjit: mqj[1]\r\n\t\t\t\t};\r\n\t\t\t\tvar matches = openenings.length > 0 ? openenings[openenings.length - 1].matches : currentToken.matches;\r\n\t\t\t\tmatch = matches.pop();\r\n\t\t\t\tif (match.isAlternator) { //handle quantifier in an alternation [0-9]{2}|[0-9]{3}\r\n\t\t\t\t\tmatches.push(match); //push back alternator\r\n\t\t\t\t\tmatches = match.matches; //remap target matches\r\n\t\t\t\t\tvar groupToken = new MaskToken(true);\r\n\t\t\t\t\tvar tmpMatch = matches.pop();\r\n\t\t\t\t\tmatches.push(groupToken); //push the group\r\n\t\t\t\t\tmatches = groupToken.matches;\r\n\t\t\t\t\tmatch = tmpMatch;\r\n\t\t\t\t}\r\n\t\t\t\tif (!match.isGroup) {\r\n\t\t\t\t\t// if (regexMask && match.fn === null) { //why is this needed???\r\n\t\t\t\t\t//     if (match.def === \".\") match.fn = new RegExp(match.def, opts.casing ? \"i\" : \"\");\r\n\t\t\t\t\t// }\r\n\r\n\t\t\t\t\tmatch = groupify([match]);\r\n\t\t\t\t}\r\n\t\t\t\tmatches.push(match);\r\n\t\t\t\tmatches.push(quantifier);\r\n\r\n\t\t\t\tbreak;\r\n\t\t\tcase opts.alternatormarker:\r\n\r\n\r\n\t\t\t\tif (openenings.length > 0) {\r\n\t\t\t\t\tcurrentOpeningToken = openenings[openenings.length - 1];\r\n\t\t\t\t\tvar subToken = currentOpeningToken.matches[currentOpeningToken.matches.length - 1];\r\n\t\t\t\t\tif (currentOpeningToken.openGroup && //regexp alt syntax\r\n\t\t\t\t\t\t(subToken.matches === undefined || (subToken.isGroup === false && subToken.isAlternator === false))) { //alternations within group\r\n\t\t\t\t\t\tlastMatch = openenings.pop();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tlastMatch = groupQuantifier(currentOpeningToken.matches);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlastMatch = groupQuantifier(currentToken.matches);\r\n\t\t\t\t}\r\n\t\t\t\tif (lastMatch.isAlternator) {\r\n\t\t\t\t\topenenings.push(lastMatch);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (lastMatch.alternatorGroup) {\r\n\t\t\t\t\t\talternator = openenings.pop();\r\n\t\t\t\t\t\tlastMatch.alternatorGroup = false;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\talternator = new MaskToken(false, false, false, true);\r\n\t\t\t\t\t}\r\n\t\t\t\t\talternator.matches.push(lastMatch);\r\n\t\t\t\t\topenenings.push(alternator);\r\n\t\t\t\t\tif (lastMatch.openGroup) { //regexp alt syntax\r\n\t\t\t\t\t\tlastMatch.openGroup = false;\r\n\t\t\t\t\t\tvar alternatorGroup = new MaskToken(true);\r\n\t\t\t\t\t\talternatorGroup.alternatorGroup = true;\r\n\t\t\t\t\t\topenenings.push(alternatorGroup);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tdefaultCase();\r\n\t\t}\r\n\t}\r\n\r\n\tif (closeRegexGroup) closeGroup();\r\n\r\n\twhile (openenings.length > 0) {\r\n\t\topeningToken = openenings.pop();\r\n\t\tcurrentToken.matches.push(openingToken);\r\n\t}\r\n\tif (currentToken.matches.length > 0) {\r\n\t\tverifyGroupMarker(currentToken);\r\n\t\tmaskTokens.push(currentToken);\r\n\t}\r\n\r\n\tif (opts.numericInput || opts.isRTL) {\r\n\t\treverseTokens(maskTokens[0]);\r\n\t}\r\n\t// console.log(JSON.stringify(maskTokens));\r\n\treturn maskTokens;\r\n}\r\n\r\nmodule.exports = {\r\n\tgenerateMaskSet: generateMaskSet,\r\n\tanalyseMask: analyseMask\r\n};","var $ = require(\"./dependencyLibs/inputmask.dependencyLib\"), window = require(\"./global/window\"),\r\n\tdocument = window.document,\r\n\tua = window.navigator.userAgent,\r\n\tie = (ua.indexOf(\"MSIE \") > 0) || (ua.indexOf(\"Trident/\") > 0),\r\n\tmobile = isInputEventSupported(\"touchstart\"), //not entirely correct but will currently do\r\n\tiemobile = /iemobile/i.test(ua),\r\n\tiphone = /iphone/i.test(ua) && !iemobile;\r\n\r\nfunction isInputEventSupported(eventName) {\r\n\tvar el = document.createElement(\"input\"),\r\n\t\tevName = \"on\" + eventName,\r\n\t\tisSupported = (evName in el);\r\n\tif (!isSupported) {\r\n\t\tel.setAttribute(evName, \"return;\");\r\n\t\tisSupported = typeof el[evName] === \"function\";\r\n\t}\r\n\tel = null;\r\n\treturn isSupported;\r\n}\r\n\r\n//masking scope\r\n//actionObj definition see below\r\nmodule.exports = function maskScope(actionObj, maskset, opts) {\r\n\tmaskset = maskset || this.maskset;\r\n\topts = opts || this.opts;\r\n\r\n\tvar inputmask = this,\r\n\t\tel = this.el,\r\n\t\tisRTL = this.isRTL || (this.isRTL = opts.numericInput),\r\n\t\tundoValue,\r\n\t\t$el,\r\n\t\tskipKeyPressEvent = false, //Safari 5.1.x - modal dialog fires keypress twice workaround\r\n\t\tskipInputEvent = false, //skip when triggered from within inputmask\r\n\t\tignorable = false,\r\n\t\tmaxLength,\r\n\t\tmouseEnter = false,\r\n\t\tcolorMask,\r\n\t\toriginalPlaceholder,\r\n\t\tfocusDelay = 0;\r\n\r\n\t//maskset helperfunctions\r\n\tfunction getMaskTemplate(baseOnInput, minimalPos, includeMode, noJit, clearOptionalTail) {\r\n\t\t//includeMode true => input, undefined => placeholder, false => mask\r\n\r\n\t\tvar greedy = opts.greedy;\r\n\t\tif (clearOptionalTail) opts.greedy = false;\r\n\t\tminimalPos = minimalPos || 0;\r\n\t\tvar maskTemplate = [],\r\n\t\t\tndxIntlzr, pos = 0,\r\n\t\t\ttest, testPos;\r\n\t\tdo {\r\n\t\t\tif (baseOnInput === true && maskset.validPositions[pos]) {\r\n\t\t\t\ttestPos = (clearOptionalTail && maskset.validPositions[pos].match.optionality === true\r\n\t\t\t\t\t&& maskset.validPositions[pos + 1] === undefined\r\n\t\t\t\t\t&& (maskset.validPositions[pos].generatedInput === true || (maskset.validPositions[pos].input == opts.skipOptionalPartCharacter && pos > 0)))\r\n\t\t\t\t\t? determineTestTemplate(pos, getTests(pos, ndxIntlzr, pos - 1))\r\n\t\t\t\t\t: maskset.validPositions[pos];\r\n\t\t\t\ttest = testPos.match;\r\n\t\t\t\tndxIntlzr = testPos.locator.slice();\r\n\t\t\t\tmaskTemplate.push(includeMode === true ? testPos.input : includeMode === false ? test.nativeDef : getPlaceholder(pos, test));\r\n\t\t\t} else {\r\n\t\t\t\ttestPos = getTestTemplate(pos, ndxIntlzr, pos - 1);\r\n\t\t\t\ttest = testPos.match;\r\n\t\t\t\tndxIntlzr = testPos.locator.slice();\r\n\t\t\t\tvar jitMasking = noJit === true ? false : (opts.jitMasking !== false ? opts.jitMasking : test.jit);\r\n\t\t\t\tif (jitMasking === false || jitMasking === undefined /*|| pos < lvp*/ || (typeof jitMasking === \"number\" && isFinite(jitMasking) && jitMasking > pos)) {\r\n\t\t\t\t\tmaskTemplate.push(includeMode === false ? test.nativeDef : getPlaceholder(pos, test));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (opts.keepStatic === \"auto\") {\r\n\t\t\t\tif (test.newBlockMarker && test.static !== true) {\r\n\t\t\t\t\topts.keepStatic = pos - 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tpos++;\r\n\t\t} while ((maxLength === undefined || pos < maxLength) && (test.static !== true || test.def !== \"\") || minimalPos > pos);\r\n\t\tif (maskTemplate[maskTemplate.length - 1] === \"\") {\r\n\t\t\tmaskTemplate.pop(); //drop the last one which is empty\r\n\t\t}\r\n\t\tif (includeMode !== false || //do not alter the masklength when just retrieving the maskdefinition\r\n\t\t\tmaskset.maskLength === undefined) //just make sure the maskLength gets initialized in all cases (needed for isValid)\r\n\t\t{\r\n\t\t\tmaskset.maskLength = pos - 1;\r\n\t\t}\r\n\r\n\t\topts.greedy = greedy;\r\n\t\treturn maskTemplate;\r\n\t}\r\n\r\n\tfunction resetMaskSet(soft) {\r\n\t\tmaskset.buffer = undefined;\r\n\t\tif (soft !== true) {\r\n\t\t\tmaskset.validPositions = {};\r\n\t\t\tmaskset.p = 0;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getLastValidPosition(closestTo, strict, validPositions) {\r\n\t\tvar before = -1,\r\n\t\t\tafter = -1,\r\n\t\t\tvalids = validPositions || maskset.validPositions; //for use in valhook ~ context switch\r\n\t\tif (closestTo === undefined) closestTo = -1;\r\n\t\tfor (var posNdx in valids) {\r\n\t\t\tvar psNdx = parseInt(posNdx);\r\n\t\t\tif (valids[psNdx] && (strict || valids[psNdx].generatedInput !== true)) {\r\n\t\t\t\tif (psNdx <= closestTo) before = psNdx;\r\n\t\t\t\tif (psNdx >= closestTo) after = psNdx;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn (before === -1 || before == closestTo) ? after : after == -1 ? before : (closestTo - before) < (after - closestTo) ? before : after;\r\n\t}\r\n\r\n\tfunction getDecisionTaker(tst) {\r\n\t\tvar decisionTaker = tst.locator[tst.alternation];\r\n\t\tif (typeof decisionTaker == \"string\" && decisionTaker.length > 0) { //no decision taken ~ take first one as decider\r\n\t\t\tdecisionTaker = decisionTaker.split(\",\")[0];\r\n\t\t}\r\n\t\treturn decisionTaker !== undefined ? decisionTaker.toString() : \"\";\r\n\t}\r\n\r\n\tfunction getLocator(tst, align) { //need to align the locators to be correct\r\n\t\tvar locator = (tst.alternation != undefined ? tst.mloc[getDecisionTaker(tst)] : tst.locator).join(\"\");\r\n\t\tif (locator !== \"\") while (locator.length < align) locator += \"0\";\r\n\t\treturn locator;\r\n\t}\r\n\r\n\tfunction determineTestTemplate(pos, tests) {\r\n\t\tpos = pos > 0 ? pos - 1 : 0;\r\n\t\tvar altTest = getTest(pos), targetLocator = getLocator(altTest), tstLocator, closest, bestMatch;\r\n\t\tfor (var ndx = 0; ndx < tests.length; ndx++) { //find best matching\r\n\t\t\tvar tst = tests[ndx];\r\n\t\t\ttstLocator = getLocator(tst, targetLocator.length);\r\n\t\t\tvar distance = Math.abs(tstLocator - targetLocator);\r\n\t\t\tif (closest === undefined\r\n\t\t\t\t|| (tstLocator !== \"\" && distance < closest)\r\n\t\t\t\t|| (bestMatch && !opts.greedy && bestMatch.match.optionality && bestMatch.match.newBlockMarker === \"master\" && (!tst.match.optionality || !tst.match.newBlockMarker))\r\n\t\t\t\t|| (bestMatch && bestMatch.match.optionalQuantifier && !tst.match.optionalQuantifier)) {\r\n\t\t\t\tclosest = distance;\r\n\t\t\t\tbestMatch = tst;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn bestMatch;\r\n\t}\r\n\r\n\r\n\tfunction getTestTemplate(pos, ndxIntlzr, tstPs) {\r\n\t\treturn maskset.validPositions[pos] || determineTestTemplate(pos, getTests(pos, ndxIntlzr ? ndxIntlzr.slice() : ndxIntlzr, tstPs));\r\n\t}\r\n\r\n\tfunction getTest(pos, tests) {\r\n\t\tif (maskset.validPositions[pos]) {\r\n\t\t\treturn maskset.validPositions[pos];\r\n\t\t}\r\n\t\treturn (tests || getTests(pos))[0];\r\n\t}\r\n\r\n\tfunction positionCanMatchDefinition(pos, def) {\r\n\t\tvar valid = false,\r\n\t\t\ttests = getTests(pos);\r\n\t\tfor (var tndx = 0; tndx < tests.length; tndx++) {\r\n\t\t\tif (tests[tndx].match && tests[tndx].match.def === def) {\r\n\t\t\t\tvalid = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (valid === false) {\r\n\t\t\tif (maskset.jitOffset[pos] !== undefined) {\r\n\t\t\t\tvalid = positionCanMatchDefinition(pos + maskset.jitOffset[pos], def);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn valid;\r\n\t}\r\n\r\n\r\n\tfunction getTests(pos, ndxIntlzr, tstPs) {\r\n\t\tvar maskTokens = maskset.maskToken,\r\n\t\t\ttestPos = ndxIntlzr ? tstPs : 0,\r\n\t\t\tndxInitializer = ndxIntlzr ? ndxIntlzr.slice() : [0],\r\n\t\t\tmatches = [],\r\n\t\t\tinsertStop = false,\r\n\t\t\tlatestMatch,\r\n\t\t\tcacheDependency = ndxIntlzr ? ndxIntlzr.join(\"\") : \"\";\r\n\r\n\t\tfunction resolveTestFromToken(maskToken, ndxInitializer, loopNdx, quantifierRecurse) { //ndxInitializer contains a set of indexes to speedup searches in the mtokens\r\n\t\t\tfunction handleMatch(match, loopNdx, quantifierRecurse) {\r\n\t\t\t\tfunction isFirstMatch(latestMatch, tokenGroup) {\r\n\t\t\t\t\tvar firstMatch = $.inArray(latestMatch, tokenGroup.matches) === 0;\r\n\t\t\t\t\tif (!firstMatch) {\r\n\t\t\t\t\t\t$.each(tokenGroup.matches, function (ndx, match) {\r\n\t\t\t\t\t\t\tif (match.isQuantifier === true) {\r\n\t\t\t\t\t\t\t\tfirstMatch = isFirstMatch(latestMatch, tokenGroup.matches[ndx - 1]);\r\n\t\t\t\t\t\t\t} else if (match.hasOwnProperty(\"matches\")) firstMatch = isFirstMatch(latestMatch, match);\r\n\t\t\t\t\t\t\tif (firstMatch) return false;\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn firstMatch;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfunction resolveNdxInitializer(pos, alternateNdx, targetAlternation) {\r\n\t\t\t\t\tvar bestMatch, indexPos;\r\n\r\n\t\t\t\t\tif (maskset.tests[pos] || maskset.validPositions[pos]) {\r\n\t\t\t\t\t\t$.each(maskset.tests[pos] || [maskset.validPositions[pos]], function (ndx, lmnt) {\r\n\t\t\t\t\t\t\tif (lmnt.mloc[alternateNdx]) {\r\n\t\t\t\t\t\t\t\tbestMatch = lmnt;\r\n\t\t\t\t\t\t\t\treturn false; //break\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvar alternation = targetAlternation !== undefined ? targetAlternation : lmnt.alternation,\r\n\t\t\t\t\t\t\t\tndxPos = lmnt.locator[alternation] !== undefined ? lmnt.locator[alternation].toString().indexOf(alternateNdx) : -1;\r\n\t\t\t\t\t\t\tif ((indexPos === undefined || ndxPos < indexPos) && ndxPos !== -1) {\r\n\t\t\t\t\t\t\t\tbestMatch = lmnt;\r\n\t\t\t\t\t\t\t\tindexPos = ndxPos;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (bestMatch) {\r\n\t\t\t\t\t\tvar bestMatchAltIndex = bestMatch.locator[bestMatch.alternation];\r\n\t\t\t\t\t\tvar locator = bestMatch.mloc[alternateNdx] || bestMatch.mloc[bestMatchAltIndex] || bestMatch.locator;\r\n\t\t\t\t\t\treturn locator.slice((targetAlternation !== undefined ? targetAlternation : bestMatch.alternation) + 1);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn targetAlternation !== undefined ? resolveNdxInitializer(pos, alternateNdx) : undefined;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfunction isSubsetOf(source, target) {\r\n\t\t\t\t\tfunction expand(pattern) {\r\n\t\t\t\t\t\tvar expanded = [], start = -1, end;\r\n\t\t\t\t\t\tfor (var i = 0, l = pattern.length; i < l; i++) {\r\n\t\t\t\t\t\t\tif (pattern.charAt(i) === \"-\") {\r\n\t\t\t\t\t\t\t\tend = pattern.charCodeAt(i + 1);\r\n\t\t\t\t\t\t\t\twhile (++start < end) expanded.push(String.fromCharCode(start));\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tstart = pattern.charCodeAt(i);\r\n\t\t\t\t\t\t\t\texpanded.push(pattern.charAt(i));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn expanded.join(\"\");\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (opts.regex && source.match.static !== true && target.match.static !== true) { //is regex a subset\r\n\t\t\t\t\t\treturn expand(target.match.def.replace(/[[\\]]/g, \"\")).indexOf(expand(source.match.def.replace(/[[\\]]/g, \"\"))) !== -1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn source.match.def === target.match.nativeDef;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfunction staticCanMatchDefinition(source, target) {\r\n\t\t\t\t\tvar sloc = source.locator.slice(source.alternation).join(\"\"),\r\n\t\t\t\t\t\ttloc = target.locator.slice(target.alternation).join(\"\"), canMatch = sloc == tloc;\r\n\t\t\t\t\tcanMatch = canMatch && source.match.static === true && target.match.static !== true ? target.match.fn.test(source.match.def, maskset, pos, false, opts, false) : false;\r\n\r\n\t\t\t\t\treturn canMatch;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//mergelocators for retrieving the correct locator match when merging\r\n\t\t\t\tfunction setMergeLocators(targetMatch, altMatch) {\r\n\t\t\t\t\tif (altMatch === undefined || (targetMatch.alternation === altMatch.alternation &&\r\n\t\t\t\t\t\ttargetMatch.locator[targetMatch.alternation].toString().indexOf(altMatch.locator[altMatch.alternation]) === -1)) {\r\n\t\t\t\t\t\ttargetMatch.mloc = targetMatch.mloc || {};\r\n\t\t\t\t\t\tvar locNdx = targetMatch.locator[targetMatch.alternation];\r\n\t\t\t\t\t\tif (locNdx === undefined) {\r\n\t\t\t\t\t\t\ttargetMatch.alternation = undefined;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tif (typeof locNdx === \"string\") locNdx = locNdx.split(\",\")[0];\r\n\t\t\t\t\t\t\tif (targetMatch.mloc[locNdx] === undefined) targetMatch.mloc[locNdx] = targetMatch.locator.slice();\r\n\t\t\t\t\t\t\tif (altMatch !== undefined) {\r\n\t\t\t\t\t\t\t\tfor (var ndx in altMatch.mloc) {\r\n\t\t\t\t\t\t\t\t\tif (typeof ndx === \"string\") ndx = ndx.split(\",\")[0];\r\n\t\t\t\t\t\t\t\t\tif (targetMatch.mloc[ndx] === undefined) targetMatch.mloc[ndx] = altMatch.mloc[ndx];\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\ttargetMatch.locator[targetMatch.alternation] = Object.keys(targetMatch.mloc).join(\",\");\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (testPos > 500 && quantifierRecurse !== undefined) {\r\n\t\t\t\t\tthrow \"Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. \" + maskset.mask;\r\n\t\t\t\t}\r\n\t\t\t\tif (testPos === pos && match.matches === undefined) {\r\n\t\t\t\t\tmatches.push({\r\n\t\t\t\t\t\t\"match\": match,\r\n\t\t\t\t\t\t\"locator\": loopNdx.reverse(),\r\n\t\t\t\t\t\t\"cd\": cacheDependency,\r\n\t\t\t\t\t\t\"mloc\": {}\r\n\t\t\t\t\t});\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t} else if (match.matches !== undefined) {\r\n\t\t\t\t\tif (match.isGroup && quantifierRecurse !== match) { //when a group pass along to the quantifier\r\n\t\t\t\t\t\tmatch = handleMatch(maskToken.matches[$.inArray(match, maskToken.matches) + 1], loopNdx, quantifierRecurse);\r\n\t\t\t\t\t\tif (match) return true;\r\n\t\t\t\t\t} else if (match.isOptional) {\r\n\t\t\t\t\t\tvar optionalToken = match, mtchsNdx = matches.length;\r\n\t\t\t\t\t\tmatch = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse);\r\n\t\t\t\t\t\tif (match) {\r\n\t\t\t\t\t\t\t//mark optionality in matches\r\n\t\t\t\t\t\t\t$.each(matches, function (ndx, mtch) {\r\n\t\t\t\t\t\t\t\tif (ndx >= mtchsNdx) {\r\n\t\t\t\t\t\t\t\t\tmtch.match.optionality = true;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\tlatestMatch = matches[matches.length - 1].match;\r\n\t\t\t\t\t\t\tif (quantifierRecurse === undefined && isFirstMatch(latestMatch, optionalToken)) { //prevent loop see #698\r\n\t\t\t\t\t\t\t\tinsertStop = true; //insert a stop\r\n\t\t\t\t\t\t\t\ttestPos = pos; //match the position after the group\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (match.isAlternator) {\r\n\t\t\t\t\t\tvar alternateToken = match,\r\n\t\t\t\t\t\t\tmalternateMatches = [],\r\n\t\t\t\t\t\t\tmaltMatches,\r\n\t\t\t\t\t\t\tcurrentMatches = matches.slice(),\r\n\t\t\t\t\t\t\tloopNdxCnt = loopNdx.length;\r\n\t\t\t\t\t\tvar altIndex = ndxInitializer.length > 0 ? ndxInitializer.shift() : -1;\r\n\t\t\t\t\t\tif (altIndex === -1 || typeof altIndex === \"string\") {\r\n\t\t\t\t\t\t\tvar currentPos = testPos,\r\n\t\t\t\t\t\t\t\tndxInitializerClone = ndxInitializer.slice(),\r\n\t\t\t\t\t\t\t\taltIndexArr = [],\r\n\t\t\t\t\t\t\t\tamndx;\r\n\t\t\t\t\t\t\tif (typeof altIndex == \"string\") {\r\n\t\t\t\t\t\t\t\taltIndexArr = altIndex.split(\",\");\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tfor (amndx = 0; amndx < alternateToken.matches.length; amndx++) {\r\n\t\t\t\t\t\t\t\t\taltIndexArr.push(amndx.toString());\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (maskset.excludes[pos]) {\r\n\t\t\t\t\t\t\t\tvar altIndexArrClone = altIndexArr.slice();\r\n\t\t\t\t\t\t\t\tfor (var i = 0, el = maskset.excludes[pos].length; i < el; i++) {\r\n\t\t\t\t\t\t\t\t\taltIndexArr.splice(altIndexArr.indexOf(maskset.excludes[pos][i].toString()), 1);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif (altIndexArr.length === 0) { //fully alternated => reset\r\n\t\t\t\t\t\t\t\t\tmaskset.excludes[pos] = undefined;\r\n\t\t\t\t\t\t\t\t\taltIndexArr = altIndexArrClone;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (opts.keepStatic === true || (isFinite(parseInt(opts.keepStatic)) && currentPos >= opts.keepStatic)) altIndexArr = altIndexArr.slice(0, 1);\r\n\t\t\t\t\t\t\tvar unMatchedAlternation = false;\r\n\t\t\t\t\t\t\tfor (var ndx = 0; ndx < altIndexArr.length; ndx++) {\r\n\t\t\t\t\t\t\t\tamndx = parseInt(altIndexArr[ndx]);\r\n\t\t\t\t\t\t\t\tmatches = [];\r\n\t\t\t\t\t\t\t\t//set the correct ndxInitializer\r\n\t\t\t\t\t\t\t\tndxInitializer = typeof altIndex === \"string\" ? resolveNdxInitializer(testPos, amndx, loopNdxCnt) || ndxInitializerClone.slice() : ndxInitializerClone.slice();\r\n\t\t\t\t\t\t\t\tif (alternateToken.matches[amndx] && handleMatch(alternateToken.matches[amndx], [amndx].concat(loopNdx), quantifierRecurse)) {\r\n\t\t\t\t\t\t\t\t\tmatch = true;\r\n\t\t\t\t\t\t\t\t} else if (ndx === 0) {\r\n\t\t\t\t\t\t\t\t\tunMatchedAlternation = true;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tmaltMatches = matches.slice();\r\n\t\t\t\t\t\t\t\ttestPos = currentPos;\r\n\t\t\t\t\t\t\t\tmatches = [];\r\n\r\n\t\t\t\t\t\t\t\t//fuzzy merge matches\r\n\t\t\t\t\t\t\t\tfor (var ndx1 = 0; ndx1 < maltMatches.length; ndx1++) {\r\n\t\t\t\t\t\t\t\t\tvar altMatch = maltMatches[ndx1],\r\n\t\t\t\t\t\t\t\t\t\tdropMatch = false;\r\n\t\t\t\t\t\t\t\t\taltMatch.match.jit = altMatch.match.jit || unMatchedAlternation; //mark jit when there are unmatched alternations  ex: mask: \"(a|aa)\"\r\n\t\t\t\t\t\t\t\t\taltMatch.alternation = altMatch.alternation || loopNdxCnt;\r\n\t\t\t\t\t\t\t\t\tsetMergeLocators(altMatch);\r\n\t\t\t\t\t\t\t\t\tfor (var ndx2 = 0; ndx2 < malternateMatches.length; ndx2++) {\r\n\t\t\t\t\t\t\t\t\t\tvar altMatch2 = malternateMatches[ndx2];\r\n\t\t\t\t\t\t\t\t\t\tif (typeof altIndex !== \"string\" || (altMatch.alternation !== undefined && $.inArray(altMatch.locator[altMatch.alternation].toString(), altIndexArr) !== -1)) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (altMatch.match.nativeDef === altMatch2.match.nativeDef) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tdropMatch = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\tsetMergeLocators(altMatch2, altMatch);\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t} else if (isSubsetOf(altMatch, altMatch2)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (setMergeLocators(altMatch, altMatch2)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tdropMatch = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tmalternateMatches.splice(malternateMatches.indexOf(altMatch2), 0, altMatch);\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t} else if (isSubsetOf(altMatch2, altMatch)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tsetMergeLocators(altMatch2, altMatch);\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t} else if (staticCanMatchDefinition(altMatch, altMatch2)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (setMergeLocators(altMatch, altMatch2)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//insert match above general match\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tdropMatch = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tmalternateMatches.splice(malternateMatches.indexOf(altMatch2), 0, altMatch);\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif (!dropMatch) {\r\n\t\t\t\t\t\t\t\t\t\tmalternateMatches.push(altMatch);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tmatches = currentMatches.concat(malternateMatches);\r\n\t\t\t\t\t\t\ttestPos = pos;\r\n\t\t\t\t\t\t\tinsertStop = matches.length > 0; //insert a stopelemnt when there is an alternate - needed for non-greedy option\r\n\t\t\t\t\t\t\tmatch = malternateMatches.length > 0; //set correct match state\r\n\r\n\t\t\t\t\t\t\t//cloneback\r\n\t\t\t\t\t\t\tndxInitializer = ndxInitializerClone.slice();\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tmatch = handleMatch(alternateToken.matches[altIndex] || maskToken.matches[altIndex], [altIndex].concat(loopNdx), quantifierRecurse);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (match) return true;\r\n\t\t\t\t\t} else if (match.isQuantifier && quantifierRecurse !== maskToken.matches[$.inArray(match, maskToken.matches) - 1]) {\r\n\t\t\t\t\t\tvar qt = match;\r\n\t\t\t\t\t\tfor (var qndx = (ndxInitializer.length > 0) ? ndxInitializer.shift() : 0; (qndx < (isNaN(qt.quantifier.max) ? qndx + 1 : qt.quantifier.max)) && testPos <= pos; qndx++) {\r\n\t\t\t\t\t\t\tvar tokenGroup = maskToken.matches[$.inArray(qt, maskToken.matches) - 1];\r\n\t\t\t\t\t\t\tmatch = handleMatch(tokenGroup, [qndx].concat(loopNdx), tokenGroup); //set the tokenGroup as quantifierRecurse marker\r\n\t\t\t\t\t\t\tif (match) {\r\n\t\t\t\t\t\t\t\t//get latest match\r\n\t\t\t\t\t\t\t\tlatestMatch = matches[matches.length - 1].match;\r\n\t\t\t\t\t\t\t\t//mark optionality\r\n\t\t\t\t\t\t\t\t//TODO FIX RECURSIVE QUANTIFIERS\r\n\t\t\t\t\t\t\t\tlatestMatch.optionalQuantifier = qndx >= qt.quantifier.min;\r\n\t\t\t\t\t\t\t\t// console.log(pos + \" \" + qt.quantifier.min + \" \" + latestMatch.optionalQuantifier);\r\n\t\t\t\t\t\t\t\tlatestMatch.jit = (qndx || 1) * tokenGroup.matches.indexOf(latestMatch) >= qt.quantifier.jit;\r\n\t\t\t\t\t\t\t\tif (latestMatch.optionalQuantifier && isFirstMatch(latestMatch, tokenGroup)) {\r\n\t\t\t\t\t\t\t\t\tinsertStop = true;\r\n\t\t\t\t\t\t\t\t\ttestPos = pos; //match the position after the group\r\n\t\t\t\t\t\t\t\t\tbreak; //stop quantifierloop && search for next possible match\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif (latestMatch.jit /*&& !latestMatch.optionalQuantifier*/) {\r\n\t\t\t\t\t\t\t\t\t//always set jitOffset, isvalid checks when to apply\r\n\t\t\t\t\t\t\t\t\tmaskset.jitOffset[pos] = tokenGroup.matches.length - tokenGroup.matches.indexOf(latestMatch);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tmatch = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse);\r\n\t\t\t\t\t\tif (match) return true;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttestPos++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t//the offset is set in the quantifierloop when git masking is used\r\n\t\t\tfor (var tndx = (ndxInitializer.length > 0 ? ndxInitializer.shift() : 0); tndx < maskToken.matches.length; tndx++) {\r\n\t\t\t\tif (maskToken.matches[tndx].isQuantifier !== true) {\r\n\t\t\t\t\tvar match = handleMatch(maskToken.matches[tndx], [tndx].concat(loopNdx), quantifierRecurse);\r\n\t\t\t\t\tif (match && testPos === pos) {\r\n\t\t\t\t\t\treturn match;\r\n\t\t\t\t\t} else if (testPos > pos) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction mergeLocators(pos, tests) {\r\n\t\t\tvar locator = [];\r\n\t\t\tif (!$.isArray(tests)) tests = [tests];\r\n\t\t\tif (tests.length > 0) {\r\n\t\t\t\tif (tests[0].alternation === undefined || opts.keepStatic === true) {\r\n\t\t\t\t\tlocator = determineTestTemplate(pos, tests.slice()).locator.slice();\r\n\t\t\t\t\tif (locator.length === 0) locator = tests[0].locator.slice();\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$.each(tests, function (ndx, tst) {\r\n\t\t\t\t\t\tif (tst.def !== \"\") {\r\n\t\t\t\t\t\t\tif (locator.length === 0) {\r\n\t\t\t\t\t\t\t\tlocator = tst.locator.slice();\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tfor (var i = 0; i < locator.length; i++) {\r\n\t\t\t\t\t\t\t\t\tif (tst.locator[i] && locator[i].toString().indexOf(tst.locator[i]) === -1) {\r\n\t\t\t\t\t\t\t\t\t\tlocator[i] += \",\" + tst.locator[i];\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn locator;\r\n\t\t}\r\n\r\n\t\tif (pos > -1 && (maxLength === undefined || pos < maxLength)) {\r\n\t\t\tif (ndxIntlzr === undefined) { //determine index initializer\r\n\t\t\t\tvar previousPos = pos - 1,\r\n\t\t\t\t\ttest;\r\n\t\t\t\twhile ((test = maskset.validPositions[previousPos] || maskset.tests[previousPos]) === undefined && previousPos > -1) {\r\n\t\t\t\t\tpreviousPos--;\r\n\t\t\t\t}\r\n\t\t\t\tif (test !== undefined && previousPos > -1) {\r\n\t\t\t\t\tndxInitializer = mergeLocators(previousPos, test);\r\n\t\t\t\t\tcacheDependency = ndxInitializer.join(\"\");\r\n\t\t\t\t\ttestPos = previousPos;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (maskset.tests[pos] && maskset.tests[pos][0].cd === cacheDependency) { //cacheDependency is set on all tests, just check on the first\r\n\t\t\t\treturn maskset.tests[pos];\r\n\t\t\t}\r\n\t\t\tfor (var mtndx = ndxInitializer.shift(); mtndx < maskTokens.length; mtndx++) {\r\n\t\t\t\tvar match = resolveTestFromToken(maskTokens[mtndx], ndxInitializer, [mtndx]);\r\n\t\t\t\tif ((match && testPos === pos) || testPos > pos) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (matches.length === 0 || insertStop) {\r\n\t\t\tmatches.push({\r\n\t\t\t\tmatch: {\r\n\t\t\t\t\tfn: null,\r\n\t\t\t\t\tstatic: true,\r\n\t\t\t\t\toptionality: false,\r\n\t\t\t\t\tcasing: null,\r\n\t\t\t\t\tdef: \"\",\r\n\t\t\t\t\tplaceholder: \"\"\r\n\t\t\t\t},\r\n\t\t\t\tlocator: [],\r\n\t\t\t\tmloc: {},\r\n\t\t\t\tcd: cacheDependency\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif (ndxIntlzr !== undefined && maskset.tests[pos]) { //prioritize full tests for caching\r\n\t\t\treturn $.extend(true, [], matches);\r\n\t\t}\r\n\t\tmaskset.tests[pos] = $.extend(true, [], matches); //set a clone to prevent overwriting some props\r\n\t\t// console.log(pos + \" - \" + JSON.stringify(matches));\r\n\t\treturn maskset.tests[pos];\r\n\t}\r\n\r\n\tfunction getBufferTemplate() {\r\n\t\tif (maskset._buffer === undefined) {\r\n\t\t\t//generate template\r\n\t\t\tmaskset._buffer = getMaskTemplate(false, 1);\r\n\t\t\tif (maskset.buffer === undefined) maskset.buffer = maskset._buffer.slice();\r\n\t\t}\r\n\t\treturn maskset._buffer;\r\n\t}\r\n\r\n\tfunction getBuffer(noCache) {\r\n\t\tif (maskset.buffer === undefined || noCache === true) {\r\n\t\t\tmaskset.buffer = getMaskTemplate(true, getLastValidPosition(), true);\r\n\t\t\tif (maskset._buffer === undefined) maskset._buffer = maskset.buffer.slice();\r\n\t\t}\r\n\t\treturn maskset.buffer;\r\n\t}\r\n\r\n\tfunction refreshFromBuffer(start, end, buffer) {\r\n\t\tvar i, p;\r\n\t\tif (start === true) {\r\n\t\t\tresetMaskSet();\r\n\t\t\tmaskset.tests = {}; //refresh tests after possible alternating\r\n\t\t\tstart = 0;\r\n\t\t\tend = buffer.length;\r\n\t\t} else {\r\n\t\t\tfor (i = start; i < end; i++) {\r\n\t\t\t\tdelete maskset.validPositions[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\tp = start;\r\n\t\tfor (i = start; i < end; i++) {\r\n\t\t\t// resetMaskSet(true); //prevents clobber from the buffer\r\n\t\t\tif (buffer[i] !== opts.skipOptionalPartCharacter) {\r\n\t\t\t\tvar valResult = isValid(p, buffer[i], opts.negationSymbol ? [i] !== opts.negationSymbol.front : true, opts.negationSymbol ? [i] !== opts.negationSymbol.front : true);  //hackery for + validator (numeric alias)\r\n\t\t\t\tif (valResult !== false) {\r\n\t\t\t\t\t// resetMaskSet(true);\r\n\t\t\t\t\tp = valResult.caret !== undefined ? valResult.caret : valResult.pos + 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction casing(elem, test, pos) {\r\n\t\tswitch (opts.casing || test.casing) {\r\n\t\t\tcase \"upper\":\r\n\t\t\t\telem = elem.toUpperCase();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"lower\":\r\n\t\t\t\telem = elem.toLowerCase();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"title\":\r\n\t\t\t\tvar posBefore = maskset.validPositions[pos - 1];\r\n\t\t\t\tif (pos === 0 || posBefore && posBefore.input === String.fromCharCode(Inputmask.keyCode.SPACE)) {\r\n\t\t\t\t\telem = elem.toUpperCase();\r\n\t\t\t\t} else {\r\n\t\t\t\t\telem = elem.toLowerCase();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tif ($.isFunction(opts.casing)) {\r\n\t\t\t\t\tvar args = Array.prototype.slice.call(arguments);\r\n\t\t\t\t\targs.push(maskset.validPositions);\r\n\t\t\t\t\telem = opts.casing.apply(this, args);\r\n\t\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn elem;\r\n\t}\r\n\r\n\tfunction checkAlternationMatch(altArr1, altArr2, na) {\r\n\t\tvar altArrC = opts.greedy ? altArr2 : altArr2.slice(0, 1),\r\n\t\t\tisMatch = false,\r\n\t\t\tnaArr = na !== undefined ? na.split(\",\") : [],\r\n\t\t\tnaNdx;\r\n\r\n\t\t//remove no alternate indexes from alternation array\r\n\t\tfor (var i = 0; i < naArr.length; i++) {\r\n\t\t\tif ((naNdx = altArr1.indexOf(naArr[i])) !== -1) {\r\n\t\t\t\taltArr1.splice(naNdx, 1);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (var alndx = 0; alndx < altArr1.length; alndx++) {\r\n\t\t\tif ($.inArray(altArr1[alndx], altArrC) !== -1) {\r\n\t\t\t\tisMatch = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn isMatch;\r\n\t}\r\n\r\n\tfunction alternate(pos, c, strict, fromIsValid, rAltPos) { //pos == true => generalize\r\n\t\tvar validPsClone = $.extend(true, {}, maskset.validPositions),\r\n\t\t\tlastAlt,\r\n\t\t\talternation,\r\n\t\t\tisValidRslt = false, returnRslt = false,\r\n\t\t\taltPos, prevAltPos, i, validPos,\r\n\t\t\tdecisionPos,\r\n\t\t\tlAltPos = rAltPos !== undefined ? rAltPos : getLastValidPosition();\r\n\r\n\t\tfunction insertPosition(insert) {\r\n\t\t\tif (insert) {\r\n\t\t\t\tif (isValidRslt && c !== undefined) {\r\n\t\t\t\t\tvar targetLvp = getLastValidPosition(pos) + 1;\r\n\t\t\t\t\tfor (i = decisionPos; i < getLastValidPosition() + 1; i++) {\r\n\t\t\t\t\t\tvalidPos = maskset.validPositions[i];\r\n\t\t\t\t\t\tif ((validPos === undefined || validPos.match.static == true) && i < (pos + posOffset)) {\r\n\t\t\t\t\t\t\tposOffset++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpos = pos + posOffset;\r\n\t\t\t\t\tisValidRslt = returnRslt = isValid(pos > targetLvp ? targetLvp : pos, c, strict, fromIsValid, true);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (lAltPos === -1 && rAltPos === undefined) { //do not recurse when already paste the beginning\r\n\t\t\tlastAlt = 0;\r\n\t\t\tprevAltPos = getTest(lastAlt);\r\n\t\t\talternation = prevAltPos.alternation;\r\n\t\t} else {\r\n\t\t\t//find last modified alternation\r\n\t\t\tfor (; lAltPos >= 0; lAltPos--) {\r\n\t\t\t\taltPos = maskset.validPositions[lAltPos];\r\n\t\t\t\tif (altPos && altPos.alternation !== undefined) {\r\n\t\t\t\t\tif (prevAltPos && prevAltPos.locator[altPos.alternation] !== altPos.locator[altPos.alternation]) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlastAlt = lAltPos;\r\n\t\t\t\t\talternation = maskset.validPositions[lastAlt].alternation;\r\n\t\t\t\t\tprevAltPos = altPos;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (alternation !== undefined) {\r\n\t\t\tdecisionPos = parseInt(lastAlt);\r\n\t\t\tmaskset.excludes[decisionPos] = maskset.excludes[decisionPos] || [];\r\n\t\t\tif (pos !== true) { //generalize\r\n\t\t\t\tmaskset.excludes[decisionPos].push(getDecisionTaker(prevAltPos));\r\n\t\t\t}\r\n\r\n\t\t\tvar validInputsClone = [], staticInputsBeforePos = 0;\r\n\t\t\tfor (i = decisionPos; i < getLastValidPosition(undefined, true) + 1; i++) {\r\n\t\t\t\tvalidPos = maskset.validPositions[i];\r\n\t\t\t\tif (validPos && validPos.generatedInput !== true /*&& /[0-9a-bA-Z]/.test(validPos.input)*/) {\r\n\t\t\t\t\tvalidInputsClone.push(validPos.input);\r\n\t\t\t\t} else if (i < pos) staticInputsBeforePos++;\r\n\t\t\t\tdelete maskset.validPositions[i];\r\n\t\t\t}\r\n\r\n\t\t\twhile (maskset.excludes[decisionPos] && maskset.excludes[decisionPos].length < 10) {\r\n\t\t\t\tvar posOffset = staticInputsBeforePos * -1, //negate\r\n\t\t\t\t\tvalidInputs = validInputsClone.slice();\r\n\t\t\t\tmaskset.tests[decisionPos] = undefined; //clear decisionPos\r\n\t\t\t\tresetMaskSet(true); //clear getbuffer\r\n\t\t\t\tisValidRslt = true;\r\n\t\t\t\tinsertPosition(pos === 0);\r\n\t\t\t\twhile (validInputs.length > 0) {\r\n\t\t\t\t\tvar input = validInputs.shift();\r\n\t\t\t\t\tif (!(isValidRslt = isValid(isValidRslt.caret || (getLastValidPosition(undefined, true) + 1), input, false, fromIsValid, true))) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tinsertPosition(pos > 0);\r\n\t\t\t\tif (!isValidRslt) {\r\n\t\t\t\t\tresetMaskSet();\r\n\t\t\t\t\tprevAltPos = getTest(decisionPos);  //get the current decisionPos to exclude ~ needs to be before restoring the initial validation\r\n\t\t\t\t\t//reset & revert\r\n\t\t\t\t\tmaskset.validPositions = $.extend(true, {}, validPsClone);\r\n\t\t\t\t\tif (maskset.excludes[decisionPos]) {\r\n\t\t\t\t\t\tvar decisionTaker = getDecisionTaker(prevAltPos);\r\n\t\t\t\t\t\tif (maskset.excludes[decisionPos].indexOf(decisionTaker) !== -1) {\r\n\t\t\t\t\t\t\tisValidRslt = alternate(pos, c, strict, fromIsValid, decisionPos - 1);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tmaskset.excludes[decisionPos].push(decisionTaker);\r\n\t\t\t\t\t\tfor (i = decisionPos; i < getLastValidPosition(undefined, true) + 1; i++) delete maskset.validPositions[i];\r\n\t\t\t\t\t} else { //latest alternation\r\n\t\t\t\t\t\tisValidRslt = alternate(pos, c, strict, fromIsValid, decisionPos - 1);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t//reset alternation excludes\r\n\t\tmaskset.excludes[decisionPos] = undefined;\r\n\t\treturn returnRslt;\r\n\t}\r\n\r\n\tfunction isValid(pos, c, strict, fromIsValid, fromAlternate, validateOnly) { //strict true ~ no correction or autofill\r\n\t\tfunction isSelection(posObj) {\r\n\t\t\treturn isRTL ? (posObj.begin - posObj.end) > 1 || ((posObj.begin - posObj.end) === 1) :\r\n\t\t\t\t(posObj.end - posObj.begin) > 1 || ((posObj.end - posObj.begin) === 1);\r\n\t\t}\r\n\r\n\t\tstrict = strict === true; //always set a value to strict to prevent possible strange behavior in the extensions\r\n\r\n\t\tvar maskPos = pos;\r\n\t\tif (pos.begin !== undefined) { //position was a position object - used to handle a delete by typing over a selection\r\n\t\t\tmaskPos = isRTL ? pos.end : pos.begin;\r\n\t\t}\r\n\r\n\t\tfunction processCommandObject(commandObj) {\r\n\t\t\tif (commandObj !== undefined) {\r\n\t\t\t\tif (commandObj.remove !== undefined) { //remove position(s)\r\n\t\t\t\t\tif (!$.isArray(commandObj.remove)) commandObj.remove = [commandObj.remove];\r\n\t\t\t\t\t$.each(commandObj.remove.sort(function (a, b) {\r\n\t\t\t\t\t\treturn b.pos - a.pos;\r\n\t\t\t\t\t}), function (ndx, lmnt) {\r\n\t\t\t\t\t\trevalidateMask({begin: lmnt, end: lmnt + 1});\r\n\t\t\t\t\t});\r\n\t\t\t\t\tcommandObj.remove = undefined;\r\n\t\t\t\t}\r\n\t\t\t\tif (commandObj.insert !== undefined) { //insert position(s)\r\n\t\t\t\t\tif (!$.isArray(commandObj.insert)) commandObj.insert = [commandObj.insert];\r\n\t\t\t\t\t$.each(commandObj.insert.sort(function (a, b) {\r\n\t\t\t\t\t\treturn a.pos - b.pos;\r\n\t\t\t\t\t}), function (ndx, lmnt) {\r\n\t\t\t\t\t\tisValid(lmnt.pos, lmnt.c, lmnt.strict !== undefined ? lmnt.strict : true, lmnt.fromIsValid !== undefined ? lmnt.fromIsValid : fromIsValid);\r\n\t\t\t\t\t});\r\n\t\t\t\t\tcommandObj.insert = undefined;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (commandObj.refreshFromBuffer && commandObj.buffer) {\r\n\t\t\t\t\tvar refresh = commandObj.refreshFromBuffer;\r\n\t\t\t\t\trefreshFromBuffer(refresh === true ? refresh : refresh.start, refresh.end, commandObj.buffer);\r\n\t\t\t\t\tcommandObj.refreshFromBuffer = undefined;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (commandObj.rewritePosition !== undefined) {\r\n\t\t\t\t\tmaskPos = commandObj.rewritePosition;\r\n\t\t\t\t\tcommandObj = true;\r\n\t\t\t\t\tcommandObj.rewritePosition = undefined;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn commandObj;\r\n\t\t}\r\n\r\n\t\tfunction _isValid(position, c, strict) {\r\n\t\t\tvar rslt = false;\r\n\r\n\t\t\t$.each(getTests(position), function (ndx, tst) {\r\n\t\t\t\tvar test = tst.match;\r\n\t\t\t\t//make sure the buffer is set and correct\r\n\t\t\t\tgetBuffer(true);\r\n\t\t\t\t//return is false or a json object => { pos: ??, c: ??} or true\r\n\t\t\t\trslt = test.fn != null ?\r\n\t\t\t\t\ttest.fn.test(c, maskset, position, strict, opts, isSelection(pos)) : (c === test.def || c === opts.skipOptionalPartCharacter) && test.def !== \"\" ? //non mask\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tc: getPlaceholder(position, test, true) || test.def,\r\n\t\t\t\t\t\t\tpos: position\r\n\t\t\t\t\t\t} : false;\r\n\r\n\t\t\t\tif (rslt !== false) {\r\n\t\t\t\t\tvar elem = rslt.c !== undefined ? rslt.c : c, validatedPos = position;\r\n\t\t\t\t\telem = (elem === opts.skipOptionalPartCharacter && test.static === true) ?\r\n\t\t\t\t\t\t(getPlaceholder(position, test, true) || test.def) : elem;\r\n\r\n\t\t\t\t\trslt = processCommandObject(rslt);\r\n\r\n\t\t\t\t\tif (rslt !== true && rslt.pos !== undefined && rslt.pos !== position) { //their is a position offset\r\n\t\t\t\t\t\tvalidatedPos = rslt.pos;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (rslt !== true && rslt.pos === undefined && rslt.c === undefined) {\r\n\t\t\t\t\t\treturn false; //breakout if nothing to insert\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!revalidateMask(pos, $.extend({}, tst, {\r\n\t\t\t\t\t\t\"input\": casing(elem, test, validatedPos)\r\n\t\t\t\t\t}), fromIsValid, validatedPos)) {\r\n\t\t\t\t\t\trslt = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn false; //break from $.each\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\treturn rslt;\r\n\t\t}\r\n\r\n\t\tvar result = true,\r\n\t\t\tpositionsClone = $.extend(true, {}, maskset.validPositions); //clone the currentPositions\r\n\r\n\t\tif ($.isFunction(opts.preValidation) && !strict && fromIsValid !== true && validateOnly !== true && fromAlternate !== true) {\r\n\t\t\tresult = opts.preValidation(getBuffer(), maskPos, c, isSelection(pos), opts, maskset);\r\n\t\t\tresult = processCommandObject(result);\r\n\t\t}\r\n\t\tif (result === true) { //preValidation result\r\n\t\t\tif (maxLength === undefined || maskPos < maxLength) {\r\n\t\t\t\tresult = _isValid(maskPos, c, strict);\r\n\t\t\t\tif ((!strict || fromIsValid === true) && result === false && validateOnly !== true) {\r\n\t\t\t\t\tvar currentPosValid = maskset.validPositions[maskPos];\r\n\t\t\t\t\tif (currentPosValid && currentPosValid.match.static === true && (currentPosValid.match.def === c || c === opts.skipOptionalPartCharacter)) {\r\n\t\t\t\t\t\tresult = {\r\n\t\t\t\t\t\t\t\"caret\": seekNext(maskPos)\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (opts.insertMode || maskset.validPositions[seekNext(maskPos)] === undefined) { //does the input match on a further position?\r\n\t\t\t\t\t\t\tvar skip = false;\r\n\t\t\t\t\t\t\tif (maskset.jitOffset[maskPos] && maskset.validPositions[seekNext(maskPos)] === undefined) {\r\n\t\t\t\t\t\t\t\tresult = isValid(maskPos + maskset.jitOffset[maskPos], c, true);\r\n\t\t\t\t\t\t\t\tif (result !== false) {\r\n\t\t\t\t\t\t\t\t\tif (fromAlternate !== true) result.caret = maskPos;\r\n\t\t\t\t\t\t\t\t\tskip = true;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (!skip && !isMask(maskPos, true)) {\r\n\t\t\t\t\t\t\t\tfor (var nPos = maskPos + 1, snPos = seekNext(maskPos); nPos <= snPos; nPos++) {\r\n\t\t\t\t\t\t\t\t\t// if (!isMask(nPos, true)) {\r\n\t\t\t\t\t\t\t\t\t// \tcontinue;\r\n\t\t\t\t\t\t\t\t\t// }\r\n\t\t\t\t\t\t\t\t\tresult = _isValid(nPos, c, strict);\r\n\t\t\t\t\t\t\t\t\tif (result !== false) {\r\n\t\t\t\t\t\t\t\t\t\tresult = trackbackPositions(maskPos, result.pos !== undefined ? result.pos : nPos) || result;\r\n\t\t\t\t\t\t\t\t\t\tmaskPos = nPos;\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (result === false && opts.keepStatic !== false && (opts.regex == null || isComplete(getBuffer())) && !strict && fromAlternate !== true) { //try fuzzy alternator logic\r\n\t\t\t\tresult = alternate(maskPos, c, strict, fromIsValid);\r\n\t\t\t}\r\n\t\t\tif (result === true) {\r\n\t\t\t\tresult = {\r\n\t\t\t\t\t\"pos\": maskPos\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\t\tif ($.isFunction(opts.postValidation) && result !== false && !strict && fromIsValid !== true && validateOnly !== true) {\r\n\t\t\tvar postResult = opts.postValidation(getBuffer(true), pos.begin !== undefined ? (isRTL ? pos.end : pos.begin) : pos, result, opts);\r\n\t\t\tif (postResult !== undefined) {\r\n\t\t\t\tresult = postResult === true ? result : postResult;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (result && result.pos === undefined) {\r\n\t\t\tresult.pos = maskPos;\r\n\t\t}\r\n\r\n\t\tif (result === false || validateOnly === true) {\r\n\t\t\tresetMaskSet(true);\r\n\t\t\tmaskset.validPositions = $.extend(true, {}, positionsClone); //revert validation changes\r\n\t\t} else {\r\n\t\t\ttrackbackPositions(undefined, maskPos, true);\r\n\t\t}\r\n\r\n\t\tvar endResult = processCommandObject(result);\r\n\t\t// console.log(\"returned result \" + JSON.stringify(endResult));\r\n\t\treturn endResult;\r\n\t}\r\n\r\n\t//fill in best positions according the current input\r\n\tfunction trackbackPositions(originalPos, newPos, fillOnly) {\r\n\t\t// console.log(\"trackbackPositions \" + originalPos + \" \" + newPos);\r\n\t\tif (originalPos === undefined) {\r\n\t\t\t//find previous valid\r\n\t\t\tfor (originalPos = newPos - 1; originalPos > 0; originalPos--) {\r\n\t\t\t\tif (maskset.validPositions[originalPos]) break;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (var ps = originalPos; ps < newPos; ps++) {\r\n\t\t\tif (maskset.validPositions[ps] === undefined && !isMask(ps, true)) {\r\n\t\t\t\tvar vp = ps == 0 ? getTest(ps) : maskset.validPositions[ps - 1];\r\n\t\t\t\tif (vp) {\r\n\t\t\t\t\tvar tests = getTests(ps).slice();\r\n\t\t\t\t\tif (tests[tests.length - 1].match.def === \"\") tests.pop();\r\n\t\t\t\t\tvar bestMatch = determineTestTemplate(ps, tests), np;\r\n\t\t\t\t\tif (bestMatch && (bestMatch.match.jit !== true || (bestMatch.match.newBlockMarker === \"master\" && (np = maskset.validPositions[ps + 1]) && np.match.optionalQuantifier === true))) {\r\n\t\t\t\t\t\tbestMatch = $.extend({}, bestMatch, {\r\n\t\t\t\t\t\t\t\"input\": getPlaceholder(ps, bestMatch.match, true) || bestMatch.match.def\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tbestMatch.generatedInput = true;\r\n\t\t\t\t\t\trevalidateMask(ps, bestMatch, true);\r\n\r\n\t\t\t\t\t\tif (fillOnly !== true) {\r\n\t\t\t\t\t\t\t//revalidate the new position to update the locator value\r\n\t\t\t\t\t\t\tvar cvpInput = maskset.validPositions[newPos].input;\r\n\t\t\t\t\t\t\tmaskset.validPositions[newPos] = undefined;\r\n\t\t\t\t\t\t\treturn isValid(newPos, cvpInput, true, true);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction revalidateMask(pos, validTest, fromIsValid, validatedPos) {\r\n\t\tfunction IsEnclosedStatic(pos, valids, selection) {\r\n\t\t\tvar posMatch = valids[pos];\r\n\t\t\tif (posMatch !== undefined && ((posMatch.match.static === true && posMatch.match.optionality !== true) || posMatch.input === opts.radixPoint)) {\r\n\t\t\t\tvar prevMatch = selection.begin <= pos - 1 ? valids[pos - 1] && valids[pos - 1].match.static === true && valids[pos - 1] : valids[pos - 1],\r\n\t\t\t\t\tnextMatch = selection.end > pos + 1 ? valids[pos + 1] && valids[pos + 1].match.static === true && valids[pos + 1] : valids[pos + 1];\r\n\t\t\t\treturn prevMatch && nextMatch;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tvar begin = pos.begin !== undefined ? pos.begin : pos, end = pos.end !== undefined ? pos.end : pos;\r\n\t\tif (pos.begin > pos.end) {\r\n\t\t\tbegin = pos.end;\r\n\t\t\tend = pos.begin;\r\n\t\t}\r\n\t\tvalidatedPos = validatedPos !== undefined ? validatedPos : begin;\r\n\t\tif (begin !== end || (opts.insertMode && maskset.validPositions[validatedPos] !== undefined && fromIsValid === undefined)) {\r\n\t\t\t//reposition & revalidate others\r\n\t\t\tvar positionsClone = $.extend(true, {}, maskset.validPositions),\r\n\t\t\t\tlvp = getLastValidPosition(undefined, true),\r\n\t\t\t\ti;\r\n\t\t\tmaskset.p = begin; //needed for alternated position after overtype selection\r\n\r\n\t\t\tfor (i = lvp; i >= begin; i--) {\r\n\t\t\t\tdelete maskset.validPositions[i];\r\n\t\t\t\tif (validTest === undefined) delete maskset.tests[i + 1];\r\n\t\t\t}\r\n\r\n\t\t\tvar valid = true, j = validatedPos,\r\n\t\t\t\tneedsValidation = false, posMatch = j;\r\n\t\t\ti = j;\r\n\r\n\t\t\tif (validTest) {\r\n\t\t\t\tmaskset.validPositions[validatedPos] = $.extend(true, {}, validTest);\r\n\t\t\t\tposMatch++;\r\n\t\t\t\tj++;\r\n\t\t\t\tif (begin < end) i++; //if selection and entry move start by one\r\n\t\t\t}\r\n\t\t\tfor (; i <= lvp; i++) {\r\n\t\t\t\tvar t = positionsClone[i];\r\n\t\t\t\tif (t !== undefined &&\r\n\t\t\t\t\t(i >= end || (i >= begin && t.generatedInput !== true && IsEnclosedStatic(i, positionsClone, {\r\n\t\t\t\t\t\tbegin: begin,\r\n\t\t\t\t\t\tend: end\r\n\t\t\t\t\t})))) {\r\n\t\t\t\t\twhile (getTest(posMatch).match.def !== \"\") { //loop needed to match further positions\r\n\t\t\t\t\t\tif (needsValidation === false && positionsClone[posMatch] && positionsClone[posMatch].match.nativeDef === t.match.nativeDef) { //obvious match\r\n\t\t\t\t\t\t\tmaskset.validPositions[posMatch] = $.extend(true, {}, positionsClone[posMatch]);\r\n\t\t\t\t\t\t\tmaskset.validPositions[posMatch].input = t.input;\r\n\t\t\t\t\t\t\ttrackbackPositions(undefined, posMatch, true);\r\n\t\t\t\t\t\t\tj = posMatch + 1;\r\n\t\t\t\t\t\t\tvalid = true;\r\n\t\t\t\t\t\t\t//we still need some hackery for the + validator (numeric alias)\r\n\t\t\t\t\t\t} else if (opts.shiftPositions && (positionCanMatchDefinition(posMatch, t.match.def) || t.match.def === \"+\")) { //validated match\r\n\t\t\t\t\t\t\tif (t.match.def === \"+\") getBuffer(true);\r\n\t\t\t\t\t\t\tvar result = isValid(posMatch, t.input, t.match.def !== \"+\", t.match.def !== \"+\");\r\n\t\t\t\t\t\t\tvalid = result !== false;\r\n\t\t\t\t\t\t\t// console.log(\"match \" + posMatch + \" \" + t.input + \" \" + JSON.stringify(result));\r\n\t\t\t\t\t\t\t// j = (result.caret || result.insert) ? getLastValidPosition() : (result.pos || posMatch) + 1;\r\n\t\t\t\t\t\t\tj = (result.pos || posMatch) + 1;\r\n\t\t\t\t\t\t\tneedsValidation = true;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tvalid = t.generatedInput === true /*|| (t.input === opts.radixPoint && opts.numericInput === true)*/;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (valid) break;\r\n\t\t\t\t\t\tif (!valid && posMatch > end && isMask(posMatch, true) && (t.match.static !== true || posMatch > maskset.maskLength)) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tposMatch++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (getTest(posMatch).match.def == \"\") {\r\n\t\t\t\t\t\tvalid = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//restore position\r\n\t\t\t\t\tposMatch = j;\r\n\t\t\t\t}\r\n\t\t\t\tif (!valid) break;\r\n\t\t\t}\r\n\r\n\t\t\tif (!valid) {\r\n\t\t\t\tmaskset.validPositions = $.extend(true, {}, positionsClone);\r\n\t\t\t\tresetMaskSet(true);\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t} else if (validTest) {\r\n\t\t\tmaskset.validPositions[validatedPos] = $.extend(true, {}, validTest);\r\n\t\t}\r\n\r\n\t\tresetMaskSet(true);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction isMask(pos, strict) {\r\n\t\tvar test = getTestTemplate(pos).match;\r\n\t\tif (test.def === \"\") test = getTest(pos).match;\r\n\r\n\t\tif (test.static != true) {\r\n\t\t\treturn test.fn;\r\n\t\t}\r\n\t\tif (strict !== true && pos > -1) {\r\n\t\t\tvar tests = getTests(pos);\r\n\t\t\treturn tests.length > 1 + (tests[tests.length - 1].match.def === \"\" ? 1 : 0);\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tfunction seekNext(pos, newBlock) {\r\n\t\tvar position = pos + 1;\r\n\t\twhile (getTest(position).match.def !== \"\" &&\r\n\t\t((newBlock === true && (getTest(position).match.newBlockMarker !== true || !isMask(position))) ||\r\n\t\t\t(newBlock !== true && !isMask(position)))) {\r\n\t\t\tposition++;\r\n\t\t}\r\n\t\treturn position;\r\n\t}\r\n\r\n\tfunction seekPrevious(pos, newBlock) {\r\n\t\tvar position = pos,\r\n\t\t\ttests;\r\n\t\tif (position <= 0) return 0;\r\n\r\n\t\twhile (--position > 0 &&\r\n\t\t((newBlock === true && getTest(position).match.newBlockMarker !== true) ||\r\n\t\t\t(newBlock !== true && !isMask(position) &&\r\n\t\t\t\t// eslint-disable-next-line no-empty\r\n\t\t\t\t(tests = getTests(position), tests.length < 2 || (tests.length === 2 && tests[1].match.def === \"\"))))) {\r\n\t\t}\r\n\t\treturn position;\r\n\t}\r\n\r\n\tfunction writeBuffer(input, buffer, caretPos, event, triggerEvents) {\r\n\t\tif (event && $.isFunction(opts.onBeforeWrite)) {\r\n\t\t\t//    buffer = buffer.slice(); //prevent uncontrolled manipulation of the internal buffer\r\n\t\t\tvar result = opts.onBeforeWrite.call(inputmask, event, buffer, caretPos, opts);\r\n\t\t\tif (result) {\r\n\t\t\t\tif (result.refreshFromBuffer) {\r\n\t\t\t\t\tvar refresh = result.refreshFromBuffer;\r\n\t\t\t\t\trefreshFromBuffer(refresh === true ? refresh : refresh.start, refresh.end, result.buffer || buffer);\r\n\t\t\t\t\tbuffer = getBuffer(true);\r\n\t\t\t\t}\r\n\t\t\t\tif (caretPos !== undefined) caretPos = result.caret !== undefined ? result.caret : caretPos;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (input !== undefined) {\r\n\t\t\tinput.inputmask._valueSet(buffer.join(\"\"));\r\n\t\t\tif (caretPos !== undefined && (event === undefined || event.type !== \"blur\")) {\r\n\t\t\t\tcaret(input, caretPos);\r\n\t\t\t} else {\r\n\t\t\t\trenderColorMask(input, caretPos, buffer.length === 0);\r\n\t\t\t}\r\n\t\t\tif (triggerEvents === true) {\r\n\t\t\t\tvar $input = $(input), nptVal = input.inputmask._valueGet();\r\n\t\t\t\tskipInputEvent = true;\r\n\t\t\t\t$input.trigger(\"input\");\r\n\t\t\t\tsetTimeout(function () { //timeout needed for IE\r\n\t\t\t\t\tif (nptVal === getBufferTemplate().join(\"\")) {\r\n\t\t\t\t\t\t$input.trigger(\"cleared\");\r\n\t\t\t\t\t} else if (isComplete(buffer) === true) {\r\n\t\t\t\t\t\t$input.trigger(\"complete\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}, 0);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getPlaceholder(pos, test, returnPL) {\r\n\t\ttest = test || getTest(pos).match;\r\n\t\tif (test.placeholder !== undefined || returnPL === true) {\r\n\t\t\treturn $.isFunction(test.placeholder) ? test.placeholder(opts) : test.placeholder;\r\n\t\t} else if (test.static === true) {\r\n\t\t\tif (pos > -1 && maskset.validPositions[pos] === undefined) {\r\n\t\t\t\tvar tests = getTests(pos),\r\n\t\t\t\t\tstaticAlternations = [],\r\n\t\t\t\t\tprevTest;\r\n\t\t\t\tif (tests.length > 1 + (tests[tests.length - 1].match.def === \"\" ? 1 : 0)) {\r\n\t\t\t\t\tfor (var i = 0; i < tests.length; i++) {\r\n\t\t\t\t\t\tif (tests[i].match.optionality !== true && tests[i].match.optionalQuantifier !== true &&\r\n\t\t\t\t\t\t\t(tests[i].match.static === true || (prevTest === undefined || tests[i].match.fn.test(prevTest.match.def, maskset, pos, true, opts) !== false))) {\r\n\t\t\t\t\t\t\tstaticAlternations.push(tests[i]);\r\n\t\t\t\t\t\t\tif (tests[i].match.static === true) prevTest = tests[i];\r\n\t\t\t\t\t\t\tif (staticAlternations.length > 1) {\r\n\t\t\t\t\t\t\t\tif (/[0-9a-bA-Z]/.test(staticAlternations[0].match.def)) {\r\n\t\t\t\t\t\t\t\t\treturn opts.placeholder.charAt(pos % opts.placeholder.length);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn test.def;\r\n\t\t}\r\n\r\n\t\treturn opts.placeholder.charAt(pos % opts.placeholder.length);\r\n\t}\r\n\r\n\tfunction HandleNativePlaceholder(npt, value) {\r\n\t\tif (ie) {\r\n\t\t\tif (npt.inputmask._valueGet() !== value && (npt.placeholder !== value || npt.placeholder === \"\")) {\r\n\t\t\t\tvar buffer = getBuffer().slice(),\r\n\t\t\t\t\tnptValue = npt.inputmask._valueGet();\r\n\t\t\t\tif (nptValue !== value) {\r\n\t\t\t\t\tvar lvp = getLastValidPosition();\r\n\t\t\t\t\tif (lvp === -1 && nptValue === getBufferTemplate().join(\"\")) {\r\n\t\t\t\t\t\tbuffer = [];\r\n\t\t\t\t\t} else if (lvp !== -1) { //clearout optional tail of the mask\r\n\t\t\t\t\t\tclearOptionalTail(buffer);\r\n\t\t\t\t\t}\r\n\t\t\t\t\twriteBuffer(npt, buffer);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (npt.placeholder !== value) {\r\n\t\t\tnpt.placeholder = value;\r\n\t\t\tif (npt.placeholder === \"\") npt.removeAttribute(\"placeholder\");\r\n\t\t}\r\n\t}\r\n\r\n\tfunction determineNewCaretPosition(selectedCaret, tabbed) {\r\n\t\tfunction doRadixFocus(clickPos) {\r\n\t\t\tif (opts.radixPoint !== \"\") {\r\n\t\t\t\tvar vps = maskset.validPositions;\r\n\t\t\t\tif (vps[clickPos] === undefined || (vps[clickPos].input === getPlaceholder(clickPos))) {\r\n\t\t\t\t\tif (clickPos < seekNext(-1)) return true;\r\n\t\t\t\t\tvar radixPos = $.inArray(opts.radixPoint, getBuffer());\r\n\t\t\t\t\tif (radixPos !== -1) {\r\n\t\t\t\t\t\tfor (var vp in vps) {\r\n\t\t\t\t\t\t\tif (vps[vp] && radixPos < vp && vps[vp].input !== getPlaceholder(vp)) {\r\n\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tif (tabbed) {\r\n\t\t\tif (isRTL) {\r\n\t\t\t\tselectedCaret.end = selectedCaret.begin;\r\n\t\t\t} else {\r\n\t\t\t\tselectedCaret.begin = selectedCaret.end;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (selectedCaret.begin === selectedCaret.end) {\r\n\t\t\tswitch (opts.positionCaretOnClick) {\r\n\t\t\t\tcase \"none\":\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"select\":\r\n\t\t\t\t\treturn {begin: 0, end: getBuffer().length};\r\n\t\t\t\tcase \"ignore\":\r\n\t\t\t\t\treturn seekNext(getLastValidPosition());\r\n\t\t\t\tcase \"radixFocus\":\r\n\t\t\t\t\tif (doRadixFocus(selectedCaret.begin)) {\r\n\t\t\t\t\t\tvar radixPos = getBuffer().join(\"\").indexOf(opts.radixPoint);\r\n\t\t\t\t\t\treturn opts.numericInput ? seekNext(radixPos) : radixPos;\r\n\t\t\t\t\t} //fallback to lvp\r\n\t\t\t\t// eslint-disable-next-line no-fallthrough\r\n\t\t\t\tdefault: //lvp:\r\n\t\t\t\t\tvar clickPosition = selectedCaret.begin,\r\n\t\t\t\t\t\tlvclickPosition = getLastValidPosition(clickPosition, true),\r\n\t\t\t\t\t\tlastPosition = seekNext((lvclickPosition === -1 && !isMask(0)) ? 0 : lvclickPosition);\r\n\t\t\t\t\tif (clickPosition < lastPosition) {\r\n\t\t\t\t\t\treturn !isMask(clickPosition, true) && !isMask(clickPosition - 1, true) ? seekNext(clickPosition) : clickPosition;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tvar lvp = maskset.validPositions[lvclickPosition],\r\n\t\t\t\t\t\t\ttt = getTestTemplate(lastPosition, lvp ? lvp.match.locator : undefined, lvp),\r\n\t\t\t\t\t\t\tplaceholder = getPlaceholder(lastPosition, tt.match);\r\n\t\t\t\t\t\tif ((placeholder !== \"\" && getBuffer()[lastPosition] !== placeholder && tt.match.optionalQuantifier !== true && tt.match.newBlockMarker !== true) || (!isMask(lastPosition, opts.keepStatic) && tt.match.def === placeholder)) {\r\n\t\t\t\t\t\t\tvar newPos = seekNext(lastPosition);\r\n\t\t\t\t\t\t\tif (clickPosition >= newPos || clickPosition === lastPosition) {\r\n\t\t\t\t\t\t\t\tlastPosition = newPos;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn lastPosition;\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tvar EventRuler = {\r\n\t\ton: function (input, eventName, eventHandler) {\r\n\t\t\tvar ev = function (e) {\r\n\t\t\t\tvar that = this, args;\r\n\t\t\t\t// console.log(e.type);\r\n\t\t\t\tif (that.inputmask === undefined && this.nodeName !== \"FORM\") { //happens when cloning an object with jquery.clone\r\n\t\t\t\t\tvar imOpts = $.data(that, \"_inputmask_opts\");\r\n\t\t\t\t\tif (imOpts) {\r\n\t\t\t\t\t\t(new Inputmask(imOpts)).mask(that);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tEventRuler.off(that);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (e.type !== \"setvalue\" && this.nodeName !== \"FORM\" && (that.disabled || (that.readOnly && !(e.type === \"keydown\" && (e.ctrlKey && e.keyCode === 67) || (opts.tabThrough === false && e.keyCode === Inputmask.keyCode.TAB))))) {\r\n\t\t\t\t\te.preventDefault();\r\n\t\t\t\t} else {\r\n\t\t\t\t\tswitch (e.type) {\r\n\t\t\t\t\t\tcase \"input\":\r\n\t\t\t\t\t\t\tif (skipInputEvent === true) {\r\n\t\t\t\t\t\t\t\tskipInputEvent = false;\r\n\t\t\t\t\t\t\t\treturn e.preventDefault();\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (mobile) {\r\n\t\t\t\t\t\t\t\targs = arguments;\r\n\t\t\t\t\t\t\t\tsetTimeout(function () { //needed for caret selection when entering a char on Android 8 - #1818\r\n\t\t\t\t\t\t\t\t\teventHandler.apply(that, args);\r\n\t\t\t\t\t\t\t\t\tcaret(that, that.inputmask.caretPos, undefined, true);\r\n\t\t\t\t\t\t\t\t}, 0);\r\n\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase \"keydown\":\r\n\t\t\t\t\t\t\t//Safari 5.1.x - modal dialog fires keypress twice workaround\r\n\t\t\t\t\t\t\tskipKeyPressEvent = false;\r\n\t\t\t\t\t\t\tskipInputEvent = false;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase \"keypress\":\r\n\t\t\t\t\t\t\tif (skipKeyPressEvent === true) {\r\n\t\t\t\t\t\t\t\treturn e.preventDefault();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tskipKeyPressEvent = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase \"click\":\r\n\t\t\t\t\t\tcase \"focus\":\r\n\t\t\t\t\t\t\targs = arguments;\r\n\t\t\t\t\t\t\tsetTimeout(function () { //needed for Chrome ~ initial selection clears after the clickevent\r\n\t\t\t\t\t\t\t\teventHandler.apply(that, args);\r\n\t\t\t\t\t\t\t}, focusDelay);\r\n\t\t\t\t\t\t\tfocusDelay = 0;\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\tcase \"invalid\":\r\n\t\t\t\t\t\t\tfocusDelay = 1000;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar returnVal = eventHandler.apply(that, arguments);\r\n\t\t\t\t\tif (returnVal === false) {\r\n\t\t\t\t\t\te.preventDefault();\r\n\t\t\t\t\t\te.stopPropagation();\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn returnVal;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\t//keep instance of the event\r\n\t\t\tinput.inputmask.events[eventName] = input.inputmask.events[eventName] || [];\r\n\t\t\tinput.inputmask.events[eventName].push(ev);\r\n\r\n\t\t\tif ($.inArray(eventName, [\"submit\", \"reset\"]) !== -1) {\r\n\t\t\t\tif (input.form !== null) $(input.form).on(eventName, ev);\r\n\t\t\t} else {\r\n\t\t\t\t$(input).on(eventName, ev);\r\n\t\t\t}\r\n\t\t},\r\n\t\toff: function (input, event) {\r\n\t\t\tif (input.inputmask && input.inputmask.events) {\r\n\t\t\t\tvar events;\r\n\t\t\t\tif (event) {\r\n\t\t\t\t\tevents = [];\r\n\t\t\t\t\tevents[event] = input.inputmask.events[event];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tevents = input.inputmask.events;\r\n\t\t\t\t}\r\n\t\t\t\t$.each(events, function (eventName, evArr) {\r\n\t\t\t\t\twhile (evArr.length > 0) {\r\n\t\t\t\t\t\tvar ev = evArr.pop();\r\n\t\t\t\t\t\tif ($.inArray(eventName, [\"submit\", \"reset\", \"invalid\"]) !== -1) {\r\n\t\t\t\t\t\t\tif (input.form !== null) $(input.form).off(eventName, ev);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t$(input).off(eventName, ev);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdelete input.inputmask.events[eventName];\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\tvar EventHandlers = {\r\n\t\tkeydownEvent: function (e) {\r\n\t\t\tvar input = this,\r\n\t\t\t\t$input = $(input),\r\n\t\t\t\tk = e.keyCode,\r\n\t\t\t\tpos = caret(input);\r\n\r\n\t\t\tvar kdResult = opts.onKeyDown.call(this, e, getBuffer(), pos.begin, opts);\r\n\t\t\tif (kdResult !== undefined) return kdResult;\r\n\r\n\t\t\t//backspace, delete, and escape get special treatment\r\n\t\t\tif (k === Inputmask.keyCode.BACKSPACE || k === Inputmask.keyCode.DELETE || (iphone && k === Inputmask.keyCode.BACKSPACE_SAFARI) || (e.ctrlKey && k === Inputmask.keyCode.X && !isInputEventSupported(\"cut\"))) { //backspace/delete\r\n\t\t\t\te.preventDefault(); //stop default action but allow propagation\r\n\t\t\t\thandleRemove(input, k, pos);\r\n\t\t\t\twriteBuffer(input, getBuffer(true), maskset.p, e, input.inputmask._valueGet() !== getBuffer().join(\"\"));\r\n\t\t\t} else if (k === Inputmask.keyCode.END || k === Inputmask.keyCode.PAGE_DOWN) { //when END or PAGE_DOWN pressed set position at lastmatch\r\n\t\t\t\te.preventDefault();\r\n\t\t\t\tvar caretPos = seekNext(getLastValidPosition());\r\n\t\t\t\tcaret(input, e.shiftKey ? pos.begin : caretPos, caretPos, true);\r\n\t\t\t} else if ((k === Inputmask.keyCode.HOME && !e.shiftKey) || k === Inputmask.keyCode.PAGE_UP) { //Home or page_up\r\n\t\t\t\te.preventDefault();\r\n\t\t\t\tcaret(input, 0, e.shiftKey ? pos.begin : 0, true);\r\n\t\t\t} else if (((opts.undoOnEscape && k === Inputmask.keyCode.ESCAPE) || (k === 90 && e.ctrlKey)) && e.altKey !== true) { //escape && undo && #762\r\n\t\t\t\tcheckVal(input, true, false, undoValue.split(\"\"));\r\n\t\t\t\t$input.trigger(\"click\");\r\n\t\t\t} else if (k === Inputmask.keyCode.INSERT && !(e.shiftKey || e.ctrlKey)) { //insert\r\n\t\t\t\topts.insertMode = !opts.insertMode;\r\n\t\t\t\tinput.setAttribute(\"data-im-insert\", opts.insertMode);\r\n\t\t\t} else if (opts.tabThrough === true && k === Inputmask.keyCode.TAB) {\r\n\t\t\t\tif (e.shiftKey === true) {\r\n\t\t\t\t\tif (getTest(pos.begin).match.static === true) {\r\n\t\t\t\t\t\tpos.begin = seekNext(pos.begin);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpos.end = seekPrevious(pos.begin, true);\r\n\t\t\t\t\tpos.begin = seekPrevious(pos.end, true);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tpos.begin = seekNext(pos.begin, true);\r\n\t\t\t\t\tpos.end = seekNext(pos.begin, true);\r\n\t\t\t\t\tif (pos.end < maskset.maskLength) pos.end--;\r\n\t\t\t\t}\r\n\t\t\t\tif (pos.begin < maskset.maskLength) {\r\n\t\t\t\t\te.preventDefault();\r\n\t\t\t\t\tcaret(input, pos.begin, pos.end);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tignorable = $.inArray(k, opts.ignorables) !== -1;\r\n\t\t},\r\n\t\tkeypressEvent: function (e, checkval, writeOut, strict, ndx) {\r\n\t\t\tvar input = this,\r\n\t\t\t\t$input = $(input),\r\n\t\t\t\tk = e.which || e.charCode || e.keyCode;\r\n\r\n\t\t\tif (checkval !== true && (!(e.ctrlKey && e.altKey) && (e.ctrlKey || e.metaKey || ignorable))) {\r\n\t\t\t\tif (k === Inputmask.keyCode.ENTER && undoValue !== getBuffer().join(\"\")) {\r\n\t\t\t\t\tundoValue = getBuffer().join(\"\");\r\n\t\t\t\t\t// e.preventDefault();\r\n\t\t\t\t\tsetTimeout(function () {\r\n\t\t\t\t\t\t$input.trigger(\"change\");\r\n\t\t\t\t\t}, 0);\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t} else if (k) {\r\n\t\t\t\t//special treat the decimal separator\r\n\t\t\t\tif (k === 46 && e.shiftKey === false && opts.radixPoint !== \"\") k = opts.radixPoint.charCodeAt(0);\r\n\t\t\t\tvar pos = checkval ? {\r\n\t\t\t\t\t\tbegin: ndx,\r\n\t\t\t\t\t\tend: ndx\r\n\t\t\t\t\t} : caret(input),\r\n\t\t\t\t\tforwardPosition, c = String.fromCharCode(k);\r\n\r\n\t\t\t\tmaskset.writeOutBuffer = true;\r\n\t\t\t\tvar valResult = isValid(pos, c, strict);\r\n\t\t\t\tif (valResult !== false) {\r\n\t\t\t\t\tresetMaskSet(true);\r\n\t\t\t\t\tforwardPosition = valResult.caret !== undefined ? valResult.caret : seekNext(valResult.pos.begin ? valResult.pos.begin : valResult.pos);\r\n\t\t\t\t\tmaskset.p = forwardPosition; //needed for checkval\r\n\t\t\t\t}\r\n\r\n\t\t\t\tforwardPosition = ((opts.numericInput && valResult.caret === undefined) ? seekPrevious(forwardPosition) : forwardPosition);\r\n\t\t\t\tif (writeOut !== false) {\r\n\t\t\t\t\tsetTimeout(function () {\r\n\t\t\t\t\t\topts.onKeyValidation.call(input, k, valResult, opts);\r\n\t\t\t\t\t}, 0);\r\n\t\t\t\t\tif (maskset.writeOutBuffer && valResult !== false) {\r\n\t\t\t\t\t\tvar buffer = getBuffer();\r\n\t\t\t\t\t\twriteBuffer(input, buffer, forwardPosition, e, checkval !== true);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\te.preventDefault();\r\n\r\n\t\t\t\tif (checkval) {\r\n\t\t\t\t\tif (valResult !== false) valResult.forwardPosition = forwardPosition;\r\n\t\t\t\t\treturn valResult;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tpasteEvent: function (e) {\r\n\t\t\tvar input = this,\r\n\t\t\t\tev = e.originalEvent || e,\r\n\t\t\t\tinputValue = input.inputmask._valueGet(true),\r\n\t\t\t\tcaretPos = caret(input),\r\n\t\t\t\ttempValue;\r\n\r\n\t\t\tif (isRTL) {\r\n\t\t\t\ttempValue = caretPos.end;\r\n\t\t\t\tcaretPos.end = caretPos.begin;\r\n\t\t\t\tcaretPos.begin = tempValue;\r\n\t\t\t}\r\n\r\n\t\t\tvar valueBeforeCaret = inputValue.substr(0, caretPos.begin),\r\n\t\t\t\tvalueAfterCaret = inputValue.substr(caretPos.end, inputValue.length);\r\n\r\n\t\t\tif (valueBeforeCaret === (isRTL ? getBufferTemplate().reverse() : getBufferTemplate()).slice(0, caretPos.begin).join(\"\")) valueBeforeCaret = \"\";\r\n\t\t\tif (valueAfterCaret === (isRTL ? getBufferTemplate().reverse() : getBufferTemplate()).slice(caretPos.end).join(\"\")) valueAfterCaret = \"\";\r\n\r\n\t\t\tif (window.clipboardData && window.clipboardData.getData) { // IE\r\n\t\t\t\tinputValue = valueBeforeCaret + window.clipboardData.getData(\"Text\") + valueAfterCaret;\r\n\t\t\t} else if (ev.clipboardData && ev.clipboardData.getData) {\r\n\t\t\t\tinputValue = valueBeforeCaret + ev.clipboardData.getData(\"text/plain\") + valueAfterCaret;\r\n\t\t\t} else {\r\n\t\t\t\treturn true;\r\n\t\t\t} //allow native paste event as fallback ~ masking will continue by inputfallback\r\n\r\n\t\t\tvar pasteValue = inputValue;\r\n\t\t\tif ($.isFunction(opts.onBeforePaste)) {\r\n\t\t\t\tpasteValue = opts.onBeforePaste.call(inputmask, inputValue, opts);\r\n\t\t\t\tif (pasteValue === false) {\r\n\t\t\t\t\treturn e.preventDefault();\r\n\t\t\t\t}\r\n\t\t\t\tif (!pasteValue) {\r\n\t\t\t\t\tpasteValue = inputValue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcheckVal(input, false, false, pasteValue.toString().split(\"\"));\r\n\t\t\twriteBuffer(input, getBuffer(), seekNext(getLastValidPosition()), e, undoValue !== getBuffer().join(\"\"));\r\n\t\t\treturn e.preventDefault();\r\n\t\t},\r\n\t\tinputFallBackEvent: function (e) { //fallback when keypress is not triggered\r\n\t\t\tfunction radixPointHandler(input, inputValue, caretPos) {\r\n\t\t\t\t//radixpoint tweak\r\n\t\t\t\tif (inputValue.charAt(caretPos.begin - 1) === \".\" && opts.radixPoint !== \"\") {\r\n\t\t\t\t\tinputValue = inputValue.split(\"\");\r\n\t\t\t\t\tinputValue[caretPos.begin - 1] = opts.radixPoint.charAt(0);\r\n\t\t\t\t\tinputValue = inputValue.join(\"\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn inputValue;\r\n\t\t\t}\r\n\r\n\t\t\tfunction ieMobileHandler(input, inputValue, caretPos) {\r\n\t\t\t\tif (iemobile) { //iemobile just sets the character at the end althought the caret position is correctly set\r\n\t\t\t\t\tvar inputChar = inputValue.replace(getBuffer().join(\"\"), \"\");\r\n\t\t\t\t\tif (inputChar.length === 1) {\r\n\t\t\t\t\t\tvar iv = inputValue.split(\"\");\r\n\t\t\t\t\t\tiv.splice(caretPos.begin, 0, inputChar);\r\n\t\t\t\t\t\tinputValue = iv.join(\"\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn inputValue;\r\n\t\t\t}\r\n\r\n\t\t\tvar input = this,\r\n\t\t\t\tinputValue = input.inputmask._valueGet();\r\n\r\n\t\t\tif (getBuffer().join(\"\") !== inputValue) {\r\n\r\n\t\t\t\tvar caretPos = caret(input);\r\n\t\t\t\tinputValue = radixPointHandler(input, inputValue, caretPos);\r\n\t\t\t\tinputValue = ieMobileHandler(input, inputValue, caretPos);\r\n\r\n\t\t\t\tif (getBuffer().join(\"\") !== inputValue) {\r\n\t\t\t\t\tvar buffer = getBuffer().join(\"\"),\r\n\t\t\t\t\t\toffset = (!opts.numericInput && inputValue.length > buffer.length) ? -1 : 0,\r\n\t\t\t\t\t\tfrontPart = inputValue.substr(0, caretPos.begin),\r\n\t\t\t\t\t\tbackPart = inputValue.substr(caretPos.begin),\r\n\t\t\t\t\t\tfrontBufferPart = buffer.substr(0, caretPos.begin + offset),\r\n\t\t\t\t\t\tbackBufferPart = buffer.substr(caretPos.begin + offset);\r\n\r\n\t\t\t\t\t//check if thare was a selection\r\n\t\t\t\t\tvar selection = caretPos,\r\n\t\t\t\t\t\tentries = \"\",\r\n\t\t\t\t\t\tisEntry = false;\r\n\t\t\t\t\tif (frontPart !== frontBufferPart) {\r\n\t\t\t\t\t\tvar fpl = ((isEntry = frontPart.length >= frontBufferPart.length)) ? frontPart.length : frontBufferPart.length,\r\n\t\t\t\t\t\t\ti;\r\n\t\t\t\t\t\tfor (i = 0; frontPart.charAt(i) === frontBufferPart.charAt(i) && i < fpl; i++) ;\r\n\t\t\t\t\t\tif (isEntry) {\r\n\t\t\t\t\t\t\tselection.begin = i - offset;\r\n\t\t\t\t\t\t\tentries += frontPart.slice(i, selection.end);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (backPart !== backBufferPart) {\r\n\t\t\t\t\t\tif (backPart.length > backBufferPart.length) {\r\n\t\t\t\t\t\t\tentries += backPart.slice(0, 1);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tif (backPart.length < backBufferPart.length) {\r\n\t\t\t\t\t\t\t\tselection.end += backBufferPart.length - backPart.length;\r\n\t\t\t\t\t\t\t\t//hack around numeric alias & radixpoint\r\n\t\t\t\t\t\t\t\tif (!isEntry && opts.radixPoint !== \"\" && backPart === \"\" && frontPart.charAt(selection.begin + offset - 1) === opts.radixPoint) {\r\n\t\t\t\t\t\t\t\t\tselection.begin--;\r\n\t\t\t\t\t\t\t\t\tentries = opts.radixPoint;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\twriteBuffer(input, getBuffer(), {\r\n\t\t\t\t\t\t\"begin\": selection.begin + offset,\r\n\t\t\t\t\t\t\"end\": selection.end + offset\r\n\t\t\t\t\t});\r\n\t\t\t\t\tif (entries.length > 0) {\r\n\t\t\t\t\t\t$.each(entries.split(\"\"), function (ndx, entry) {\r\n\t\t\t\t\t\t\tvar keypress = new $.Event(\"keypress\");\r\n\t\t\t\t\t\t\tkeypress.which = entry.charCodeAt(0);\r\n\t\t\t\t\t\t\tignorable = false; //make sure ignorable is ignored ;-)\r\n\t\t\t\t\t\t\tEventHandlers.keypressEvent.call(input, keypress);\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (selection.begin === selection.end - 1) {\r\n\t\t\t\t\t\t\tselection.begin = seekPrevious(selection.begin + 1);\r\n\t\t\t\t\t\t\tif (selection.begin === selection.end - 1) {\r\n\t\t\t\t\t\t\t\tcaret(input, selection.begin);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tcaret(input, selection.begin, selection.end);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar keydown = new $.Event(\"keydown\");\r\n\t\t\t\t\t\tkeydown.keyCode = opts.numericInput ? Inputmask.keyCode.BACKSPACE : Inputmask.keyCode.DELETE;\r\n\t\t\t\t\t\tEventHandlers.keydownEvent.call(input, keydown);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\te.preventDefault();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tbeforeInputEvent: function (e) {\r\n\t\t\tif (e.cancelable) {\r\n\t\t\t\tvar input = this, keydown, keypress;\r\n\t\t\t\tswitch (e.inputType) {\r\n\t\t\t\t\tcase \"insertText\":\r\n\t\t\t\t\t\t$.each(e.data.split(\"\"), function (ndx, entry) {\r\n\t\t\t\t\t\t\tkeypress = new $.Event(\"keypress\");\r\n\t\t\t\t\t\t\tkeypress.which = entry.charCodeAt(0);\r\n\t\t\t\t\t\t\tignorable = false; //make sure ignorable is ignored ;-)\r\n\t\t\t\t\t\t\tEventHandlers.keypressEvent.call(input, keypress);\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\treturn e.preventDefault();\r\n\t\t\t\t\tcase \"deleteContentBackward\":\r\n\t\t\t\t\t\tkeydown = new $.Event(\"keydown\");\r\n\t\t\t\t\t\tkeydown.keyCode = Inputmask.keyCode.BACKSPACE;\r\n\t\t\t\t\t\tEventHandlers.keydownEvent.call(input, keydown);\r\n\t\t\t\t\t\treturn e.preventDefault();\r\n\t\t\t\t\tcase \"deleteContentForward\":\r\n\t\t\t\t\t\tkeydown = new $.Event(\"keydown\");\r\n\t\t\t\t\t\tkeydown.keyCode = Inputmask.keyCode.DELETE;\r\n\t\t\t\t\t\tEventHandlers.keydownEvent.call(input, keydown);\r\n\t\t\t\t\t\treturn e.preventDefault();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tsetValueEvent: function (e) {\r\n\t\t\tvar input = this,\r\n\t\t\t\tvalue = (e && e.detail) ? e.detail[0] : arguments[1];\r\n\t\t\tvalue = value || input.inputmask._valueGet(true);\r\n\r\n\t\t\tapplyInputValue(input, value);\r\n\r\n\t\t\tif ((e.detail && e.detail[1] !== undefined) || arguments[2] !== undefined) {\r\n\t\t\t\tcaret(input, e.detail ? e.detail[1] : arguments[2]);\r\n\t\t\t}\r\n\t\t},\r\n\t\tfocusEvent: function (e) {\r\n\t\t\tvar input = this,\r\n\t\t\t\tnptValue = input.inputmask._valueGet();\r\n\t\t\tif (opts.showMaskOnFocus) {\r\n\t\t\t\tif (nptValue !== getBuffer().join(\"\")) {\r\n\t\t\t\t\twriteBuffer(input, getBuffer(), seekNext(getLastValidPosition()));\r\n\t\t\t\t} else if (mouseEnter === false) { //only executed on focus without mouseenter\r\n\t\t\t\t\tcaret(input, seekNext(getLastValidPosition()));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (opts.positionCaretOnTab === true && mouseEnter === false) {\r\n\t\t\t\tEventHandlers.clickEvent.apply(input, [e, true]);\r\n\t\t\t}\r\n\t\t\tundoValue = getBuffer().join(\"\");\r\n\t\t},\r\n\t\tmouseleaveEvent: function () {\r\n\t\t\tvar input = this;\r\n\t\t\tmouseEnter = false;\r\n\t\t\tif (opts.clearMaskOnLostFocus && document.activeElement !== input) {\r\n\t\t\t\tHandleNativePlaceholder(input, originalPlaceholder);\r\n\t\t\t}\r\n\t\t},\r\n\t\tclickEvent: function (e, tabbed) {\r\n\t\t\tvar input = this;\r\n\t\t\tif (document.activeElement === input) {\r\n\t\t\t\tvar newCaretPosition = determineNewCaretPosition(caret(input), tabbed);\r\n\t\t\t\tif (newCaretPosition !== undefined) {\r\n\t\t\t\t\tcaret(input, newCaretPosition);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tcutEvent: function (e) {\r\n\t\t\tvar input = this,\r\n\t\t\t\tpos = caret(input),\r\n\t\t\t\tev = e.originalEvent || e;\r\n\r\n\t\t\t//correct clipboardData\r\n\t\t\tvar clipboardData = window.clipboardData || ev.clipboardData,\r\n\t\t\t\tclipData = isRTL ? getBuffer().slice(pos.end, pos.begin) : getBuffer().slice(pos.begin, pos.end);\r\n\t\t\tclipboardData.setData(\"text\", isRTL ? clipData.reverse().join(\"\") : clipData.join(\"\"));\r\n\t\t\tif (document.execCommand) document.execCommand(\"copy\"); // copy selected content to system clipbaord\r\n\r\n\t\t\thandleRemove(input, Inputmask.keyCode.DELETE, pos);\r\n\t\t\twriteBuffer(input, getBuffer(), maskset.p, e, undoValue !== getBuffer().join(\"\"));\r\n\t\t},\r\n\t\tblurEvent: function (e) {\r\n\t\t\tvar $input = $(this),\r\n\t\t\t\tinput = this;\r\n\t\t\tif (input.inputmask) {\r\n\t\t\t\tHandleNativePlaceholder(input, originalPlaceholder);\r\n\t\t\t\tvar nptValue = input.inputmask._valueGet(),\r\n\t\t\t\t\tbuffer = getBuffer().slice();\r\n\r\n\t\t\t\tif (nptValue !== \"\" || colorMask !== undefined) {\r\n\t\t\t\t\tif (opts.clearMaskOnLostFocus) {\r\n\t\t\t\t\t\tif (getLastValidPosition() === -1 && nptValue === getBufferTemplate().join(\"\")) {\r\n\t\t\t\t\t\t\tbuffer = [];\r\n\t\t\t\t\t\t} else { //clearout optional tail of the mask\r\n\t\t\t\t\t\t\tclearOptionalTail(buffer);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (isComplete(buffer) === false) {\r\n\t\t\t\t\t\tsetTimeout(function () {\r\n\t\t\t\t\t\t\t$input.trigger(\"incomplete\");\r\n\t\t\t\t\t\t}, 0);\r\n\t\t\t\t\t\tif (opts.clearIncomplete) {\r\n\t\t\t\t\t\t\tresetMaskSet();\r\n\t\t\t\t\t\t\tif (opts.clearMaskOnLostFocus) {\r\n\t\t\t\t\t\t\t\tbuffer = [];\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tbuffer = getBufferTemplate().slice();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\twriteBuffer(input, buffer, undefined, e);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (undoValue !== getBuffer().join(\"\")) {\r\n\t\t\t\t\tundoValue = getBuffer().join(\"\");\r\n\t\t\t\t\t$input.trigger(\"change\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tmouseenterEvent: function () {\r\n\t\t\tvar input = this;\r\n\t\t\tmouseEnter = true;\r\n\t\t\tif (document.activeElement !== input) {\r\n\t\t\t\tif (input.placeholder !== originalPlaceholder) {\r\n\t\t\t\t\toriginalPlaceholder = input.placeholder;\r\n\t\t\t\t}\r\n\t\t\t\tif (opts.showMaskOnHover) {\r\n\t\t\t\t\tHandleNativePlaceholder(input, (isRTL ? getBuffer().slice().reverse() : getBuffer()).join(\"\"));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tsubmitEvent: function () { //trigger change on submit if any\r\n\t\t\tif (undoValue !== getBuffer().join(\"\")) {\r\n\t\t\t\t$el.trigger(\"change\");\r\n\t\t\t}\r\n\t\t\tif (opts.clearMaskOnLostFocus && getLastValidPosition() === -1 && el.inputmask._valueGet && el.inputmask._valueGet() === getBufferTemplate().join(\"\")) {\r\n\t\t\t\tel.inputmask._valueSet(\"\"); //clear masktemplete on submit and still has focus\r\n\t\t\t}\r\n\t\t\tif (opts.clearIncomplete && isComplete(getBuffer()) === false) {\r\n\t\t\t\tel.inputmask._valueSet(\"\");\r\n\t\t\t}\r\n\t\t\tif (opts.removeMaskOnSubmit) {\r\n\t\t\t\tel.inputmask._valueSet(el.inputmask.unmaskedvalue(), true);\r\n\t\t\t\tsetTimeout(function () {\r\n\t\t\t\t\twriteBuffer(el, getBuffer());\r\n\t\t\t\t}, 0);\r\n\t\t\t}\r\n\t\t},\r\n\t\tresetEvent: function () {\r\n\t\t\tel.inputmask.refreshValue = true; //indicate a forced refresh when there is a call to the value before leaving the triggering event fn\r\n\t\t\tsetTimeout(function () {\r\n\t\t\t\tapplyInputValue(el, el.inputmask._valueGet(true));\r\n\t\t\t}, 0);\r\n\t\t},\r\n\t\tinvalidEvent: function (e) {\r\n\r\n\t\t},\r\n\t};\r\n\r\n\tfunction checkVal(input, writeOut, strict, nptvl, initiatingEvent) {\r\n\t\tvar inputmask = this || input.inputmask,\r\n\t\t\tinputValue = nptvl.slice(),\r\n\t\t\tcharCodes = \"\",\r\n\t\t\tinitialNdx = -1,\r\n\t\t\tresult = undefined;\r\n\r\n\t\t// console.log(nptvl);\r\n\r\n\t\tfunction isTemplateMatch(ndx, charCodes) {\r\n\t\t\tif (opts.regex) return false;\r\n\t\t\tvar targetTemplate = getMaskTemplate(true, 0, false).slice(ndx, seekNext(ndx)).join(\"\").replace(/'/g, \"\"),\r\n\t\t\t\tcharCodeNdx = targetTemplate.indexOf(charCodes);\r\n\t\t\t//strip spaces from targetTemplate\r\n\t\t\twhile (charCodeNdx > 0 && targetTemplate[charCodeNdx - 1] === \" \") charCodeNdx--;\r\n\r\n\t\t\tvar match = charCodeNdx === 0 && !isMask(ndx)\r\n\t\t\t\t&& (getTest(ndx).match.nativeDef === charCodes.charAt(0)\r\n\t\t\t\t\t|| (getTest(ndx).match.static === true && getTest(ndx).match.nativeDef === (\"'\" + charCodes.charAt(0)))\r\n\t\t\t\t\t|| (getTest(ndx).match.nativeDef === \" \" && (getTest(ndx + 1).match.nativeDef === charCodes.charAt(0)\r\n\t\t\t\t\t\t|| (getTest(ndx + 1).match.static === true && getTest(ndx + 1).match.nativeDef === (\"'\" + charCodes.charAt(0))))));\r\n\r\n\t\t\tif (!match && charCodeNdx > 0) inputmask.caretPos = {begin: seekNext(charCodeNdx)};\r\n\t\t\treturn match;\r\n\t\t}\r\n\r\n\t\tresetMaskSet();\r\n\t\tinitialNdx = opts.radixPoint ? determineNewCaretPosition(0) : 0;\r\n\t\tmaskset.p = initialNdx;\r\n\t\tinputmask.caretPos = {begin: initialNdx};\r\n\r\n\t\tvar staticMatches = [], prevCaretPos = inputmask.caretPos;\r\n\t\t$.each(inputValue, function (ndx, charCode) {\r\n\t\t\tif (charCode !== undefined) { //inputfallback strips some elements out of the inputarray.  $.each logically presents them as undefined\r\n\t\t\t\tif (maskset.validPositions[ndx] === undefined && inputValue[ndx] === getPlaceholder(ndx) && isMask(ndx, true) &&\r\n\t\t\t\t\tisValid(ndx, inputValue[ndx], true, undefined, undefined, true) === false) {\r\n\t\t\t\t\tmaskset.p++;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar keypress = new $.Event(\"_checkval\");\r\n\t\t\t\t\tkeypress.which = charCode.charCodeAt(0);\r\n\t\t\t\t\tcharCodes += charCode;\r\n\t\t\t\t\tvar lvp = getLastValidPosition(undefined, true);\r\n\t\t\t\t\tif (!isTemplateMatch(initialNdx, charCodes)) {\r\n\t\t\t\t\t\tresult = EventHandlers.keypressEvent.call(input, keypress, true, false, strict, inputmask.caretPos.begin);\r\n\r\n\t\t\t\t\t\tif (result) {\r\n\t\t\t\t\t\t\tinitialNdx = inputmask.caretPos.begin + 1;\r\n\t\t\t\t\t\t\tcharCodes = \"\";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tresult = EventHandlers.keypressEvent.call(input, keypress, true, false, strict, lvp + 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (result) {\r\n\t\t\t\t\t\tif (result.pos && maskset.validPositions[result.pos] && maskset.validPositions[result.pos].match.static === true) {\r\n\t\t\t\t\t\t\tstaticMatches.push(result.pos);\r\n\t\t\t\t\t\t\tresult.forwardPosition = result.pos + 1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\twriteBuffer(undefined, getBuffer(), result.forwardPosition, keypress, false);\r\n\t\t\t\t\t\tinputmask.caretPos = {begin: result.forwardPosition, end: result.forwardPosition};\r\n\t\t\t\t\t\tprevCaretPos = inputmask.caretPos;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tinputmask.caretPos = prevCaretPos;\r\n\t\t\t\t\t}  //restore the caret position from before the failed validation\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t\tif (staticMatches.length > 0) {\r\n\t\t\tvar sndx, validPos, nextValid;\r\n\t\t\tif (!isComplete(getBuffer())) {  //FIXME ENHANCE ME\r\n\t\t\t\twhile ((sndx = staticMatches.pop())) {\r\n\t\t\t\t\tvar keypress = new $.Event(\"_checkval\"),\r\n\t\t\t\t\t\tnextSndx = sndx + 1;\r\n\r\n\t\t\t\t\tvalidPos = maskset.validPositions[sndx];\r\n\t\t\t\t\tvalidPos.generatedInput = true;\r\n\t\t\t\t\tkeypress.which = validPos.input.charCodeAt(0);\r\n\t\t\t\t\twhile ((nextValid = maskset.validPositions[nextSndx]) && nextValid.input === validPos.input) {\r\n\t\t\t\t\t\tnextSndx++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tEventHandlers.keypressEvent.call(input, keypress, true, false, strict, nextSndx);\r\n\t\t\t\t\tif (isComplete(getBuffer())) break;\r\n\t\t\t\t}\r\n\t\t\t} else { //mark al statics as generated\r\n\t\t\t\twhile ((sndx = staticMatches.pop())) {\r\n\t\t\t\t\tvalidPos = maskset.validPositions[sndx];\r\n\t\t\t\t\tif (validPos) {\r\n\t\t\t\t\t\tvalidPos.generatedInput = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (writeOut) {\r\n\t\t\twriteBuffer(input, getBuffer(), result ? result.forwardPosition : undefined, initiatingEvent || new $.Event(\"checkval\"), initiatingEvent && initiatingEvent.type === \"input\");\r\n\t\t}\r\n\t}\r\n\r\n\tfunction unmaskedvalue(input) {\r\n\t\tif (input) {\r\n\t\t\tif (input.inputmask === undefined) {\r\n\t\t\t\treturn input.value;\r\n\t\t\t}\r\n\t\t\tif (input.inputmask && input.inputmask.refreshValue) { //forced refresh from the value form.reset\r\n\t\t\t\tapplyInputValue(input, input.inputmask._valueGet(true));\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar umValue = [],\r\n\t\t\tvps = maskset.validPositions;\r\n\t\tfor (var pndx in vps) {\r\n\t\t\tif (vps[pndx] && vps[pndx].match && vps[pndx].match.static != true) {\r\n\t\t\t\tumValue.push(vps[pndx].input);\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar unmaskedValue = umValue.length === 0 ? \"\" : (isRTL ? umValue.reverse() : umValue).join(\"\");\r\n\t\tif ($.isFunction(opts.onUnMask)) {\r\n\t\t\tvar bufferValue = (isRTL ? getBuffer().slice().reverse() : getBuffer()).join(\"\");\r\n\t\t\tunmaskedValue = opts.onUnMask.call(inputmask, bufferValue, unmaskedValue, opts);\r\n\t\t}\r\n\t\treturn unmaskedValue;\r\n\t}\r\n\r\n\tfunction caret(input, begin, end, notranslate) {\r\n\t\tfunction translatePosition(pos) {\r\n\t\t\tif (isRTL && typeof pos === \"number\" && (!opts.greedy || opts.placeholder !== \"\") && el) {\r\n\t\t\t\tpos = el.inputmask._valueGet().length - pos;\r\n\t\t\t}\r\n\t\t\treturn pos;\r\n\t\t}\r\n\r\n\t\tvar range;\r\n\t\tif (begin !== undefined) {\r\n\t\t\tif ($.isArray(begin)) {\r\n\t\t\t\tend = isRTL ? begin[0] : begin[1];\r\n\t\t\t\tbegin = isRTL ? begin[1] : begin[0];\r\n\t\t\t}\r\n\t\t\tif (begin.begin !== undefined) {\r\n\t\t\t\tend = isRTL ? begin.begin : begin.end;\r\n\t\t\t\tbegin = isRTL ? begin.end : begin.begin;\r\n\t\t\t}\r\n\t\t\tif (typeof begin === \"number\") {\r\n\t\t\t\tbegin = notranslate ? begin : translatePosition(begin);\r\n\t\t\t\tend = notranslate ? end : translatePosition(end);\r\n\t\t\t\tend = (typeof end == \"number\") ? end : begin;\r\n\t\t\t\t// if (!$(input).is(\":visible\")) {\r\n\t\t\t\t// \treturn;\r\n\t\t\t\t// }\r\n\r\n\t\t\t\tvar scrollCalc = parseInt(((input.ownerDocument.defaultView || window).getComputedStyle ? (input.ownerDocument.defaultView || window).getComputedStyle(input, null) : input.currentStyle).fontSize) * end;\r\n\t\t\t\tinput.scrollLeft = scrollCalc > input.scrollWidth ? scrollCalc : 0;\r\n\r\n\t\t\t\tinput.inputmask.caretPos = {begin: begin, end: end}; //track caret internally\r\n\t\t\t\tif (input === document.activeElement) {\r\n\t\t\t\t\tif (\"setSelectionRange\" in input) {\r\n\t\t\t\t\t\tinput.setSelectionRange(begin, end);\r\n\t\t\t\t\t} else if (window.getSelection) {\r\n\t\t\t\t\t\trange = document.createRange();\r\n\t\t\t\t\t\tif (input.firstChild === undefined || input.firstChild === null) {\r\n\t\t\t\t\t\t\tvar textNode = document.createTextNode(\"\");\r\n\t\t\t\t\t\t\tinput.appendChild(textNode);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\trange.setStart(input.firstChild, begin < input.inputmask._valueGet().length ? begin : input.inputmask._valueGet().length);\r\n\t\t\t\t\t\trange.setEnd(input.firstChild, end < input.inputmask._valueGet().length ? end : input.inputmask._valueGet().length);\r\n\t\t\t\t\t\trange.collapse(true);\r\n\t\t\t\t\t\tvar sel = window.getSelection();\r\n\t\t\t\t\t\tsel.removeAllRanges();\r\n\t\t\t\t\t\tsel.addRange(range);\r\n\t\t\t\t\t\t//input.focus();\r\n\t\t\t\t\t} else if (input.createTextRange) {\r\n\t\t\t\t\t\trange = input.createTextRange();\r\n\t\t\t\t\t\trange.collapse(true);\r\n\t\t\t\t\t\trange.moveEnd(\"character\", end);\r\n\t\t\t\t\t\trange.moveStart(\"character\", begin);\r\n\t\t\t\t\t\trange.select();\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\trenderColorMask(input, {\r\n\t\t\t\t\t\tbegin: begin,\r\n\t\t\t\t\t\tend: end\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (\"selectionStart\" in input && \"selectionEnd\" in input) {\r\n\t\t\t\tbegin = input.selectionStart;\r\n\t\t\t\tend = input.selectionEnd;\r\n\t\t\t} else if (window.getSelection) {\r\n\t\t\t\trange = window.getSelection().getRangeAt(0);\r\n\t\t\t\tif (range.commonAncestorContainer.parentNode === input || range.commonAncestorContainer === input) {\r\n\t\t\t\t\tbegin = range.startOffset;\r\n\t\t\t\t\tend = range.endOffset;\r\n\t\t\t\t}\r\n\t\t\t} else if (document.selection && document.selection.createRange) {\r\n\t\t\t\trange = document.selection.createRange();\r\n\t\t\t\tbegin = 0 - range.duplicate().moveStart(\"character\", -input.inputmask._valueGet().length);\r\n\t\t\t\tend = begin + range.text.length;\r\n\t\t\t}\r\n\r\n\t\t\t/*eslint-disable consistent-return */\r\n\t\t\treturn {\r\n\t\t\t\t\"begin\": notranslate ? begin : translatePosition(begin),\r\n\t\t\t\t\"end\": notranslate ? end : translatePosition(end)\r\n\t\t\t};\r\n\t\t\t/*eslint-enable consistent-return */\r\n\t\t}\r\n\t}\r\n\r\n\tfunction determineLastRequiredPosition(returnDefinition) {\r\n\t\tvar buffer = getMaskTemplate(true, getLastValidPosition(), true, true),\r\n\t\t\tbl = buffer.length,\r\n\t\t\tpos, lvp = getLastValidPosition(),\r\n\t\t\tpositions = {},\r\n\t\t\tlvTest = maskset.validPositions[lvp],\r\n\t\t\tndxIntlzr = lvTest !== undefined ? lvTest.locator.slice() : undefined,\r\n\t\t\ttestPos;\r\n\t\tfor (pos = lvp + 1; pos < buffer.length; pos++) {\r\n\t\t\ttestPos = getTestTemplate(pos, ndxIntlzr, pos - 1);\r\n\t\t\tndxIntlzr = testPos.locator.slice();\r\n\t\t\tpositions[pos] = $.extend(true, {}, testPos);\r\n\t\t}\r\n\r\n\t\tvar lvTestAlt = lvTest && lvTest.alternation !== undefined ? lvTest.locator[lvTest.alternation] : undefined;\r\n\t\tfor (pos = bl - 1; pos > lvp; pos--) {\r\n\t\t\ttestPos = positions[pos];\r\n\t\t\tif ((testPos.match.optionality ||\r\n\t\t\t\t\t(testPos.match.optionalQuantifier && testPos.match.newBlockMarker) ||\r\n\t\t\t\t\t(lvTestAlt &&\r\n\t\t\t\t\t\t(\r\n\t\t\t\t\t\t\t(lvTestAlt !== positions[pos].locator[lvTest.alternation] && testPos.match.static != true) ||\r\n\t\t\t\t\t\t\t(testPos.match.static === true &&\r\n\t\t\t\t\t\t\t\ttestPos.locator[lvTest.alternation] &&\r\n\t\t\t\t\t\t\t\tcheckAlternationMatch(testPos.locator[lvTest.alternation].toString().split(\",\"), lvTestAlt.toString().split(\",\")) &&\r\n\t\t\t\t\t\t\t\tgetTests(pos)[0].def !== \"\")\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t)\r\n\t\t\t\t) &&\r\n\t\t\t\tbuffer[pos] === getPlaceholder(pos, testPos.match)) {\r\n\t\t\t\tbl--;\r\n\t\t\t} else {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn returnDefinition ? {\r\n\t\t\t\"l\": bl,\r\n\t\t\t\"def\": positions[bl] ? positions[bl].match : undefined\r\n\t\t} : bl;\r\n\t}\r\n\r\n\tfunction clearOptionalTail(buffer) {\r\n\t\tbuffer.length = 0;\r\n\t\tvar template = getMaskTemplate(true, 0, true, undefined, true), lmnt;\r\n\t\twhile ((lmnt = template.shift()) !== undefined) buffer.push(lmnt);\r\n\t\treturn buffer;\r\n\t}\r\n\r\n\tfunction isComplete(buffer) { //return true / false / undefined (repeat *)\r\n\t\tif ($.isFunction(opts.isComplete)) return opts.isComplete(buffer, opts);\r\n\t\tif (opts.repeat === \"*\") return undefined;\r\n\t\tvar complete = false,\r\n\t\t\tlrp = determineLastRequiredPosition(true),\r\n\t\t\taml = seekPrevious(lrp.l);\r\n\r\n\t\tif (lrp.def === undefined || lrp.def.newBlockMarker || lrp.def.optionality || lrp.def.optionalQuantifier) {\r\n\t\t\tcomplete = true;\r\n\t\t\tfor (var i = 0; i <= aml; i++) {\r\n\t\t\t\tvar test = getTestTemplate(i).match;\r\n\t\t\t\tif ((test.static !== true && maskset.validPositions[i] === undefined && test.optionality !== true && test.optionalQuantifier !== true) || (test.static === true && buffer[i] !== getPlaceholder(i, test))) {\r\n\t\t\t\t\tcomplete = false;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn complete;\r\n\t}\r\n\r\n\r\n\tfunction handleRemove(input, k, pos, strict, fromIsValid) {\r\n\t\tif (opts.numericInput || isRTL) {\r\n\t\t\tif (k === Inputmask.keyCode.BACKSPACE) {\r\n\t\t\t\tk = Inputmask.keyCode.DELETE;\r\n\t\t\t} else if (k === Inputmask.keyCode.DELETE) {\r\n\t\t\t\tk = Inputmask.keyCode.BACKSPACE;\r\n\t\t\t}\r\n\r\n\t\t\tif (isRTL) {\r\n\t\t\t\tvar pend = pos.end;\r\n\t\t\t\tpos.end = pos.begin;\r\n\t\t\t\tpos.begin = pend;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (k === Inputmask.keyCode.BACKSPACE && (pos.end - pos.begin < 1)) {\r\n\t\t\tpos.begin = seekPrevious(pos.begin);\r\n\t\t\tif (maskset.validPositions[pos.begin] !== undefined && maskset.validPositions[pos.begin].input === opts.groupSeparator) {\r\n\t\t\t\tpos.begin--;\r\n\t\t\t}\r\n\t\t} else if (k === Inputmask.keyCode.DELETE && pos.begin === pos.end) {\r\n\t\t\tpos.end = isMask(pos.end, true) && (maskset.validPositions[pos.end] && maskset.validPositions[pos.end].input !== opts.radixPoint) ?\r\n\t\t\t\tpos.end + 1 :\r\n\t\t\t\tseekNext(pos.end) + 1;\r\n\t\t\tif (maskset.validPositions[pos.begin] !== undefined && maskset.validPositions[pos.begin].input === opts.groupSeparator) {\r\n\t\t\t\tpos.end++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\trevalidateMask(pos);\r\n\r\n\t\tif (strict !== true && opts.keepStatic !== false || opts.regex !== null) {\r\n\t\t\tvar result = alternate(true);\r\n\t\t\tif (result) {\r\n\t\t\t\tvar newPos = result.caret !== undefined ? result.caret : (result.pos ? seekNext(result.pos.begin ? result.pos.begin : result.pos) : getLastValidPosition(-1, true));\r\n\t\t\t\tif (k !== Inputmask.keyCode.DELETE || pos.begin > newPos) {\r\n\t\t\t\t\tpos.begin == newPos;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar lvp = getLastValidPosition(pos.begin, true);\r\n\t\tif (lvp < pos.begin || pos.begin === -1) {\r\n\t\t\t//if (lvp === -1) resetMaskSet();\r\n\t\t\tmaskset.p = seekNext(lvp);\r\n\t\t} else if (strict !== true) {\r\n\t\t\tmaskset.p = pos.begin;\r\n\t\t\tif (fromIsValid !== true) {\r\n\t\t\t\t//put position on first valid from pos.begin ~ #1351\r\n\t\t\t\twhile (maskset.p < lvp && maskset.validPositions[maskset.p] === undefined) {\r\n\t\t\t\t\tmaskset.p++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction initializeColorMask(input) {\r\n\t\tvar computedStyle = (input.ownerDocument.defaultView || window).getComputedStyle(input, null);\r\n\r\n\t\tfunction findCaretPos(clientx) {\r\n\t\t\t//calculate text width\r\n\t\t\tvar e = document.createElement(\"span\"),\r\n\t\t\t\tcaretPos;\r\n\t\t\tfor (var style in computedStyle) { //clone styles\r\n\t\t\t\tif (isNaN(style) && style.indexOf(\"font\") !== -1) {\r\n\t\t\t\t\te.style[style] = computedStyle[style];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\te.style.textTransform = computedStyle.textTransform;\r\n\t\t\te.style.letterSpacing = computedStyle.letterSpacing;\r\n\t\t\te.style.position = \"absolute\";\r\n\t\t\te.style.height = \"auto\";\r\n\t\t\te.style.width = \"auto\";\r\n\t\t\te.style.visibility = \"hidden\";\r\n\t\t\te.style.whiteSpace = \"nowrap\";\r\n\r\n\t\t\tdocument.body.appendChild(e);\r\n\t\t\tvar inputText = input.inputmask._valueGet(),\r\n\t\t\t\tpreviousWidth = 0,\r\n\t\t\t\titl;\r\n\t\t\tfor (caretPos = 0, itl = inputText.length; caretPos <= itl; caretPos++) {\r\n\t\t\t\te.innerHTML += inputText.charAt(caretPos) || \"_\";\r\n\t\t\t\tif (e.offsetWidth >= clientx) {\r\n\t\t\t\t\tvar offset1 = (clientx - previousWidth);\r\n\t\t\t\t\tvar offset2 = e.offsetWidth - clientx;\r\n\t\t\t\t\te.innerHTML = inputText.charAt(caretPos);\r\n\t\t\t\t\toffset1 -= (e.offsetWidth / 3);\r\n\t\t\t\t\tcaretPos = offset1 < offset2 ? caretPos - 1 : caretPos;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tpreviousWidth = e.offsetWidth;\r\n\t\t\t}\r\n\t\t\tdocument.body.removeChild(e);\r\n\t\t\treturn caretPos;\r\n\t\t}\r\n\r\n\t\tvar template = document.createElement(\"div\");\r\n\t\ttemplate.style.width = computedStyle.width;\r\n\t\ttemplate.style.textAlign = computedStyle.textAlign;\r\n\t\tcolorMask = document.createElement(\"div\");\r\n\t\tinput.inputmask.colorMask = colorMask;\r\n\t\tcolorMask.className = \"im-colormask\";\r\n\t\tinput.parentNode.insertBefore(colorMask, input);\r\n\t\tinput.parentNode.removeChild(input);\r\n\t\tcolorMask.appendChild(input);\r\n\t\tcolorMask.appendChild(template);\r\n\t\tinput.style.left = template.offsetLeft + \"px\";\r\n\r\n\t\t$(colorMask).on(\"mouseleave\", function (e) {\r\n\t\t\treturn EventHandlers.mouseleaveEvent.call(input, [e]);\r\n\t\t});\r\n\t\t$(colorMask).on(\"mouseenter\", function (e) {\r\n\t\t\treturn EventHandlers.mouseenterEvent.call(input, [e]);\r\n\t\t});\r\n\t\t$(colorMask).on(\"click\", function (e) {\r\n\t\t\tcaret(input, findCaretPos(e.clientX));\r\n\t\t\treturn EventHandlers.clickEvent.call(input, [e]);\r\n\t\t});\r\n\t}\r\n\r\n\r\n\tfunction renderColorMask(input, caretPos, clear) {\r\n\t\tvar maskTemplate = [],\r\n\t\t\tisStatic = false,\r\n\t\t\ttest, testPos, ndxIntlzr, pos = 0;\r\n\r\n\r\n\t\tfunction setEntry(entry) {\r\n\t\t\tif (entry === undefined) entry = \"\";\r\n\t\t\tif (!isStatic && (test.static === true || testPos.input === undefined)) {\r\n\t\t\t\tisStatic = true;\r\n\t\t\t\tmaskTemplate.push(\"<span class='im-static'>\" + entry);\r\n\t\t\t} else if (isStatic && ((test.static !== true && testPos.input !== undefined) || test.def === \"\")) {\r\n\t\t\t\tisStatic = false;\r\n\t\t\t\tvar mtl = maskTemplate.length;\r\n\t\t\t\tmaskTemplate[mtl - 1] = maskTemplate[mtl - 1] + \"</span>\";\r\n\t\t\t\tmaskTemplate.push(entry);\r\n\t\t\t} else {\r\n\t\t\t\tmaskTemplate.push(entry);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction setCaret() {\r\n\t\t\tif (document.activeElement === input) {\r\n\t\t\t\tmaskTemplate.splice(caretPos.begin, 0,\r\n\t\t\t\t\t(caretPos.begin === caretPos.end || caretPos.end > maskset.maskLength) ?\r\n\t\t\t\t\t\t\"<mark class=\\\"im-caret\\\" style=\\\"border-right-width: 1px;border-right-style: solid;\\\">\" :\r\n\t\t\t\t\t\t\"<mark class=\\\"im-caret-select\\\">\");\r\n\t\t\t\tmaskTemplate.splice(caretPos.end + 1, 0, \"</mark>\");\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (colorMask !== undefined) {\r\n\t\t\tvar buffer = getBuffer();\r\n\t\t\tif (caretPos === undefined) {\r\n\t\t\t\tcaretPos = caret(input);\r\n\t\t\t} else if (caretPos.begin === undefined) {\r\n\t\t\t\tcaretPos = {\r\n\t\t\t\t\tbegin: caretPos,\r\n\t\t\t\t\tend: caretPos\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tif (clear !== true) {\r\n\t\t\t\tvar lvp = getLastValidPosition();\r\n\t\t\t\tdo {\r\n\t\t\t\t\tif (maskset.validPositions[pos]) {\r\n\t\t\t\t\t\ttestPos = maskset.validPositions[pos];\r\n\t\t\t\t\t\ttest = testPos.match;\r\n\t\t\t\t\t\tndxIntlzr = testPos.locator.slice();\r\n\t\t\t\t\t\tsetEntry(buffer[pos]);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttestPos = getTestTemplate(pos, ndxIntlzr, pos - 1);\r\n\t\t\t\t\t\ttest = testPos.match;\r\n\t\t\t\t\t\tndxIntlzr = testPos.locator.slice();\r\n\t\t\t\t\t\tif (opts.jitMasking === false || pos < lvp || (typeof opts.jitMasking === \"number\" && isFinite(opts.jitMasking) && opts.jitMasking > pos)) {\r\n\t\t\t\t\t\t\tsetEntry(getPlaceholder(pos, test));\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tisStatic = false;\r\n\t\t\t\t\t\t} //break infinite loop\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpos++;\r\n\t\t\t\t} while ((maxLength === undefined || pos < maxLength) && (test.static !== true || test.def !== \"\") || lvp > pos || isStatic);\r\n\t\t\t\tif (isStatic) setEntry();\r\n\t\t\t\tsetCaret();\r\n\t\t\t}\r\n\r\n\t\t\tvar template = colorMask.getElementsByTagName(\"div\")[0];\r\n\t\t\ttemplate.innerHTML = maskTemplate.join(\"\");\r\n\t\t\tinput.inputmask.positionColorMask(input, template);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction applyInputValue(input, value) {\r\n\t\tinput.inputmask.refreshValue = false;\r\n\t\tif ($.isFunction(opts.onBeforeMask)) value = opts.onBeforeMask.call(inputmask, value, opts) || value;\r\n\t\tvalue = value.toString().split(\"\");\r\n\t\tcheckVal(input, true, false, value);\r\n\t\tundoValue = getBuffer().join(\"\");\r\n\t\tif ((opts.clearMaskOnLostFocus || opts.clearIncomplete) && input.inputmask._valueGet() === getBufferTemplate().join(\"\") && getLastValidPosition() === -1) {\r\n\t\t\tinput.inputmask._valueSet(\"\");\r\n\t\t}\r\n\t}\r\n\r\n\tfunction mask(elem) {\r\n\t\tfunction isElementTypeSupported(input, opts) {\r\n\t\t\tfunction patchValueProperty(npt) {\r\n\t\t\t\tvar valueGet;\r\n\t\t\t\tvar valueSet;\r\n\r\n\t\t\t\tfunction patchValhook(type) {\r\n\t\t\t\t\tif ($.valHooks && ($.valHooks[type] === undefined || $.valHooks[type].inputmaskpatch !== true)) {\r\n\t\t\t\t\t\tvar valhookGet = $.valHooks[type] && $.valHooks[type].get ? $.valHooks[type].get : function (elem) {\r\n\t\t\t\t\t\t\treturn elem.value;\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\tvar valhookSet = $.valHooks[type] && $.valHooks[type].set ? $.valHooks[type].set : function (elem, value) {\r\n\t\t\t\t\t\t\telem.value = value;\r\n\t\t\t\t\t\t\treturn elem;\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t$.valHooks[type] = {\r\n\t\t\t\t\t\t\tget: function (elem) {\r\n\t\t\t\t\t\t\t\tif (elem.inputmask) {\r\n\t\t\t\t\t\t\t\t\tif (elem.inputmask.opts.autoUnmask) {\r\n\t\t\t\t\t\t\t\t\t\treturn elem.inputmask.unmaskedvalue();\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tvar result = valhookGet(elem);\r\n\t\t\t\t\t\t\t\t\t\treturn getLastValidPosition(undefined, undefined, elem.inputmask.maskset.validPositions) !== -1 || opts.nullable !== true ? result : \"\";\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\treturn valhookGet(elem);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tset: function (elem, value) {\r\n\t\t\t\t\t\t\t\tvar result = valhookSet(elem, value);\r\n\t\t\t\t\t\t\t\tif (elem.inputmask) {\r\n\t\t\t\t\t\t\t\t\tapplyInputValue(elem, value);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\treturn result;\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tinputmaskpatch: true\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfunction getter() {\r\n\t\t\t\t\tif (this.inputmask) {\r\n\t\t\t\t\t\treturn this.inputmask.opts.autoUnmask ?\r\n\t\t\t\t\t\t\tthis.inputmask.unmaskedvalue() :\r\n\t\t\t\t\t\t\t(getLastValidPosition() !== -1 || opts.nullable !== true ?\r\n\t\t\t\t\t\t\t\t(document.activeElement === this && opts.clearMaskOnLostFocus ?\r\n\t\t\t\t\t\t\t\t\t(isRTL ? clearOptionalTail(getBuffer().slice()).reverse() : clearOptionalTail(getBuffer().slice())).join(\"\") :\r\n\t\t\t\t\t\t\t\t\tvalueGet.call(this)) :\r\n\t\t\t\t\t\t\t\t\"\");\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn valueGet.call(this);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfunction setter(value) {\r\n\t\t\t\t\tvalueSet.call(this, value);\r\n\t\t\t\t\tif (this.inputmask) {\r\n\t\t\t\t\t\tapplyInputValue(this, value);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfunction installNativeValueSetFallback(npt) {\r\n\t\t\t\t\tEventRuler.on(npt, \"mouseenter\", function () {\r\n\t\t\t\t\t\tvar input = this,\r\n\t\t\t\t\t\t\tvalue = input.inputmask._valueGet(true);\r\n\t\t\t\t\t\tif (value !== (isRTL ? getBuffer().reverse() : getBuffer()).join(\"\")) { //Is this correct? to apply RTL? TOCHECK\r\n\t\t\t\t\t\t\tapplyInputValue(input, value);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!npt.inputmask.__valueGet) {\r\n\t\t\t\t\tif (opts.noValuePatching !== true) {\r\n\t\t\t\t\t\tif (Object.getOwnPropertyDescriptor) {\r\n\t\t\t\t\t\t\tif (typeof Object.getPrototypeOf !== \"function\") {\r\n\t\t\t\t\t\t\t\tObject.getPrototypeOf = typeof \"test\".__proto__ === \"object\" ? function (object) {\r\n\t\t\t\t\t\t\t\t\treturn object.__proto__;\r\n\t\t\t\t\t\t\t\t} : function (object) {\r\n\t\t\t\t\t\t\t\t\treturn object.constructor.prototype;\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tvar valueProperty = Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(npt), \"value\") : undefined;\r\n\t\t\t\t\t\t\tif (valueProperty && valueProperty.get && valueProperty.set) {\r\n\t\t\t\t\t\t\t\tvalueGet = valueProperty.get;\r\n\t\t\t\t\t\t\t\tvalueSet = valueProperty.set;\r\n\t\t\t\t\t\t\t\tObject.defineProperty(npt, \"value\", {\r\n\t\t\t\t\t\t\t\t\tget: getter,\r\n\t\t\t\t\t\t\t\t\tset: setter,\r\n\t\t\t\t\t\t\t\t\tconfigurable: true\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t} else if (npt.tagName !== \"INPUT\") {\r\n\t\t\t\t\t\t\t\tvalueGet = function () {\r\n\t\t\t\t\t\t\t\t\treturn this.textContent;\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t\tvalueSet = function (value) {\r\n\t\t\t\t\t\t\t\t\tthis.textContent = value;\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t\tObject.defineProperty(npt, \"value\", {\r\n\t\t\t\t\t\t\t\t\tget: getter,\r\n\t\t\t\t\t\t\t\t\tset: setter,\r\n\t\t\t\t\t\t\t\t\tconfigurable: true\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else if (document.__lookupGetter__ && npt.__lookupGetter__(\"value\")) {\r\n\t\t\t\t\t\t\tvalueGet = npt.__lookupGetter__(\"value\");\r\n\t\t\t\t\t\t\tvalueSet = npt.__lookupSetter__(\"value\");\r\n\r\n\t\t\t\t\t\t\tnpt.__defineGetter__(\"value\", getter);\r\n\t\t\t\t\t\t\tnpt.__defineSetter__(\"value\", setter);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tnpt.inputmask.__valueGet = valueGet; //store native property getter\r\n\t\t\t\t\t\tnpt.inputmask.__valueSet = valueSet; //store native property setter\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnpt.inputmask._valueGet = function (overruleRTL) {\r\n\t\t\t\t\t\treturn isRTL && overruleRTL !== true ? valueGet.call(this.el).split(\"\").reverse().join(\"\") : valueGet.call(this.el);\r\n\t\t\t\t\t};\r\n\t\t\t\t\tnpt.inputmask._valueSet = function (value, overruleRTL) { //null check is needed for IE8 => otherwise converts to \"null\"\r\n\t\t\t\t\t\tvalueSet.call(this.el, (value === null || value === undefined) ? \"\" : ((overruleRTL !== true && isRTL) ? value.split(\"\").reverse().join(\"\") : value));\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tif (valueGet === undefined) { //jquery.val fallback\r\n\t\t\t\t\t\tvalueGet = function () {\r\n\t\t\t\t\t\t\treturn this.value;\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\tvalueSet = function (value) {\r\n\t\t\t\t\t\t\tthis.value = value;\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\tpatchValhook(npt.type);\r\n\t\t\t\t\t\tinstallNativeValueSetFallback(npt);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar elementType = input.getAttribute(\"type\");\r\n\t\t\tvar isSupported = (input.tagName === \"INPUT\" && $.inArray(elementType, opts.supportsInputType) !== -1) || input.isContentEditable || input.tagName === \"TEXTAREA\";\r\n\t\t\tif (!isSupported) {\r\n\t\t\t\tif (input.tagName === \"INPUT\") {\r\n\t\t\t\t\tvar el = document.createElement(\"input\");\r\n\t\t\t\t\tel.setAttribute(\"type\", elementType);\r\n\t\t\t\t\tisSupported = el.type === \"text\"; //apply mask only if the type is not natively supported\r\n\t\t\t\t\tel = null;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tisSupported = \"partial\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (isSupported !== false) {\r\n\t\t\t\tpatchValueProperty(input);\r\n\t\t\t} else {\r\n\t\t\t\tinput.inputmask = undefined;\r\n\t\t\t}\r\n\t\t\treturn isSupported;\r\n\t\t}\r\n\r\n\t\t//unbind all events - to make sure that no other mask will interfere when re-masking\r\n\t\tEventRuler.off(elem);\r\n\t\tvar isSupported = isElementTypeSupported(elem, opts);\r\n\t\tif (isSupported !== false) {\r\n\t\t\tel = elem;\r\n\t\t\t$el = $(el);\r\n\r\n\t\t\toriginalPlaceholder = el.placeholder;\r\n\r\n\t\t\t//read maxlength prop from el\r\n\t\t\tmaxLength = el !== undefined ? el.maxLength : undefined;\r\n\t\t\tif (maxLength === -1) maxLength = undefined;\r\n\r\n\t\t\tif (opts.colorMask === true) {\r\n\t\t\t\tinitializeColorMask(el);\r\n\t\t\t}\r\n\t\t\tif (mobile) {\r\n\t\t\t\tif (\"inputmode\" in el) {\r\n\t\t\t\t\tel.inputmode = opts.inputmode;\r\n\t\t\t\t\tel.setAttribute(\"inputmode\", opts.inputmode);\r\n\t\t\t\t}\r\n\t\t\t\tif (opts.disablePredictiveText === true) {\r\n\t\t\t\t\tif (\"autocorrect\" in el) {  //safari\r\n\t\t\t\t\t\tel.autocorrect = false;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (opts.colorMask !== true) {\r\n\t\t\t\t\t\t\tinitializeColorMask(el);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tel.type = \"password\";\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (isSupported === true) {\r\n\t\t\t\tel.setAttribute(\"data-im-insert\", opts.insertMode);\r\n\r\n\t\t\t\t//bind events\r\n\t\t\t\tEventRuler.on(el, \"submit\", EventHandlers.submitEvent);\r\n\t\t\t\tEventRuler.on(el, \"reset\", EventHandlers.resetEvent);\r\n\t\t\t\tEventRuler.on(el, \"invalid\", EventHandlers.invalidEvent);\r\n\t\t\t\tEventRuler.on(el, \"blur\", EventHandlers.blurEvent);\r\n\t\t\t\tEventRuler.on(el, \"focus\", EventHandlers.focusEvent);\r\n\t\t\t\tif (opts.colorMask !== true) {\r\n\t\t\t\t\tEventRuler.on(el, \"click\", EventHandlers.clickEvent);\r\n\t\t\t\t\tEventRuler.on(el, \"mouseleave\", EventHandlers.mouseleaveEvent);\r\n\t\t\t\t\tEventRuler.on(el, \"mouseenter\", EventHandlers.mouseenterEvent);\r\n\t\t\t\t}\r\n\t\t\t\tEventRuler.on(el, \"paste\", EventHandlers.pasteEvent);\r\n\t\t\t\tEventRuler.on(el, \"cut\", EventHandlers.cutEvent);\r\n\t\t\t\tEventRuler.on(el, \"complete\", opts.oncomplete);\r\n\t\t\t\tEventRuler.on(el, \"incomplete\", opts.onincomplete);\r\n\t\t\t\tEventRuler.on(el, \"cleared\", opts.oncleared);\r\n\t\t\t\tif (!mobile && opts.inputEventOnly !== true) {\r\n\t\t\t\t\tEventRuler.on(el, \"keydown\", EventHandlers.keydownEvent);\r\n\t\t\t\t\tEventRuler.on(el, \"keypress\", EventHandlers.keypressEvent);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tel.removeAttribute(\"maxLength\");\r\n\t\t\t\t}\r\n\t\t\t\tEventRuler.on(el, \"input\", EventHandlers.inputFallBackEvent);\r\n\t\t\t\tEventRuler.on(el, \"beforeinput\", EventHandlers.beforeInputEvent); //https://github.com/w3c/input-events - to implement\r\n\t\t\t}\r\n\t\t\tEventRuler.on(el, \"setvalue\", EventHandlers.setValueEvent);\r\n\r\n\t\t\t//apply mask\r\n\t\t\tundoValue = getBufferTemplate().join(\"\"); //initialize the buffer and getmasklength\r\n\t\t\tif (el.inputmask._valueGet(true) !== \"\" || opts.clearMaskOnLostFocus === false || document.activeElement === el) {\r\n\t\t\t\tvar initialValue = $.isFunction(opts.onBeforeMask) ? (opts.onBeforeMask.call(inputmask, el.inputmask._valueGet(true), opts) || el.inputmask._valueGet(true)) : el.inputmask._valueGet(true);\r\n\t\t\t\tif (initialValue !== \"\") checkVal(el, true, false, initialValue.split(\"\"));\r\n\t\t\t\tvar buffer = getBuffer().slice();\r\n\t\t\t\tundoValue = buffer.join(\"\");\r\n\t\t\t\t// Wrap document.activeElement in a try/catch block since IE9 throw \"Unspecified error\" if document.activeElement is undefined when we are in an IFrame.\r\n\t\t\t\tif (isComplete(buffer) === false) {\r\n\t\t\t\t\tif (opts.clearIncomplete) {\r\n\t\t\t\t\t\tresetMaskSet();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (opts.clearMaskOnLostFocus && document.activeElement !== el) {\r\n\t\t\t\t\tif (getLastValidPosition() === -1) {\r\n\t\t\t\t\t\tbuffer = [];\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tclearOptionalTail(buffer);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (opts.clearMaskOnLostFocus === false || (opts.showMaskOnFocus && document.activeElement === el) || el.inputmask._valueGet(true) !== \"\") {\r\n\t\t\t\t\twriteBuffer(el, buffer);\r\n\t\t\t\t}\r\n\t\t\t\tif (document.activeElement === el) { //position the caret when in focus\r\n\t\t\t\t\tcaret(el, seekNext(getLastValidPosition()));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t//action object\r\n\tvar valueBuffer;\r\n\tif (actionObj !== undefined) {\r\n\t\tswitch (actionObj.action) {\r\n\t\t\tcase \"isComplete\":\r\n\t\t\t\tel = actionObj.el;\r\n\t\t\t\treturn isComplete(getBuffer());\r\n\t\t\tcase \"unmaskedvalue\":\r\n\t\t\t\tif (el === undefined || actionObj.value !== undefined) {\r\n\t\t\t\t\tvalueBuffer = actionObj.value;\r\n\t\t\t\t\tvalueBuffer = ($.isFunction(opts.onBeforeMask) ? (opts.onBeforeMask.call(inputmask, valueBuffer, opts) || valueBuffer) : valueBuffer).split(\"\");\r\n\t\t\t\t\tcheckVal.call(this, undefined, false, false, valueBuffer);\r\n\t\t\t\t\tif ($.isFunction(opts.onBeforeWrite)) opts.onBeforeWrite.call(inputmask, undefined, getBuffer(), 0, opts);\r\n\t\t\t\t}\r\n\t\t\t\treturn unmaskedvalue(el);\r\n\t\t\tcase \"mask\":\r\n\t\t\t\tmask(el);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"format\":\r\n\t\t\t\tvalueBuffer = ($.isFunction(opts.onBeforeMask) ? (opts.onBeforeMask.call(inputmask, actionObj.value, opts) || actionObj.value) : actionObj.value).split(\"\");\r\n\t\t\t\tcheckVal.call(this, undefined, true, false, valueBuffer);\r\n\t\t\t\tif (actionObj.metadata) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tvalue: isRTL ? getBuffer().slice().reverse().join(\"\") : getBuffer().join(\"\"),\r\n\t\t\t\t\t\tmetadata: maskScope.call(this, {\r\n\t\t\t\t\t\t\t\"action\": \"getmetadata\"\r\n\t\t\t\t\t\t}, maskset, opts)\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn isRTL ? getBuffer().slice().reverse().join(\"\") : getBuffer().join(\"\");\r\n\t\t\tcase \"isValid\":\r\n\t\t\t\tif (actionObj.value) {\r\n\t\t\t\t\tvalueBuffer = actionObj.value.split(\"\");\r\n\t\t\t\t\tcheckVal.call(this, undefined, true, false, valueBuffer);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tactionObj.value = isRTL ? getBuffer().slice().reverse().join(\"\") : getBuffer().join(\"\");\r\n\t\t\t\t}\r\n\t\t\t\tvar buffer = getBuffer();\r\n\t\t\t\tvar rl = determineLastRequiredPosition(),\r\n\t\t\t\t\tlmib = buffer.length - 1;\r\n\t\t\t\tfor (; lmib > rl; lmib--) {\r\n\t\t\t\t\tif (isMask(lmib)) break;\r\n\t\t\t\t}\r\n\t\t\t\tbuffer.splice(rl, lmib + 1 - rl);\r\n\r\n\t\t\t\treturn isComplete(buffer) && actionObj.value === (isRTL ? getBuffer().slice().reverse().join(\"\") : getBuffer().join(\"\"));\r\n\t\t\tcase \"getemptymask\":\r\n\t\t\t\treturn getBufferTemplate().join(\"\");\r\n\t\t\tcase \"remove\":\r\n\t\t\t\tif (el && el.inputmask) {\r\n\t\t\t\t\t$.data(el, \"_inputmask_opts\", null); //invalidate\r\n\t\t\t\t\t$el = $(el);\r\n\t\t\t\t\t//writeout the value\r\n\t\t\t\t\tvar cv = opts.autoUnmask ? unmaskedvalue(el) : el.inputmask._valueGet(opts.autoUnmask);\r\n\t\t\t\t\tif (cv !== getBufferTemplate().join(\"\")) el.inputmask._valueSet(cv, opts.autoUnmask); else el.inputmask._valueSet(\"\");\r\n\t\t\t\t\t//unbind all events\r\n\t\t\t\t\tEventRuler.off(el);\r\n\t\t\t\t\t//remove colormask if used\r\n\t\t\t\t\tif (el.inputmask.colorMask) {\r\n\t\t\t\t\t\tcolorMask = el.inputmask.colorMask;\r\n\t\t\t\t\t\tcolorMask.removeChild(el);\r\n\t\t\t\t\t\tcolorMask.parentNode.insertBefore(el, colorMask);\r\n\t\t\t\t\t\tcolorMask.parentNode.removeChild(colorMask);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//restore the value property\r\n\t\t\t\t\tvar valueProperty;\r\n\t\t\t\t\tif (Object.getOwnPropertyDescriptor && Object.getPrototypeOf) {\r\n\t\t\t\t\t\tvalueProperty = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(el), \"value\");\r\n\t\t\t\t\t\tif (valueProperty) {\r\n\t\t\t\t\t\t\tif (el.inputmask.__valueGet) {\r\n\t\t\t\t\t\t\t\tObject.defineProperty(el, \"value\", {\r\n\t\t\t\t\t\t\t\t\tget: el.inputmask.__valueGet,\r\n\t\t\t\t\t\t\t\t\tset: el.inputmask.__valueSet,\r\n\t\t\t\t\t\t\t\t\tconfigurable: true\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (document.__lookupGetter__ && el.__lookupGetter__(\"value\")) {\r\n\t\t\t\t\t\tif (el.inputmask.__valueGet) {\r\n\t\t\t\t\t\t\tel.__defineGetter__(\"value\", el.inputmask.__valueGet);\r\n\t\t\t\t\t\t\tel.__defineSetter__(\"value\", el.inputmask.__valueSet);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//clear data\r\n\t\t\t\t\tel.inputmask = undefined;\r\n\t\t\t\t}\r\n\t\t\t\treturn el;\r\n\t\t\tcase \"getmetadata\":\r\n\t\t\t\tif ($.isArray(maskset.metadata)) {\r\n\t\t\t\t\tvar maskTarget = getMaskTemplate(true, 0, false).join(\"\");\r\n\t\t\t\t\t$.each(maskset.metadata, function (ndx, mtdt) {\r\n\t\t\t\t\t\tif (mtdt.mask === maskTarget) {\r\n\t\t\t\t\t\t\tmaskTarget = mtdt;\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t\treturn maskTarget;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn maskset.metadata;\r\n\t\t}\r\n\t}\r\n};\r\n\r\n","/*\r\n Input Mask plugin extensions\r\n http://github.com/RobinHerbots/jquery.inputmask\r\n Copyright (c) Robin Herbots\r\n Licensed under the MIT license\r\n */\r\nvar Inputmask = require(\"../inputmask\"), $ = Inputmask.dependencyLib,\r\n\t//supported codes for formatting\r\n\t//http://blog.stevenlevithan.com/archives/date-time-format\r\n\t//https://docs.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings?view=netframework-4.7\r\n\tformatCode = { //regex, valueSetter, type, displayformatter\r\n\t\td: [\"[1-9]|[12][0-9]|3[01]\", Date.prototype.setDate, \"day\", Date.prototype.getDate], //Day of the month as digits; no leading zero for single-digit days.\r\n\t\tdd: [\"0[1-9]|[12][0-9]|3[01]\", Date.prototype.setDate, \"day\", function () {\r\n\t\t\treturn pad(Date.prototype.getDate.call(this), 2);\r\n\t\t}], //Day of the month as digits; leading zero for single-digit days.\r\n\t\tddd: [\"\"], //Day of the week as a three-letter abbreviation.\r\n\t\tdddd: [\"\"], //Day of the week as its full name.\r\n\t\tm: [\"[1-9]|1[012]\", Date.prototype.setMonth, \"month\", function () {\r\n\t\t\treturn Date.prototype.getMonth.call(this) + 1;\r\n\t\t}], //Month as digits; no leading zero for single-digit months.\r\n\t\tmm: [\"0[1-9]|1[012]\", Date.prototype.setMonth, \"month\", function () {\r\n\t\t\treturn pad(Date.prototype.getMonth.call(this) + 1, 2);\r\n\t\t}], //Month as digits; leading zero for single-digit months.\r\n\t\tmmm: [\"\"], //Month as a three-letter abbreviation.\r\n\t\tmmmm: [\"\"], //Month as its full name.\r\n\t\tyy: [\"[0-9]{2}\", Date.prototype.setFullYear, \"year\", function () {\r\n\t\t\treturn pad(Date.prototype.getFullYear.call(this), 2);\r\n\t\t}], //Year as last two digits; leading zero for years less than 10.\r\n\t\tyyyy: [\"[0-9]{4}\", Date.prototype.setFullYear, \"year\", function () {\r\n\t\t\treturn pad(Date.prototype.getFullYear.call(this), 4);\r\n\t\t}],\r\n\t\th: [\"[1-9]|1[0-2]\", Date.prototype.setHours, \"hours\", Date.prototype.getHours], //Hours; no leading zero for single-digit hours (12-hour clock).\r\n\t\thh: [\"0[1-9]|1[0-2]\", Date.prototype.setHours, \"hours\", function () {\r\n\t\t\treturn pad(Date.prototype.getHours.call(this), 2);\r\n\t\t}], //Hours; leading zero for single-digit hours (12-hour clock).\r\n\t\thhh: [\"[0-9]+\", Date.prototype.setHours, \"hours\", Date.prototype.getHours], //Hours; no limit\r\n\t\tH: [\"1?[0-9]|2[0-3]\", Date.prototype.setHours, \"hours\", Date.prototype.getHours], //Hours; no leading zero for single-digit hours (24-hour clock).\r\n\t\tHH: [\"0[0-9]|1[0-9]|2[0-3]\", Date.prototype.setHours, \"hours\", function () {\r\n\t\t\treturn pad(Date.prototype.getHours.call(this), 2);\r\n\t\t}], //Hours; leading zero for single-digit hours (24-hour clock).\r\n\t\tHHH: [\"[0-9]+\", Date.prototype.setHours, \"hours\", Date.prototype.getHours], //Hours; no limit\r\n\t\tM: [\"[1-5]?[0-9]\", Date.prototype.setMinutes, \"minutes\", Date.prototype.getMinutes], //Minutes; no leading zero for single-digit minutes. Uppercase M unlike CF timeFormat's m to avoid conflict with months.\r\n\t\tMM: [\"0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]\", Date.prototype.setMinutes, \"minutes\", function () {\r\n\t\t\treturn pad(Date.prototype.getMinutes.call(this), 2);\r\n\t\t}], //Minutes; leading zero for single-digit minutes. Uppercase MM unlike CF timeFormat's mm to avoid conflict with months.\r\n\t\ts: [\"[1-5]?[0-9]\", Date.prototype.setSeconds, \"seconds\", Date.prototype.getSeconds], //Seconds; no leading zero for single-digit seconds.\r\n\t\tss: [\"0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]\", Date.prototype.setSeconds, \"seconds\", function () {\r\n\t\t\treturn pad(Date.prototype.getSeconds.call(this), 2);\r\n\t\t}], //Seconds; leading zero for single-digit seconds.\r\n\t\tl: [\"[0-9]{3}\", Date.prototype.setMilliseconds, \"milliseconds\", function () {\r\n\t\t\treturn pad(Date.prototype.getMilliseconds.call(this), 3);\r\n\t\t}], //Milliseconds. 3 digits.\r\n\t\tL: [\"[0-9]{2}\", Date.prototype.setMilliseconds, \"milliseconds\", function () {\r\n\t\t\treturn pad(Date.prototype.getMilliseconds.call(this), 2);\r\n\t\t}], //Milliseconds. 2 digits.\r\n\t\tt: [\"[ap]\"], //Lowercase, single-character time marker string: a or p.\r\n\t\ttt: [\"[ap]m\"], //two-character time marker string: am or pm.\r\n\t\tT: [\"[AP]\"], //single-character time marker string: A or P.\r\n\t\tTT: [\"[AP]M\"], //two-character time marker string: AM or PM.\r\n\t\tZ: [\"\"], //US timezone abbreviation, e.g. EST or MDT. With non-US timezones or in the Opera browser, the GMT/UTC offset is returned, e.g. GMT-0500\r\n\t\to: [\"\"], //GMT/UTC timezone offset, e.g. -0500 or +0230.\r\n\t\tS: [\"\"] //The date's ordinal suffix (st, nd, rd, or th).\r\n\t},\r\n\tformatAlias = {\r\n\t\tisoDate: \"yyyy-mm-dd\", //2007-06-09\r\n\t\tisoTime: \"HH:MM:ss\", //17:46:21\r\n\t\tisoDateTime: \"yyyy-mm-dd'T'HH:MM:ss\", //2007-06-09T17:46:21\r\n\t\tisoUtcDateTime: \"UTC:yyyy-mm-dd'T'HH:MM:ss'Z'\" //2007-06-09T22:46:21Z\r\n\t};\r\n\r\nfunction getTokenizer(opts) {\r\n\tif (!opts.tokenizer) {\r\n\t\tvar tokens = [];\r\n\t\tfor (var ndx in formatCode) {\r\n\t\t\tif (tokens.indexOf(ndx[0]) === -1) {\r\n\t\t\t\ttokens.push(ndx[0]);\r\n\t\t\t}\r\n\t\t}\r\n\t\topts.tokenizer = \"(\" + tokens.join(\"+|\") + \")+?|.\";\r\n\t\topts.tokenizer = new RegExp(opts.tokenizer, \"g\");\r\n\t}\r\n\r\n\treturn opts.tokenizer;\r\n}\r\n\r\nfunction isValidDate(dateParts, currentResult) {\r\n\treturn !isFinite(dateParts.rawday)\r\n\t|| (dateParts.day == \"29\" && !isFinite(dateParts.rawyear))\r\n\t|| new Date(dateParts.date.getFullYear(), isFinite(dateParts.rawmonth) ? dateParts.month : dateParts.date.getMonth() + 1, 0).getDate() >= dateParts.day\r\n\t\t? currentResult\r\n\t\t: false; //take corrective action if possible\r\n}\r\n\r\nfunction isDateInRange(dateParts, opts) {\r\n\tvar result = true;\r\n\tif (opts.min) {\r\n\t\tif (dateParts[\"rawyear\"]) {\r\n\t\t\tvar rawYear = dateParts[\"rawyear\"].replace(/[^0-9]/g, \"\"),\r\n\t\t\t\tminYear = opts.min.year.substr(0, rawYear.length);\r\n\t\t\tresult = minYear <= rawYear;\r\n\t\t}\r\n\t\tif (dateParts[\"year\"] === dateParts[\"rawyear\"]) {\r\n\t\t\tif (opts.min.date.getTime() === opts.min.date.getTime()) {\r\n\t\t\t\tresult = opts.min.date.getTime() <= dateParts.date.getTime();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (result && opts.max && opts.max.date.getTime() === opts.max.date.getTime()) {\r\n\t\tresult = opts.max.date.getTime() >= dateParts.date.getTime();\r\n\t}\r\n\treturn result;\r\n}\r\n\r\n//parse the given format and return a mask pattern\r\n//when a dateObjValue is passed a datestring in the requested format is returned\r\nfunction parse(format, dateObjValue, opts, raw) {\r\n\t//parse format to regex string\r\n\tvar mask = \"\", match;\r\n\twhile ((match = getTokenizer(opts).exec(format))) {\r\n\t\tif (dateObjValue === undefined) {\r\n\t\t\tif (formatCode[match[0]]) {\r\n\t\t\t\tmask += \"(\" + formatCode[match[0]][0] + \")\";\r\n\t\t\t} else {\r\n\t\t\t\tswitch (match[0]) {\r\n\t\t\t\t\tcase \"[\":\r\n\t\t\t\t\t\tmask += \"(\";\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"]\":\r\n\t\t\t\t\t\tmask += \")?\";\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tmask += Inputmask.escapeRegex(match[0]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (formatCode[match[0]]) {\r\n\t\t\t\tif (raw !== true && formatCode[match[0]][3]) {\r\n\t\t\t\t\tvar getFn = formatCode[match[0]][3];\r\n\t\t\t\t\tmask += getFn.call(dateObjValue.date);\r\n\t\t\t\t} else if (formatCode[match[0]][2]) {\r\n\t\t\t\t\tmask += dateObjValue[\"raw\" + formatCode[match[0]][2]];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tmask += match[0];\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tmask += match[0];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn mask;\r\n}\r\n\r\n//padding function\r\nfunction pad(val, len) {\r\n\tval = String(val);\r\n\tlen = len || 2;\r\n\twhile (val.length < len) val = \"0\" + val;\r\n\treturn val;\r\n}\r\n\r\nfunction analyseMask(maskString, format, opts) {\r\n\tvar dateObj = {\"date\": new Date(1, 0, 1)}, targetProp, mask = maskString, match, dateOperation;\r\n\r\n\tfunction extendProperty(value) {\r\n\t\tvar correctedValue = value.replace(/[^0-9]/g, \"0\");\r\n\t\t// if (correctedValue != value) { //only do correction on incomplete values\r\n\t\t//     //determine best validation match\r\n\t\t//     var enteredPart = value.replace(/[^0-9]/g, \"\"),\r\n\t\t//         enteredPartIndex = value.indexOf(enteredPart),\r\n\t\t//         minPart = (opts.min && opts.min[targetProp] || value).slice(enteredPartIndex, enteredPartIndex + enteredPart.length),\r\n\t\t//         maxPart = (opts.max && opts.max[targetProp] || value).slice(enteredPartIndex, enteredPartIndex + enteredPart.length),\r\n\t\t//         correctedPart = enteredPart < minPart ? minPart : (enteredPart > maxPart ? maxPart : correctedValue.slice(enteredPartIndex, enteredPartIndex + enteredPart.length));\r\n\t\t//     correctedValue = correctedValue.split(\"\");\r\n\t\t//     correctedValue.splice(enteredPartIndex, 1, correctedPart);\r\n\t\t//     correctedValue = correctedValue.join(\"\");\r\n\t\t// }\r\n\t\treturn correctedValue;\r\n\t}\r\n\r\n\tfunction setValue(dateObj, value, opts) {\r\n\t\tdateObj[targetProp] = extendProperty(value);\r\n\t\tdateObj[\"raw\" + targetProp] = value;\r\n\r\n\t\tif (dateOperation !== undefined) {\r\n\t\t\tdateOperation.call(dateObj.date, targetProp == \"month\" ? parseInt(dateObj[targetProp]) - 1 : dateObj[targetProp]);\r\n\t\t}\r\n\t}\r\n\r\n\tif (typeof mask === \"string\") {\r\n\t\twhile ((match = getTokenizer(opts).exec(format))) {\r\n\t\t\tvar value = mask.slice(0, match[0].length);\r\n\t\t\tif (formatCode.hasOwnProperty(match[0])) {\r\n\t\t\t\t// targetValidator = formatCode[match[0]][0];\r\n\t\t\t\ttargetProp = formatCode[match[0]][2];\r\n\t\t\t\tdateOperation = formatCode[match[0]][1];\r\n\t\t\t\tsetValue(dateObj, value, opts);\r\n\t\t\t}\r\n\t\t\tmask = mask.slice(value.length);\r\n\t\t}\r\n\r\n\t\treturn dateObj;\r\n\t} else if (mask && typeof mask === \"object\" && mask.hasOwnProperty(\"date\")) {\r\n\t\treturn mask;\r\n\t}\r\n\treturn undefined;\r\n}\r\n\r\nInputmask.extendAliases({\r\n\t\"datetime\": {\r\n\t\tmask: function (opts) {\r\n\t\t\t//localize\r\n\t\t\tformatCode.S = opts.i18n.ordinalSuffix.join(\"|\");\r\n\r\n\t\t\topts.inputFormat = formatAlias[opts.inputFormat] || opts.inputFormat; //resolve possible formatAlias\r\n\t\t\topts.displayFormat = formatAlias[opts.displayFormat] || opts.displayFormat || opts.inputFormat; //resolve possible formatAlias\r\n\t\t\topts.outputFormat = formatAlias[opts.outputFormat] || opts.outputFormat || opts.inputFormat; //resolve possible formatAlias\r\n\t\t\topts.placeholder = opts.placeholder !== \"\" ? opts.placeholder : opts.inputFormat.replace(/[[\\]]/, \"\");\r\n\t\t\topts.regex = parse(opts.inputFormat, undefined, opts);\r\n\t\t\t// console.log(opts.regex);\r\n\t\t\treturn null; //migrate to regex mask\r\n\t\t},\r\n\t\tplaceholder: \"\", //set default as none (~ auto); when a custom placeholder is passed it will be used\r\n\t\tinputFormat: \"isoDateTime\", //format used to input the date\r\n\t\tdisplayFormat: undefined, //visual format when the input looses focus\r\n\t\toutputFormat: undefined, //unmasking format\r\n\t\tmin: null, //needs to be in the same format as the inputfornat\r\n\t\tmax: null, //needs to be in the same format as the inputfornat,\r\n\t\t// Internationalization strings\r\n\t\ti18n: {\r\n\t\t\tdayNames: [\r\n\t\t\t\t\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\",\r\n\t\t\t\t\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"\r\n\t\t\t],\r\n\t\t\tmonthNames: [\r\n\t\t\t\t\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\",\r\n\t\t\t\t\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"\r\n\t\t\t],\r\n\t\t\tordinalSuffix: [\"st\", \"nd\", \"rd\", \"th\"]\r\n\t\t},\r\n\t\tpreValidation: function (buffer, pos, c, isSelection, opts, maskset) {\r\n\t\t\tvar calcPos = 0, targetMatch, match;\r\n\t\t\tif (isNaN(c) && buffer[pos] !== c) {\r\n\t\t\t\twhile ((match = getTokenizer(opts).exec(opts.inputFormat))) {\r\n\t\t\t\t\tcalcPos += match[0].length;\r\n\t\t\t\t\tif (calcPos >= pos) {\r\n\t\t\t\t\t\ttargetMatch = match;\r\n\t\t\t\t\t\tmatch = getTokenizer(opts).exec(opts.inputFormat);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (match && match[0] === c && targetMatch[0].length > 1) {\r\n\t\t\t\t\tbuffer[pos] = buffer[pos - 1];\r\n\t\t\t\t\tbuffer[pos - 1] = \"0\";\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tfuzzy: true,\r\n\t\t\t\t\t\tbuffer: buffer,\r\n\t\t\t\t\t\trefreshFromBuffer: {start: pos - 1, end: pos + 1},\r\n\t\t\t\t\t\tpos: pos + 1\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t},\r\n\t\tpostValidation: function (buffer, pos, currentResult, opts) {\r\n\t\t\topts.min = analyseMask(opts.min, opts.inputFormat, opts);\r\n\t\t\topts.max = analyseMask(opts.max, opts.inputFormat, opts);\r\n\r\n\t\t\tif (currentResult.fuzzy) {\r\n\t\t\t\tbuffer = currentResult.buffer;\r\n\t\t\t\tpos = currentResult.pos;\r\n\t\t\t}\r\n\r\n\t\t\tvar result = currentResult, dateParts = analyseMask(buffer.join(\"\"), opts.inputFormat, opts);\r\n\t\t\tif (result && dateParts.date.getTime() === dateParts.date.getTime()) { //check for a valid date ~ an invalid date returns NaN which isn't equal\r\n\t\t\t\tresult = isValidDate(dateParts, result);\r\n\t\t\t\tresult = result && isDateInRange(dateParts, opts);\r\n\t\t\t}\r\n\r\n\t\t\tif (pos && result && currentResult.pos !== pos) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tbuffer: parse(opts.inputFormat, dateParts, opts),\r\n\t\t\t\t\trefreshFromBuffer: {start: pos, end: currentResult.pos}\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\t\t},\r\n\t\tonKeyDown: function (e, buffer, caretPos, opts) {\r\n\t\t\tvar input = this;\r\n\t\t\tif (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {\r\n\t\t\t\tvar today = new Date(), match, date = \"\";\r\n\r\n\t\t\t\twhile ((match = getTokenizer(opts).exec(opts.inputFormat))) {\r\n\t\t\t\t\tif (match[0].charAt(0) === \"d\") {\r\n\t\t\t\t\t\tdate += pad(today.getDate(), match[0].length);\r\n\t\t\t\t\t} else if (match[0].charAt(0) === \"m\") {\r\n\t\t\t\t\t\tdate += pad((today.getMonth() + 1), match[0].length);\r\n\t\t\t\t\t} else if (match[0] === \"yyyy\") {\r\n\t\t\t\t\t\tdate += today.getFullYear().toString();\r\n\t\t\t\t\t} else if (match[0].charAt(0) === \"y\") {\r\n\t\t\t\t\t\tdate += pad(today.getYear(), match[0].length);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tinput.inputmask._valueSet(date);\r\n\t\t\t\t$(input).trigger(\"setvalue\");\r\n\t\t\t}\r\n\t\t},\r\n\t\tonUnMask: function (maskedValue, unmaskedValue, opts) {\r\n\t\t\treturn unmaskedValue ? parse(opts.outputFormat, analyseMask(maskedValue, opts.inputFormat, opts), opts, true) : unmaskedValue;\r\n\t\t},\r\n\t\tcasing: function (elem, test, pos, validPositions) {\r\n\t\t\tif (test.nativeDef.indexOf(\"[ap]\") == 0) return elem.toLowerCase();\r\n\t\t\tif (test.nativeDef.indexOf(\"[AP]\") == 0) return elem.toUpperCase();\r\n\t\t\treturn elem;\r\n\t\t},\r\n\t\tinsertMode: false,\r\n\t\tshiftPositions: false\r\n\t}\r\n});\r\n\r\nmodule.exports = Inputmask;\r\n","/*\r\n Input Mask plugin extensions\r\n http://github.com/RobinHerbots/jquery.inputmask\r\n Copyright (c) Robin Herbots\r\n Licensed under the MIT license\r\n */\r\nvar Inputmask = require(\"../inputmask\"), $ = Inputmask.dependencyLib;\r\n\r\nfunction autoEscape(txt, opts) {\r\n\tvar escapedTxt = \"\";\r\n\tfor (var i = 0; i < txt.length; i++) {\r\n\t\tif (Inputmask.prototype.definitions[txt.charAt(i)] ||\r\n\t\t\topts.definitions[txt.charAt(i)] ||\r\n\t\t\topts.optionalmarker.start === txt.charAt(i) ||\r\n\t\t\topts.optionalmarker.end === txt.charAt(i) ||\r\n\t\t\topts.quantifiermarker.start === txt.charAt(i) ||\r\n\t\t\topts.quantifiermarker.end === txt.charAt(i) ||\r\n\t\t\topts.groupmarker.start === txt.charAt(i) ||\r\n\t\t\topts.groupmarker.end === txt.charAt(i) ||\r\n\t\t\topts.alternatormarker === txt.charAt(i)) {\r\n\t\t\tescapedTxt += \"\\\\\" + txt.charAt(i);\r\n\t\t} else {\r\n\t\t\tescapedTxt += txt.charAt(i);\r\n\t\t}\r\n\t}\r\n\treturn escapedTxt;\r\n}\r\n\r\nfunction alignDigits(buffer, digits, opts) {\r\n\tif (digits > 0 && !opts.digitsOptional && buffer.length > 0) {\r\n\t\tvar radixPosition = $.inArray(opts.radixPoint, buffer);\r\n\t\tif (radixPosition === -1) {\r\n\t\t\tbuffer.push(opts.radixPoint);\r\n\t\t\tradixPosition = buffer.length - 1;\r\n\t\t}\r\n\t\tfor (var i = 1; i <= digits; i++) {\r\n\t\t\tbuffer[radixPosition + i] = buffer[radixPosition + i] || \"0\";\r\n\t\t}\r\n\t}\r\n\treturn buffer;\r\n}\r\n\r\nfunction findValidator(symbol, maskset) {\r\n\tvar posNdx = 0;\r\n\tfor (posNdx in maskset.validPositions) ;\r\n\tposNdx = parseInt(posNdx);\r\n\tfor (var tstNdx in maskset.tests) {\r\n\t\ttstNdx = parseInt(tstNdx);\r\n\t\tif (tstNdx >= posNdx) {\r\n\t\t\tfor (var ndx = 0, ndxl = maskset.tests[tstNdx].length; ndx < ndxl; ndx++) {\r\n\t\t\t\tif (maskset.validPositions[tstNdx] === undefined && maskset.tests[tstNdx][ndx].match.def === symbol) {\r\n\t\t\t\t\treturn tstNdx + (maskset.validPositions[tstNdx] !== undefined ? 1 : 0);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn posNdx;\r\n}\r\n\r\nfunction findValid(symbol, maskset) {\r\n\tvar ret = -1;\r\n\t$.each(maskset.validPositions, function (ndx, tst) {\r\n\t\tif (tst.match.def === symbol) {\r\n\t\t\tret = parseInt(ndx);\r\n\t\t\treturn false;\r\n\t\t}\r\n\t});\r\n\treturn ret;\r\n}\r\n\r\nfunction parseMinMaxOptions(opts) {\r\n\tif (opts.parseMinMaxOptions === undefined) {\r\n\t\t// convert min and max options\r\n\t\tif (opts.min !== null) {\r\n\t\t\topts.min = opts.min.toString().replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), \"g\"), \"\");\r\n\t\t\tif (opts.radixPoint === \",\") opts.min = opts.min.replace(opts.radixPoint, \".\");\r\n\t\t\topts.min = isFinite(opts.min) ? parseFloat(opts.min) : NaN;\r\n\t\t\tif (isNaN(opts.min)) opts.min = Number.MIN_VALUE;\r\n\t\t}\r\n\t\tif (opts.max !== null) {\r\n\t\t\topts.max = opts.max.toString().replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), \"g\"), \"\");\r\n\t\t\tif (opts.radixPoint === \",\") opts.max = opts.max.replace(opts.radixPoint, \".\");\r\n\t\t\topts.max = isFinite(opts.max) ? parseFloat(opts.max) : NaN;\r\n\t\t\tif (isNaN(opts.max)) opts.max = Number.MAX_VALUE;\r\n\t\t}\r\n\t\topts.parseMinMaxOptions = \"done\";\r\n\t}\r\n}\r\n\r\nfunction genMask(opts) {\r\n\topts.repeat = 0;\r\n\t//treat equal separator and radixpoint\r\n\tif (opts.groupSeparator === opts.radixPoint && opts.digits && opts.digits !== \"0\") {\r\n\t\tif (opts.radixPoint === \".\") {\r\n\t\t\topts.groupSeparator = \",\";\r\n\t\t} else if (opts.radixPoint === \",\") {\r\n\t\t\topts.groupSeparator = \".\";\r\n\t\t} else {\r\n\t\t\topts.groupSeparator = \"\";\r\n\t\t}\r\n\t}\r\n\t//prevent conflict with default skipOptionalPartCharacter\r\n\tif (opts.groupSeparator === \" \") {\r\n\t\topts.skipOptionalPartCharacter = undefined;\r\n\t}\r\n\r\n\t//enforce placeholder to single\r\n\tif (opts.placeholder.length > 1) {\r\n\t\topts.placeholder = opts.placeholder.charAt(0);\r\n\t}\r\n\t//only allow radixfocus when placeholder = 0\r\n\tif (opts.positionCaretOnClick === \"radixFocus\" && opts.placeholder === \"\") {\r\n\t\topts.positionCaretOnClick = \"lvp\";\r\n\t}\r\n\r\n\tvar decimalDef = \"0\";\r\n\tif (opts.numericInput === true && opts.__financeInput === undefined) { //finance people input style\r\n\t\tdecimalDef = \"1\";\r\n\t\topts.positionCaretOnClick = opts.positionCaretOnClick === \"radixFocus\" ? \"lvp\" : opts.positionCaretOnClick;\r\n\t\t// opts.digitsOptional = false;\r\n\t\tif (isNaN(opts.digits)) opts.digits = 2;\r\n\t\topts._radixDance = false;\r\n\t} else {\r\n\t\topts.__financeInput = false; //needed to keep original selection when remasking\r\n\t\topts.numericInput = true;\r\n\t}\r\n\r\n\tvar mask = \"[+]\", altMask;\r\n\tmask += autoEscape(opts.prefix, opts);\r\n\tif (opts.groupSeparator !== \"\") {\r\n\t\tmask += opts._mask(opts);\r\n\t} else {\r\n\t\tmask += \"9{+}\";\r\n\t}\r\n\tif (opts.digits !== undefined) {\r\n\t\tvar dq = opts.digits.toString().split(\",\");\r\n\t\tif (isFinite(dq[0]) && dq[1] && isFinite(dq[1])) {\r\n\t\t\tmask += opts.radixPoint + decimalDef + \"{\" + opts.digits + \"}\";\r\n\t\t} else if (isNaN(opts.digits) || parseInt(opts.digits) > 0) {\r\n\t\t\tif (opts.digitsOptional) {\r\n\t\t\t\taltMask = mask + opts.radixPoint + decimalDef + \"{0,\" + opts.digits + \"}\";\r\n\t\t\t\t// mask += \"[\" + opts.radixPoint + \"]\";\r\n\t\t\t\topts.keepStatic = true;\r\n\t\t\t} else {\r\n\t\t\t\tmask += opts.radixPoint + decimalDef + \"{\" + opts.digits + \"}\";\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tmask += autoEscape(opts.suffix, opts);\r\n\tmask += \"[-]\";\r\n\r\n\tif (altMask) {\r\n\t\tmask = [(altMask + autoEscape(opts.suffix, opts) + \"[-]\"), mask];\r\n\t}\r\n\r\n\r\n\topts.greedy = false; //enforce greedy false\r\n\r\n\tparseMinMaxOptions(opts);\r\n\treturn mask;\r\n}\r\n\r\nfunction hanndleRadixDance(pos, c, radixPos, opts) {\r\n\tif (opts._radixDance && opts.numericInput) {\r\n\t\tif (pos <= radixPos && (radixPos > 0 || c == opts.radixPoint)) {\r\n\t\t\tpos -= 1;\r\n\t\t}\r\n\t}\r\n\treturn pos;\r\n}\r\n\r\nfunction decimalValidator(chrs, maskset, pos, strict, opts) {\r\n\tvar radixPos = maskset.buffer.indexOf(opts.radixPoint),\r\n\t\tresult = radixPos !== -1 && new RegExp(\"[0-9\\uFF11-\\uFF19]\").test(chrs);\r\n\tif (opts._radixDance && result && maskset.validPositions[radixPos] == undefined) {\r\n\t\treturn {\r\n\t\t\tinsert: {\r\n\t\t\t\tpos: radixPos === pos ? radixPos + 1 : radixPos,\r\n\t\t\t\tc: opts.radixPoint\r\n\t\t\t},\r\n\t\t\tpos: pos\r\n\t\t};\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\n//number aliases\r\nInputmask.extendAliases({\r\n\t\"numeric\": {\r\n\t\tmask: genMask,\r\n\t\t_mask: function (opts) {\r\n\t\t\treturn \"(\" + opts.groupSeparator + \"999){+|1}\";\r\n\t\t},\r\n\t\tplaceholder: \"0\",\r\n\t\tgreedy: false,\r\n\t\tdigits: \"*\", //number of fractionalDigits\r\n\t\tdigitsOptional: true,\r\n\t\tenforceDigitsOnBlur: false,\r\n\t\tradixPoint: \".\",\r\n\t\tpositionCaretOnClick: \"radixFocus\",\r\n\t\t_radixDance: true,\r\n\t\tgroupSeparator: \"\",\r\n\t\tallowMinus: true,\r\n\t\tnegationSymbol: {\r\n\t\t\tfront: \"-\", //\"(\"\r\n\t\t\tback: \"\" //\")\"\r\n\t\t},\r\n\t\tprefix: \"\",\r\n\t\tsuffix: \"\",\r\n\t\trightAlign: true,\r\n\t\tmin: null, //minimum value\r\n\t\tmax: null, //maximum value\r\n\t\tstep: 1,\r\n\t\tinsertMode: true,\r\n\t\tautoUnmask: false,\r\n\t\tunmaskAsNumber: false,\r\n\t\tinputmode: \"numeric\",\r\n\t\tdefinitions: {\r\n\t\t\t\"0\": {\r\n\t\t\t\tvalidator: decimalValidator\r\n\t\t\t},\r\n\t\t\t\"1\": {\r\n\t\t\t\tvalidator: decimalValidator,\r\n\t\t\t\tdefinitionSymbol: \"*\"\r\n\t\t\t},\r\n\t\t\t\"+\": {\r\n\t\t\t\tvalidator: function (chrs, maskset, pos, strict, opts) {\r\n\t\t\t\t\treturn (opts.allowMinus && (chrs === \"-\" || chrs === opts.negationSymbol.front));\r\n\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t\"-\": {\r\n\t\t\t\tvalidator: function (chrs, maskset, pos, strict, opts) {\r\n\t\t\t\t\treturn (opts.allowMinus && chrs === opts.negationSymbol.back);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tpreValidation: function (buffer, pos, c, isSelection, opts, maskset) {\r\n\t\t\tvar radixPos = $.inArray(opts.radixPoint, buffer);\r\n\t\t\tpos = hanndleRadixDance(pos, c, radixPos, opts);\r\n\t\t\tif (c === \"-\" || c === opts.negationSymbol.front) {\r\n\t\t\t\tif (opts.allowMinus !== true) return false;\r\n\t\t\t\tvar isNegative = false,\r\n\t\t\t\t\tfront = findValid(\"+\", maskset), back = findValid(\"-\", maskset);\r\n\t\t\t\tif (front !== -1) {\r\n\t\t\t\t\tisNegative = [front, back];\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn isNegative !== false ? {\r\n\t\t\t\t\tremove: isNegative,\r\n\t\t\t\t\tcaret: radixPos > pos ? pos + 1 : pos\r\n\t\t\t\t} : {\r\n\t\t\t\t\tinsert: [\r\n\t\t\t\t\t\t{pos: findValidator(\"+\", maskset), c: opts.negationSymbol.front, fromIsValid: true},\r\n\t\t\t\t\t\t{pos: findValidator(\"-\", maskset), c: opts.negationSymbol.back, fromIsValid: true}],\r\n\t\t\t\t\tcaret: radixPos > pos ? pos + 1 : pos\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t\tif (radixPos !== -1 && (opts._radixDance === true && isSelection === false && c === opts.radixPoint && (opts.digits !== undefined && (isNaN(opts.digits) || parseInt(opts.digits) > 0)) && radixPos !== pos)) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\t\"caret\": opts._radixDance && pos === radixPos - 1 ? radixPos + 1 : radixPos\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\treturn {rewritePosition: pos};\r\n\t\t},\r\n\t\tpostValidation: function (buffer, pos, currentResult, opts) {\r\n\t\t\tif (opts.min !== null || opts.max !== null) {\r\n\t\t\t\tvar unmasked = opts.onUnMask(buffer.slice().reverse().join(\"\"), undefined, $.extend({}, opts, {\r\n\t\t\t\t\tunmaskAsNumber: true\r\n\t\t\t\t}));\r\n\t\t\t\tif (opts.min !== null && unmasked < opts.min && unmasked.toString().length >= opts.min.toString().length) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\tif (opts.max !== null && unmasked > opts.max) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn currentResult;\r\n\t\t},\r\n\t\tonUnMask: function (maskedValue, unmaskedValue, opts) {\r\n\t\t\tif (unmaskedValue === \"\" && opts.nullable === true) {\r\n\t\t\t\treturn unmaskedValue;\r\n\t\t\t}\r\n\t\t\tvar processValue = maskedValue.replace(opts.prefix, \"\");\r\n\t\t\tprocessValue = processValue.replace(opts.suffix, \"\");\r\n\t\t\tprocessValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), \"g\"), \"\");\r\n\t\t\tif (opts.placeholder.charAt(0) !== \"\") {\r\n\t\t\t\tprocessValue = processValue.replace(new RegExp(opts.placeholder.charAt(0), \"g\"), \"0\");\r\n\t\t\t}\r\n\t\t\tif (opts.unmaskAsNumber) {\r\n\t\t\t\tif (opts.radixPoint !== \"\" && processValue.indexOf(opts.radixPoint) !== -1) processValue = processValue.replace(Inputmask.escapeRegex.call(this, opts.radixPoint), \".\");\r\n\t\t\t\tprocessValue = processValue.replace(new RegExp(\"^\" + Inputmask.escapeRegex(opts.negationSymbol.front)), \"-\");\r\n\t\t\t\tprocessValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + \"$\"), \"\");\r\n\t\t\t\treturn Number(processValue);\r\n\t\t\t}\r\n\t\t\treturn processValue;\r\n\t\t},\r\n\t\tisComplete: function (buffer, opts) {\r\n\t\t\tvar maskedValue = (opts.numericInput ? buffer.slice().reverse() : buffer).join(\"\");\r\n\t\t\tmaskedValue = maskedValue.replace(new RegExp(\"^\" + Inputmask.escapeRegex(opts.negationSymbol.front)), \"-\");\r\n\t\t\tmaskedValue = maskedValue.replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + \"$\"), \"\");\r\n\t\t\tmaskedValue = maskedValue.replace(opts.prefix, \"\");\r\n\t\t\tmaskedValue = maskedValue.replace(opts.suffix, \"\");\r\n\t\t\tmaskedValue = maskedValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator) + \"([0-9]{3})\", \"g\"), \"$1\");\r\n\t\t\tif (opts.radixPoint === \",\") maskedValue = maskedValue.replace(Inputmask.escapeRegex(opts.radixPoint), \".\");\r\n\t\t\treturn isFinite(maskedValue);\r\n\t\t},\r\n\t\tonBeforeMask: function (initialValue, opts) {\r\n\t\t\tvar radixPoint = opts.radixPoint || \",\";\r\n\r\n\t\t\tif ((typeof initialValue == \"number\" || opts.inputType === \"number\") && radixPoint !== \"\") {\r\n\t\t\t\tinitialValue = initialValue.toString().replace(\".\", radixPoint);\r\n\t\t\t}\r\n\r\n\t\t\tvar valueParts = initialValue.split(radixPoint),\r\n\t\t\t\tintegerPart = valueParts[0].replace(/[^\\-0-9]/g, \"\"),\r\n\t\t\t\tdecimalPart = valueParts.length > 1 ? valueParts[1].replace(/[^0-9]/g, \"\") : \"\";\r\n\r\n\t\t\tinitialValue = integerPart + (decimalPart !== \"\" ? radixPoint + decimalPart : decimalPart);\r\n\r\n\t\t\tvar digits = 0;\r\n\t\t\tif (radixPoint !== \"\") {\r\n\t\t\t\tdigits = decimalPart.length;\r\n\t\t\t\tif (decimalPart !== \"\") {\r\n\t\t\t\t\tvar digitsFactor = Math.pow(10, digits || 1);\r\n\t\t\t\t\tif (isFinite(opts.digits)) {\r\n\t\t\t\t\t\tdigits = parseInt(opts.digits);\r\n\t\t\t\t\t\tdigitsFactor = Math.pow(10, digits);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t//make the initialValue a valid javascript number for the parsefloat\r\n\t\t\t\t\tinitialValue = initialValue.replace(Inputmask.escapeRegex(radixPoint), \".\");\r\n\t\t\t\t\tif (isFinite(initialValue)) {\r\n\t\t\t\t\t\tinitialValue = Math.round(parseFloat(initialValue) * digitsFactor) / digitsFactor;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tinitialValue = initialValue.toString().replace(\".\", radixPoint);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t//this needs to be in a separate part and not directly in decimalPart to allow rounding\r\n\t\t\tif (opts.digits === 0 && initialValue.indexOf(Inputmask.escapeRegex(radixPoint)) !== -1) {\r\n\t\t\t\tinitialValue = initialValue.substring(0, initialValue.indexOf(Inputmask.escapeRegex(radixPoint)));\r\n\t\t\t}\r\n\t\t\treturn alignDigits(initialValue.toString().split(\"\"), digits, opts).join(\"\");\r\n\t\t},\r\n\t\tonBeforeWrite: function (e, buffer, caretPos, opts) {\r\n\t\t\tvar result;\r\n\t\t\t//check leading zeros\r\n\t\t\tvar numberMatches = new RegExp(\"^\" + (opts.negationSymbol.front != \"\" ? Inputmask.escapeRegex(opts.negationSymbol.front) + \"?\" : \"\") + Inputmask.escapeRegex(opts.prefix) + \"(?<number>.*)\" + Inputmask.escapeRegex(opts.suffix) + (opts.negationSymbol.back != \"\" ? Inputmask.escapeRegex(opts.negationSymbol.back) + \"?\" : \"\") + \"$\").exec(buffer.slice().reverse().join(\"\")),\r\n\t\t\t\tnumber = numberMatches ? numberMatches.groups.number : \"\";\r\n\t\t\tif (number) {\r\n\t\t\t\tnumber = number.split(opts.radixPoint.charAt(0))[0];\r\n\r\n\t\t\t\tvar leadingzeroes = new RegExp(\"^[0\" + opts.groupSeparator + \"]*\").exec(number);\r\n\r\n\t\t\t\tif (leadingzeroes[0].length > 1 || leadingzeroes[0].length > 0 && leadingzeroes[0].length < number.length) {\r\n\t\t\t\t\tvar buf = buffer.slice().reverse(), caretNdx = buf.join(\"\").indexOf(leadingzeroes[0]);\r\n\t\t\t\t\tbuf.splice(caretNdx, leadingzeroes[0].length);\r\n\t\t\t\t\tvar newCaretPos = buf.length - caretNdx;\r\n\t\t\t\t\tresult = {\r\n\t\t\t\t\t\trefreshFromBuffer: true,\r\n\t\t\t\t\t\tbuffer: buf.reverse(),\r\n\t\t\t\t\t\tcaret: caretPos < newCaretPos ? caretPos : newCaretPos\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\r\n\t\t\tif (e) {\r\n\t\t\t\tswitch (e.type) {\r\n\t\t\t\t\tcase \"blur\":\r\n\t\t\t\t\tcase \"checkval\":\r\n\t\t\t\t\t\tif (opts.radixPoint !== \"\" && buffer[0] === opts.radixPoint) {\r\n\t\t\t\t\t\t\tif (result && result.buffer) {\r\n\t\t\t\t\t\t\t\tresult.buffer.shift();\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tbuffer.shift();\r\n\t\t\t\t\t\t\t\tresult =\r\n\t\t\t\t\t\t\t\t\t{refreshFromBuffer: true, buffer: buffer};\r\n\t\t\t\t\t\t\t\t;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result;\r\n\t\t},\r\n\t\tonKeyDown: function (e, buffer, caretPos, opts) {\r\n\t\t\tvar $input = $(this);\r\n\t\t\tif (e.ctrlKey) {\r\n\t\t\t\tswitch (e.keyCode) {\r\n\t\t\t\t\tcase Inputmask.keyCode.UP:\r\n\t\t\t\t\t\tthis.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) + parseInt(opts.step));\r\n\t\t\t\t\t\t$input.trigger(\"setvalue\");\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\tcase Inputmask.keyCode.DOWN:\r\n\t\t\t\t\t\tthis.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) - parseInt(opts.step));\r\n\t\t\t\t\t\t$input.trigger(\"setvalue\");\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (e.keyCode === Inputmask.keyCode.DELETE || e.keyCode === Inputmask.keyCode.BACKSPACE || e.keyCode === Inputmask.keyCode.BACKSPACE_SAFARI) {\r\n\t\t\t\tif (opts._radixDance === true && !opts.digitsOptional) {\r\n\t\t\t\t\tvar radixPos = $.inArray(opts.radixPoint, buffer);\r\n\t\t\t\t\tif (radixPos !== -1 && (caretPos < radixPos || (e.keyCode === Inputmask.keyCode.DELETE && caretPos === radixPos))) {\r\n\t\t\t\t\t\tif (e.keyCode === Inputmask.keyCode.BACKSPACE || e.keyCode === Inputmask.keyCode.BACKSPACE_SAFARI) {\r\n\t\t\t\t\t\t\tcaretPos++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar bffr = buffer.slice().reverse();\r\n\t\t\t\t\t\tbffr.splice(bffr.length - caretPos, 1);\r\n\t\t\t\t\t\t$input.trigger(\"setvalue\", [alignDigits(bffr, opts.digits, opts).join(\"\"), caretPos]);\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\t\"currency\": {\r\n\t\tprefix: \"$ \",\r\n\t\tgroupSeparator: \",\",\r\n\t\talias: \"numeric\",\r\n\t\tplaceholder: \"0\",\r\n\t\tdigits: 2,\r\n\t\tdigitsOptional: false\r\n\t},\r\n\t\"decimal\": {\r\n\t\talias: \"numeric\"\r\n\t},\r\n\t\"integer\": {\r\n\t\talias: \"numeric\",\r\n\t\tdigits: 0\r\n\t},\r\n\t\"percentage\": {\r\n\t\talias: \"integer\",\r\n\t\tmin: 0,\r\n\t\tmax: 100,\r\n\t\tsuffix: \" %\",\r\n\t\tallowMinus: false\r\n\t},\r\n\t\"indianns\": { //indian numbering system\r\n\t\talias: \"numeric\",\r\n\t\t_mask: function (opts) {\r\n\t\t\treturn \"(\" + opts.groupSeparator + \"99){*|1}(\" + opts.groupSeparator + \"999){1|1}\";\r\n\t\t},\r\n\t\tgroupSeparator: \",\",\r\n\t\tradixPoint: \".\",\r\n\t\tplaceholder: \"0\",\r\n\t\tdigits: 2,\r\n\t\tdigitsOptional: false\r\n\t}\r\n});\r\nmodule.exports = Inputmask;\r\n","/*\r\n * Input Mask plugin for jquery\r\n * http://github.com/RobinHerbots/jquery.inputmask\r\n * Copyright (c) Robin Herbots\r\n * Licensed under the MIT license\r\n */\r\nvar $ = require(\"jquery\"), Inputmask = require(\"./inputmask\");\r\nif ($.fn.inputmask === undefined) {\r\n\t//jquery plugin\r\n\t$.fn.inputmask = function (fn, options) {\r\n\t\tvar nptmask, input = this[0];\r\n\t\tif (options === undefined) options = {};\r\n\t\tif (typeof fn === \"string\") {\r\n\t\t\tswitch (fn) {\r\n\t\t\t\tcase \"unmaskedvalue\":\r\n\t\t\t\t\treturn input && input.inputmask ? input.inputmask.unmaskedvalue() : $(input).val();\r\n\t\t\t\tcase \"remove\":\r\n\t\t\t\t\treturn this.each(function () {\r\n\t\t\t\t\t\tif (this.inputmask) this.inputmask.remove();\r\n\t\t\t\t\t});\r\n\t\t\t\tcase \"getemptymask\":\r\n\t\t\t\t\treturn input && input.inputmask ? input.inputmask.getemptymask() : \"\";\r\n\t\t\t\tcase \"hasMaskedValue\": //check whether the returned value is masked or not; currently only works reliable when using jquery.val fn to retrieve the value\r\n\t\t\t\t\treturn input && input.inputmask ? input.inputmask.hasMaskedValue() : false;\r\n\t\t\t\tcase \"isComplete\":\r\n\t\t\t\t\treturn input && input.inputmask ? input.inputmask.isComplete() : true;\r\n\t\t\t\tcase \"getmetadata\": //return mask metadata if exists\r\n\t\t\t\t\treturn input && input.inputmask ? input.inputmask.getmetadata() : undefined;\r\n\t\t\t\tcase \"setvalue\":\r\n\t\t\t\t\tInputmask.setValue(input, options);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"option\":\r\n\t\t\t\t\tif (typeof options === \"string\") {\r\n\t\t\t\t\t\tif (input && input.inputmask !== undefined) {\r\n\t\t\t\t\t\t\treturn input.inputmask.option(options);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn this.each(function () {\r\n\t\t\t\t\t\t\tif (this.inputmask !== undefined) {\r\n\t\t\t\t\t\t\t\treturn this.inputmask.option(options);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\toptions.alias = fn;\r\n\t\t\t\t\tnptmask = new Inputmask(options);\r\n\t\t\t\t\treturn this.each(function () {\r\n\t\t\t\t\t\tnptmask.mask(this);\r\n\t\t\t\t\t});\r\n\t\t\t}\r\n\t\t} else if (Array.isArray(fn)) {\r\n\t\t\toptions.alias = fn;\r\n\t\t\tnptmask = new Inputmask(options);\r\n\t\t\treturn this.each(function () {\r\n\t\t\t\tnptmask.mask(this);\r\n\t\t\t});\r\n\t\t} else if (typeof fn == \"object\") {\r\n\t\t\tnptmask = new Inputmask(fn);\r\n\t\t\tif (fn.mask === undefined && fn.alias === undefined) {\r\n\t\t\t\treturn this.each(function () {\r\n\t\t\t\t\tif (this.inputmask !== undefined) {\r\n\t\t\t\t\t\treturn this.inputmask.option(fn);\r\n\t\t\t\t\t} else nptmask.mask(this);\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\treturn this.each(function () {\r\n\t\t\t\t\tnptmask.mask(this);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t} else if (fn === undefined) {\r\n\t\t\t//look for data-inputmask atributes\r\n\t\t\treturn this.each(function () {\r\n\t\t\t\tnptmask = new Inputmask(options);\r\n\t\t\t\tnptmask.mask(this);\r\n\t\t\t});\r\n\t\t}\r\n\t};\r\n}\r\n"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n"],"sourceRoot":""}