{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///./bundle.js","webpack:///./lib/extensions/inputmask.extensions.js","webpack:///./lib/inputmask.js","webpack:///./lib/dependencyLibs/inputmask.dependencyLib.js","webpack:///./lib/global/window.js","webpack:///./lib/maskset.js","webpack:///./lib/maskScope.js","webpack:///./lib/extensions/inputmask.date.extensions.js","webpack:///./lib/extensions/inputmask.numeric.extensions.js","webpack:///webpack/bootstrap"],"names":["webpackUniversalModuleDefinition","root","factory","exports","module","define","amd","a","i","window","require","Inputmask","extendDefinitions","A","validator","casing","&","#","extendAliases","cssunit","regex","url","autoUnmask","ip","mask","definitions","chrs","maskset","pos","strict","opts","buffer","RegExp","test","onUnMask","maskedValue","unmaskedValue","inputmode","email","greedy","onBeforePaste","pastedValue","toLowerCase","replace","*","-","mac","vin","V","clearIncomplete","$","document","generateMaskSet","analyseMask","maskScope","alias","options","internal","this","el","undefined","events","refreshValue","isPlainObject","extend","defaults","noMasksCache","userOptions","resolveAlias","isRTL","numericInput","aliasStr","aliasDefinition","prototype","aliases","importAttributeOptions","npt","dataAttribute","importOption","option","optionData","getAttribute","indexOf","importDataAttributes","attrOptions","dataoptions","p","JSON","parse","dir","rightAlign","style","textAlign","removeAttribute","Object","keys","length","placeholder","optionalmarker","quantifiermarker","groupmarker","alternatormarker","escapeChar","oncomplete","noop","onincomplete","oncleared","repeat","removeMaskOnSubmit","clearMaskOnLostFocus","insertMode","onKeyDown","onBeforeMask","isFunction","call","onBeforeWrite","showMaskOnFocus","showMaskOnHover","onKeyValidation","skipOptionalPartCharacter","undoOnEscape","radixPoint","_radixDance","groupSeparator","keepStatic","positionCaretOnTab","tabThrough","supportsInputType","ignorables","isComplete","preValidation","postValidation","staticDefinitionSymbol","jitMasking","nullable","inputEventOnly","noValuePatching","positionCaretOnClick","colorMask","disablePredictiveText","shiftPositions","9","definitionSymbol","masksCache","elems","that","getElementById","querySelectorAll","nodeName","each","ndx","scopedOpts","inputmask","remove","data","action","noremask","_typeof","unmaskedvalue","value","getemptymask","hasMaskedValue","getmetadata","isValid","format","metadata","setValue","trigger","positionColorMask","input","template","left","offsetLeft","extendDefaults","definition","unmask","escapeRegex","str","specials","join","keyCode","BACKSPACE","BACKSPACE_SAFARI","DELETE","DOWN","END","ENTER","ESCAPE","HOME","INSERT","LEFT","PAGE_DOWN","PAGE_UP","RIGHT","SPACE","TAB","UP","X","CONTROL","dependencyLib","list","elem","len","isWindow","obj","isArraylike","ltype","nodeType","isValidElement","Element","DependencyLib","querySelector","eventRegistry","on","handler","addEvent","ev","namespace","addEventListener","attachEvent","push","_events","split","endx","nsEvent","off","removeEvent","removeEventListener","detachEvent","nmsp","splice","resolveNamespace","evts","hndx","hndL","evNdx","offEvents","offEventsL","type","evnt","params","bubbles","cancelable","detail","arguments","createEvent","CustomEvent","e","initCustomEvent","dispatchEvent","createEventObject","eventType","fireEvent","Event","slice","apply","isArray","Array","inArray","arr","valHooks","constructor","hasOwnProperty","name","src","copy","copyIsArray","clone","target","deep","callback","owner","key","__data","event","evt","eval","__webpack_require__","__WEBPACK_AMD_DEFINE_RESULT__","nocache","ms","generateMask","regexMask","masksetDefinition","maskdefKey","repeatStart","reverse","maskToken","validPositions","_buffer","tests","excludes","maskLength","jitOffset","charAt","altMask","msk","pop","tokenizer","regexTokenizer","escaped","currentToken","MaskToken","match","m","openenings","maskTokens","openingToken","currentOpeningToken","alternator","lastMatch","closeRegexGroup","isGroup","isOptional","isQuantifier","isAlternator","matches","openGroup","alternatorGroup","quantifier","min","max","insertTestDefinition","mtoken","element","position","prevMatch","fn","static","optionality","newBlockMarker","def","nativeDef","lmnt","maskdef","verifyGroupMarker","token","nextToken","defaultCase","mndx","reverseTokens","reverseStatic","st","intMatch","parseInt","qt","groupify","groupToken","closeGroup","groupQuantifier","exec","altRegexGroup","mqj","mq","mq0","isNaN","mq1","jit","tmpMatch","subToken","ua","navigator","userAgent","ie","mobile","isInputEventSupported","iemobile","iphone","eventName","createElement","evName","isSupported","setAttribute","actionObj","undoValue","$el","skipKeyPressEvent","skipInputEvent","ignorable","maxLength","mouseEnter","originalPlaceholder","focusDelay","getMaskTemplate","baseOnInput","minimalPos","includeMode","noJit","clearOptionalTail","maskTemplate","ndxIntlzr","testPos","generatedInput","determineTestTemplate","getTests","locator","getPlaceholder","getTestTemplate","isFinite","resetMaskSet","soft","getLastValidPosition","closestTo","before","after","valids","posNdx","psNdx","getDecisionTaker","tst","decisionTaker","alternation","toString","getLocator","align","mloc","altTest","getTest","targetLocator","tstLocator","closest","bestMatch","distance","Math","abs","optionalQuantifier","tstPs","positionCanMatchDefinition","valid","tndx","ndxInitializer","insertStop","latestMatch","cacheDependency","resolveTestFromToken","loopNdx","quantifierRecurse","handleMatch","isFirstMatch","tokenGroup","firstMatch","resolveNdxInitializer","alternateNdx","targetAlternation","indexPos","ndxPos","bestMatchAltIndex","isSubsetOf","source","expand","pattern","expanded","start","end","l","charCodeAt","String","fromCharCode","staticCanMatchDefinition","sloc","tloc","canMatch","setMergeLocators","targetMatch","altMatch","locNdx","cd","optionalToken","mtchsNdx","mtch","alternateToken","malternateMatches","maltMatches","currentMatches","loopNdxCnt","altIndex","shift","currentPos","ndxInitializerClone","altIndexArr","amndx","altIndexArrClone","unMatchedAlternation","concat","ndx1","dropMatch","ndx2","altMatch2","qndx","mergeLocators","previousPos","mtndx","getBufferTemplate","getBuffer","noCache","refreshFromBuffer","valResult","negationSymbol","front","caret","toUpperCase","posBefore","args","checkAlternationMatch","altArr1","altArr2","na","altArrC","isMatch","naArr","naNdx","alndx","alternate","c","fromIsValid","rAltPos","validPsClone","lastAlt","isValidRslt","returnRslt","altPos","prevAltPos","validPos","decisionPos","lAltPos","insertPosition","insert","targetLvp","posOffset","validInputsClone","staticInputsBeforePos","validInputs","fromAlternate","validateOnly","isSelection","posObj","begin","maskPos","processCommandObject","commandObj","sort","b","revalidateMask","refresh","rewritePosition","_isValid","rslt","validatedPos","result","positionsClone","currentPosValid","seekNext","skip","isMask","nPos","snPos","trackbackPositions","postResult","endResult","originalPos","newPos","fillOnly","ps","vp","np","cvpInput","validTest","IsEnclosedStatic","selection","posMatch","nextMatch","lvp","j","needsValidation","t","newBlock","seekPrevious","writeBuffer","caretPos","triggerEvents","_valueSet","renderColorMask","$input","nptVal","_valueGet","setTimeout","returnPL","staticAlternations","prevTest","HandleNativePlaceholder","nptValue","determineNewCaretPosition","selectedCaret","tabbed","doRadixFocus","clickPos","vps","radixPos","clickPosition","lvclickPosition","lastPosition","tt","EventRuler","eventHandler","imOpts","disabled","readOnly","ctrlKey","preventDefault","returnVal","stopPropagation","form","evArr","EventHandlers","keydownEvent","k","kdResult","handleRemove","shiftKey","altKey","checkVal","keypressEvent","checkval","writeOut","which","charCode","metaKey","forwardPosition","writeOutBuffer","pasteEvent","originalEvent","inputValue","tempValue","valueBeforeCaret","substr","valueAfterCaret","clipboardData","getData","pasteValue","inputFallBackEvent","radixPointHandler","ieMobileHandler","inputChar","iv","offset","frontPart","backPart","frontBufferPart","backBufferPart","entries","isEntry","fpl","entry","keypress","keydown","beforeInputEvent","inputType","setValueEvent","applyInputValue","focusEvent","clickEvent","mouseleaveEvent","activeElement","newCaretPosition","cutEvent","clipData","setData","execCommand","blurEvent","mouseenterEvent","submitEvent","resetEvent","invalidEvent","valueBuffer","nptvl","initiatingEvent","charCodes","initialNdx","isTemplateMatch","targetTemplate","charCodeNdx","staticMatches","prevCaretPos","sndx","nextValid","nextSndx","umValue","pndx","bufferValue","notranslate","translatePosition","range","selectionStart","selectionEnd","getSelection","getRangeAt","commonAncestorContainer","parentNode","startOffset","endOffset","createRange","duplicate","moveStart","text","scrollCalc","ownerDocument","defaultView","getComputedStyle","currentStyle","fontSize","scrollLeft","scrollWidth","setSelectionRange","firstChild","textNode","createTextNode","appendChild","setStart","setEnd","collapse","sel","removeAllRanges","addRange","createTextRange","moveEnd","select","determineLastRequiredPosition","returnDefinition","bl","positions","lvTest","lvTestAlt","complete","lrp","aml","pend","initializeColorMask","computedStyle","findCaretPos","clientx","textTransform","letterSpacing","height","width","visibility","whiteSpace","body","inputText","previousWidth","itl","innerHTML","offsetWidth","offset1","offset2","removeChild","className","insertBefore","clientX","clear","isStatic","setEntry","mtl","setCaret","getElementsByTagName","isElementTypeSupported","patchValueProperty","valueGet","valueSet","patchValhook","inputmaskpatch","valhookGet","get","valhookSet","set","getter","setter","installNativeValueSetFallback","__valueGet","getOwnPropertyDescriptor","getPrototypeOf","__proto__","object","valueProperty","defineProperty","configurable","tagName","textContent","__lookupGetter__","__lookupSetter__","__defineGetter__","__defineSetter__","__valueSet","overruleRTL","elementType","isContentEditable","autocorrect","initialValue","rl","lmib","cv","maskTarget","mtdt","formatCode","d","Date","setDate","getDate","dd","pad","ddd","dddd","setMonth","getMonth","mm","mmm","mmmm","yy","setFullYear","getFullYear","yyyy","h","setHours","getHours","hh","hhh","H","HH","HHH","M","setMinutes","getMinutes","MM","s","setSeconds","getSeconds","ss","setMilliseconds","getMilliseconds","L","T","TT","Z","o","S","formatAlias","isoDate","isoTime","isoDateTime","isoUtcDateTime","getTokenizer","tokens","isValidDate","dateParts","currentResult","rawday","day","rawyear","date","rawmonth","month","isDateInRange","rawYear","minYear","year","getTime","dateObjValue","raw","getFn","val","maskString","dateObj","targetProp","dateOperation","extendProperty","correctedValue","datetime","i18n","ordinalSuffix","inputFormat","displayFormat","outputFormat","dayNames","monthNames","calcPos","fuzzy","today","getYear","autoEscape","txt","escapedTxt","alignDigits","digits","digitsOptional","radixPosition","findValidator","symbol","tstNdx","ndxl","findValid","ret","parseMinMaxOptions","parseFloat","NaN","Number","MIN_VALUE","MAX_VALUE","genMask","decimalDef","__financeInput","prefix","_mask","dq","suffix","hanndleRadixDance","decimalValidator","numeric","enforceDigitsOnBlur","allowMinus","back","step","unmaskAsNumber","0","1","+","isNegative","unmasked","processValue","valueParts","integerPart","decimalPart","digitsFactor","pow","round","substring","numberMatches","number","groups","leadingzeroes","buf","caretNdx","newCaretPos","bffr","currency","decimal","integer","percentage","indianns","installedModules","modules","enumerable","r","Symbol","toStringTag","mode","__esModule","ns","create","bind","n","getDefault","getModuleExports","property","moduleId"],"mappings":";;;;;;;CAAA,SAAAA,iCAAAC,MAAAC;IACA,uBAAAC,WAAA,mBAAAC,QACAA,OAAAD,UAAAD,gBACA,yBAAAG,iBAAAC,KACAD,OAAA,IAAAH,eACA;QACA,IAAAK,IAAAL;QACA,SAAAM,KAAAD,IAAA,mBAAAJ,oBAAAF,MAAAO,KAAAD,EAAAC;;CAPA,CASCC,QAAA;IACD;QCRAC,oBAAQ,IACRA,oBAAQ,IACRA,oBAAQ,IACRN,OAAOD,UAAUO,oBAAQ;;QCCzB,IAAIC,YAAYD,oBAAQ;QAExBC,UAAUC,kBAAkB;YAC3BC,GAAK;gBACJC,WAAW;gBACXC,QAAQ;;YAETC,KAAK;gBACJF,WAAW;gBACXC,QAAQ;;YAETE,KAAK;gBACJH,WAAW;gBACXC,QAAQ;;YAGVJ,UAAUO,cAAc;YACvBC,SAAW;gBACVC,OAAO;;YAERC,KAAO;gBACND,OAAO;gBACPE,aAAY;;YAEbC,IAAM;gBACLC,MAAM;gBACNC,aAAa;oBACZjB,GAAK;wBACJM,WAAW,SAAAA,UAAUY,MAAMC,SAASC,KAAKC,QAAQC;4BAOhD,OAHEJ,QAHa,IAAXE,MAAM,KAAsC,QAA5BD,QAAQI,OAAOH,MAAM,MACxCF,OAAOC,QAAQI,OAAOH,MAAM,KAAKF;6BAClB,IAAXE,MAAM,KAAsC,QAA5BD,QAAQI,OAAOH,MAAM,KACjCD,QAAQI,OAAOH,MAAM,KAAKF,OACpB,MAAMA,QACP,OAAOA;4BACd,IAAIM,OAAO,sCAAsCC,KAAKP;;;;gBAIhEQ,UAAU,SAAAA,SAAUC,aAAaC,eAAeN;oBAC/C,OAAOK;;gBAERE,WAAW;;YAEZC,OAAS;gBAIRd,MAAM;gBACNe,SAAQ;gBACRxB,QAAQ;gBACRyB,eAAe,SAAAA,cAAUC,aAAaX;oBAErC,OADAW,cAAcA,YAAYC,eACnBD,YAAYE,QAAQ,WAAW;;gBAEvClB,aAAa;oBACZmB,KAAK;wBACJ9B,WAAW;;oBAEZ+B,KAAK;wBACJ/B,WAAW;;;gBAGboB,UAAU,SAAAA,SAAUC,aAAaC,eAAeN;oBAC/C,OAAOK;;gBAERE,WAAW;;YAEZS,KAAO;gBACNtB,MAAM;;YAIPuB,KAAO;gBACNvB,MAAM;gBACNC,aAAa;oBACZuB,GAAK;wBACJlC,WAAW;wBACXC,QAAQ;;;gBAGVkC,kBAAiB;gBACjB3B,aAAY;;YAGdlB,OAAOD,UAAUQ;;;;;;;;;QCrFjB,IAAIuC,IAAIxC,oBAAQ,IAA6CD,SAASC,oBAAQ,IAC7EyC,WAAW1C,OAAO0C,UAClBC,kBAAkB1C,oBAAQ,GAAa0C,iBACvCC,cAAc3C,oBAAQ,GAAa2C,aACnCC,YAAY5C,oBAAQ;QAGrB,SAASC,UAAU4C,OAAOC,SAASC;YAElC,MAAMC,gBAAgB/C,YACrB,OAAO,IAAIA,UAAU4C,OAAOC,SAASC;YAGtCC,KAAKC,UAAKC,GACVF,KAAKG,SAAS,IACdH,KAAK/B,eAAUiC,GACfF,KAAKI,gBAAe;aAEH,MAAbL,aAECP,EAAEa,cAAcR,SACnBC,UAAUD,SAEVC,UAAUA,WAAW;YACjBD,UAAOC,QAAQD,QAAQA,SAE5BG,KAAK5B,OAAOoB,EAAEc,QAAO,GAAM,IAAIN,KAAKO,UAAUT;YAC9CE,KAAKQ,eAAeV,gBAAmCI,MAAxBJ,QAAQ/B,aACvCiC,KAAKS,cAAcX,WAAW;YAC9BY,aAAaV,KAAK5B,KAAKyB,OAAOC,SAASE,KAAK5B,OAC5C4B,KAAKW,QAAQX,KAAK5B,KAAKwC;;QA4LzB,SAASF,aAAaG,UAAUf,SAAS1B;YACxC,IAAI0C,kBAAkB7D,UAAU8D,UAAUC,QAAQH;YAClD,OAAIC,mBACCA,gBAAgBjB,SAAOa,aAAaI,gBAAgBjB,YAAOK,GAAW9B;YAC1EoB,EAAEc,QAAO,GAAMlC,MAAM0C,kBACrBtB,EAAEc,QAAO,GAAMlC,MAAM0B,WACd,MAEU,SAAd1B,KAAKN,SACRM,KAAKN,OAAO+C;aAGN;;QAGR,SAASI,uBAAuBC,KAAK9C,MAAMqC,aAAaU;YACvD,SAASC,aAAaC,QAAQC;gBAC7BA,kBAA4BpB,MAAfoB,aAA2BA,aAAaJ,IAAIK,aAAaJ,gBAAgB,MAAME;gBACzE,SAAfC,eACuB,mBAAfA,eACmB,MAAzBD,OAAOG,QAAQ,QAClBF,aAAavE,OAAOuE,cAEG,YAAfA,aACRA,cAAa,IACY,WAAfA,eAAuBA,cAAa;gBAEhDb,YAAYY,UAAUC;;YAIxB,KAAkC,MAA9BlD,KAAKqD,sBAA+B;gBACvC,IAAIC,cAAcR,IAAIK,aAAaJ,gBAAgBE,QAAQM,aAAaL,YAAYM;gBAQpF,IANIF,eAA+B,OAAhBA,gBAClBA,cAAcA,YAAYzC,QAAQ,MAAM;gBACxC0C,cAAcE,KAAKC,MAAM,MAAMJ,cAAc,OAI1CC,aAEH,KAAKC,KADLN,kBAAapB;gBACHyB,aACT,IAAwB,YAApBC,EAAE5C,eAA2B;oBAChCsC,aAAaK,YAAYC;oBACzB;;gBASH,KAAKP,UALLD,aAAa,SAASE,aAClBb,YAAYZ,SACfa,aAAaD,YAAYZ,OAAOY,aAAarC;gBAG/BA,MAAM;oBACpB,IAAIuD,aAEH,KAAKC,KADLN,kBAAapB,GACHyB,aACT,IAAIC,EAAE5C,kBAAkBqC,OAAOrC,eAAe;wBAC7CsC,aAAaK,YAAYC;wBACzB;;oBAIHR,aAAaC,QAAQC;;;YAgBvB,OAbA9B,EAAEc,QAAO,GAAMlC,MAAMqC,cAGL,UAAZS,IAAIa,QAAiB3D,KAAK4D,eAC7Bd,IAAIe,MAAMC,YAAY;YAGP,UAAZhB,IAAIa,QAAiB3D,KAAKwC,iBAC7BM,IAAIa,MAAM,OACVb,IAAIiB,gBAAgB;YACpB/D,KAAKuC,SAAQ,IAGPyB,OAAOC,KAAK5B,aAAa6B;;QAxQjCrF,UAAU8D,YAAY;YACrBI,eAAe;YAEfZ,UAAU;gBACTgC,aAAa;gBACbC,gBAAgB,EAAC,KAAK;gBACtBC,kBAAkB,EAAC,KAAK;gBACxBC,aAAa,EAAC,KAAK;gBACnBC,kBAAkB;gBAClBC,YAAY;gBACZ9E,MAAM;gBACNJ,OAAO;gBACPmF,YAAYrD,EAAEsD;gBACdC,cAAcvD,EAAEsD;gBAChBE,WAAWxD,EAAEsD;gBACbG,QAAQ;gBACRpE,SAAQ;gBACRjB,aAAY;gBACZsF,qBAAoB;gBACpBC,uBAAsB;gBACtBC,aAAY;gBACZ7D,kBAAiB;gBACjBM,OAAO;gBACPwD,WAAW7D,EAAEsD;gBACbQ,cAAc;gBACdxE,eAAe,SAAAA,cAAUC,aAAaX;oBACrC,OAAOoB,EAAE+D,WAAWnF,KAAKkF,gBAAgBlF,KAAKkF,aAAaE,KAAKxD,MAAMjB,aAAaX,QAAQW;;gBAE5F0E,eAAe;gBACfjF,UAAU;gBACVkF,kBAAiB;gBACjBC,kBAAiB;gBACjBC,iBAAiBpE,EAAEsD;gBACnBe,2BAA2B;gBAC3BjD,eAAc;gBACdoB,aAAY;gBACZ8B,eAAc;gBAEdC,YAAY;gBACZC,cAAa;gBACbC,gBAAgB;gBAEhBC,YAAY;gBACZC,qBAAoB;gBACpBC,aAAY;gBACZC,mBAAmB,EAAC,QAAQ,OAAO,OAAO,YAAY;gBAEtDC,YAAY,EAAC,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,GAAG;gBAC1IC,YAAY;gBACZC,eAAe;gBACfC,gBAAgB;gBAChBC,6BAAwBxE;gBACxByE,aAAY;gBACZC,WAAU;gBACVC,iBAAgB;gBAChBC,kBAAiB;gBACjBC,sBAAsB;gBACtB1H,QAAQ;gBACRsB,WAAW;gBACXqG,YAAW;gBACXC,wBAAuB;gBACvBxD,uBAAsB;gBACtByD,iBAAgB;;YAEjBnH,aAAa;gBACZoH,GAAK;oBACJ/H,WAAW;oBACXgI,kBAAkB;;gBAEnBvI,GAAK;oBACJO,WAAW;oBACXgI,kBAAkB;;gBAEnBlG,KAAK;oBACJ9B,WAAW;;;YAGb4D,SAAS;YACTqE,YAAY;YACZvH,MAAM,SAAAA,KAAUwH;gBACf,IAAIC,OAAOvF;gBA+BX,OA9BqB,mBAAVsF,UACVA,QAAQ7F,SAAS+F,eAAeF,UAAU7F,SAASgG,iBAAiBH;gBAErEA,QAAQA,MAAMI,WAAW,EAACJ,UAASA,OACnC9F,EAAEmG,KAAKL,OAAO,SAAUM,KAAK3F;oBAC5B,IAAI4F,aAAarG,EAAEc,QAAO,GAAM,IAAIiF,KAAKnH;oBACzC,IAAI6C,uBAAuBhB,IAAI4F,YAAYrG,EAAEc,QAAO,GAAM,IAAIiF,KAAK9E,cAAc8E,KAAKpE,gBAAgB;wBACrG,IAAIlD,UAAUyB,gBAAgBmG,YAAYN,KAAK/E;6BAC/BN,MAAZjC,iBACkBiC,MAAjBD,GAAG6F,cACN7F,GAAG6F,UAAU1H,KAAKR,cAAa;wBAC/BqC,GAAG6F,UAAUC,WAGd9F,GAAG6F,YAAY,IAAI7I,eAAUiD,QAAWA,IAAW,IACnDD,GAAG6F,UAAU1H,OAAOyH;wBACpB5F,GAAG6F,UAAUtF,eAAe+E,KAAK/E,cACjCP,GAAG6F,UAAUrF,cAAcjB,EAAEc,QAAO,GAAM,IAAIiF,KAAK9E;wBACnDR,GAAG6F,UAAUnF,QAAQkF,WAAWlF,SAASkF,WAAWjF,cACpDX,GAAG6F,UAAU7F,KAAKA;wBAClBA,GAAG6F,UAAU7H,UAAUA,SAEvBuB,EAAEwG,KAAK/F,IAAI,mBAAmB4F,aAE9BjG,UAAU4D,KAAKvD,GAAG6F,WAAW;4BAC5BG,QAAU;;;oBAKPX,SAASA,MAAM,MAAMA,MAAM,GAAGQ,aAAqB9F;;YAE3DqB,QAAQ,SAAAA,OAAUvB,SAASoG;gBAC1B,OAAuB,mBAAZpG,UACHE,KAAK5B,KAAK0B,WACY,aAAnBqG,QAAOrG,YACjBN,EAAEc,OAAON,KAAKS,aAAaX;gBAEvBE,KAAKC,OAAmB,MAAbiG,YACdlG,KAAKlC,KAAKkC,KAAKC,KAETD,aAND;;YASRoG,eAAe,SAAAA,cAAUC;gBAExB,OADArG,KAAK/B,UAAU+B,KAAK/B,WAAWyB,gBAAgBM,KAAK5B,MAAM4B,KAAKQ;gBACxDZ,UAAU4D,KAAKxD,MAAM;oBAC3BiG,QAAU;oBACVI,OAASA;;;YAGXN,QAAQ,SAAAA;gBACP,OAAOnG,UAAU4D,KAAKxD,MAAM;oBAC3BiG,QAAU;;;YAGZK,cAAc,SAAAA;gBAEb,OADAtG,KAAK/B,UAAU+B,KAAK/B,WAAWyB,gBAAgBM,KAAK5B,MAAM4B,KAAKQ;gBACxDZ,UAAU4D,KAAKxD,MAAM;oBAC3BiG,QAAU;;;YAGZM,gBAAgB,SAAAA;gBACf,QAAQvG,KAAK5B,KAAKR;;YAEnB2G,YAAY,SAAAA;gBAEX,OADAvE,KAAK/B,UAAU+B,KAAK/B,WAAWyB,gBAAgBM,KAAK5B,MAAM4B,KAAKQ;gBACxDZ,UAAU4D,KAAKxD,MAAM;oBAC3BiG,QAAU;;;YAGZO,aAAa,SAAAA;gBAEZ,OADAxG,KAAK/B,UAAU+B,KAAK/B,WAAWyB,gBAAgBM,KAAK5B,MAAM4B,KAAKQ;gBACxDZ,UAAU4D,KAAKxD,MAAM;oBAC3BiG,QAAU;;;YAGZQ,SAAS,SAAAA,QAAUJ;gBAElB,OADArG,KAAK/B,UAAU+B,KAAK/B,WAAWyB,gBAAgBM,KAAK5B,MAAM4B,KAAKQ;gBACxDZ,UAAU4D,KAAKxD,MAAM;oBAC3BiG,QAAU;oBACVI,OAASA;;;YAGXK,QAAQ,SAAAA,OAAUL,OAAOM;gBAExB,OADA3G,KAAK/B,UAAU+B,KAAK/B,WAAWyB,gBAAgBM,KAAK5B,MAAM4B,KAAKQ;gBACxDZ,UAAU4D,KAAKxD,MAAM;oBAC3BiG,QAAU;oBACVI,OAASA;oBACTM,UAAYA;;;YAGdC,UAAU,SAAAA,SAAUP;gBACfrG,KAAKC,MACRT,EAAEQ,KAAKC,IAAI4G,QAAQ,YAAY,EAACR;;YAGlC1G,aAAaA;YACbmH,mBAAmB,SAAAA,kBAAUC,OAAOC;gBACnCD,MAAM9E,MAAMgF,OAAOD,SAASE,aAAa;;WAwF3CjK,UAAUkK,iBAAiB,SAAUrH;YACpCN,EAAEc,QAAO,GAAMrD,UAAU8D,UAAUR,UAAUT;WAE9C7C,UAAUC,oBAAoB,SAAUkK;YACvC5H,EAAEc,QAAO,GAAMrD,UAAU8D,UAAUhD,aAAaqJ;WAEjDnK,UAAUO,gBAAgB,SAAUqC;YACnCL,EAAEc,QAAO,GAAMrD,UAAU8D,UAAUC,SAASnB;WAG7C5C,UAAUyJ,SAAS,SAAUL,OAAOvG,SAAS6G;YAC5C,OAAO1J,UAAU6C,SAAS4G,OAAOL,OAAOM;WAEzC1J,UAAUoK,SAAS,SAAUhB,OAAOvG;YACnC,OAAO7C,UAAU6C,SAASsG,cAAcC;WAEzCpJ,UAAUwJ,UAAU,SAAUJ,OAAOvG;YACpC,OAAO7C,UAAU6C,SAAS2G,QAAQJ;WAEnCpJ,UAAU8I,SAAS,SAAUT;YACP,mBAAVA,UACVA,QAAQ7F,SAAS+F,eAAeF,UAAU7F,SAASgG,iBAAiBH;YAErEA,QAAQA,MAAMI,WAAW,EAACJ,UAASA,OACnC9F,EAAEmG,KAAKL,OAAO,SAAUM,KAAK3F;gBACxBA,GAAG6F,aAAW7F,GAAG6F,UAAUC;;WAGjC9I,UAAU2J,WAAW,SAAUtB,OAAOe;YAChB,mBAAVf,UACVA,QAAQ7F,SAAS+F,eAAeF,UAAU7F,SAASgG,iBAAiBH;YAErEA,QAAQA,MAAMI,WAAW,EAACJ,UAASA,OACnC9F,EAAEmG,KAAKL,OAAO,SAAUM,KAAK3F;gBACxBA,GAAG6F,YAAW7F,GAAG6F,UAAUc,SAASP,SAAa7G,EAAES,IAAI4G,QAAQ,YAAY,EAACR;;WAGlFpJ,UAAUqK,cAAc,SAAUC;YACjC,IAAIC,WAAW,EAAC,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,MAAM,KAAK;YACvF,OAAOD,IAAItI,QAAQ,IAAIX,OAAO,QAAQkJ,SAASC,KAAK,SAAS,KAAK,QAAQ;WAE3ExK,UAAUyK,UAAU;YACnBC,WAAW;YACXC,kBAAkB;YAClBC,QAAQ;YACRC,MAAM;YACNC,KAAK;YACLC,OAAO;YACPC,QAAQ;YACRC,MAAM;YACNC,QAAQ;YACRC,MAAM;YACNC,WAAW;YACXC,SAAS;YACTC,OAAO;YACPC,OAAO;YACPC,KAAK;YACLC,IAAI;YACJC,GAAG;YACHC,SAAS;WAEV3L,UAAU4L,gBAAgBrJ,GAG1BzC,OAAOE,YAAYA,WACnBP,OAAOD,UAAUQ;;;;;;;;;QC9WjB,IAAIF,SAASC,oBAAQ,IAAqByC,WAAW1C,OAAO0C;QAK5D,SAAS+B,QAAQsH,MAAMC;YAGtB,KAFA,IAAIjM,IAAI,GACPkM,MAAMF,KAAKxG,QACLxF,IAAIkM,KAAKlM,KACf,IAAIgM,KAAKhM,OAAOiM,MACf,OAAOjM;YAGT,QAAQ;;QAGT,SAASmM,SAASC;YACjB,OAAc,QAAPA,OAAeA,QAAQA,IAAG;;QAGlC,SAASC,YAAYD;YAKpB,IAAI5G,SAAS,YAAY4G,OAAOA,IAAI5G,QACnC8G,QAAKjD,QAAU+C;YAEhB,OAAc,eAAVE,UAAwBH,SAASC,WAIhB,MAAjBA,IAAIG,aAAkB/G,YAIT,YAAV8G,SAAgC,MAAX9G,UACT,mBAAXA,UAAgC,IAATA,UAAeA,SAAS,KAAM4G;;QAG9D,SAASI,eAAeP;YACvB,OAAOA,gBAAgBQ;;QAGxB,SAASC,cAAcT;YACtB,OAAIA,gBAAgBS,gBACZT,OAEF/I,gBAAgBwJ,sBAGlBT,gBAAuCA,SAAShM,WACnDiD,KAAK,KAAK+I,KAAKrD,WAAWqD,YAAoB7I,MAAZ6I,KAAK,MAAoBA,KAAK,GAAGrD,WAAWqD,KAAK,KAAKtJ,SAASgK,cAAcV;iBAC/F7I,MAAZF,KAAK,MAAgC,SAAZA,KAAK,OACjCA,KAAK,GAAG0J,gBAAgB1J,KAAK,GAAG0J,iBAAiB,QAL3C,IAAIF,cAAcT;;QAU3BS,cAAczI,YAAY;YACzB4I,IAAI,SAAAA,GAAUxJ,QAAQyJ;gBACrB,SAASC,SAASC,IAAIC;oBAEjBhB,KAAKiB,mBACRjB,KAAKiB,iBAAiBF,IAAIF,UAAS,KACzBb,KAAKkB,eACflB,KAAKkB,YAAY,OAAOH,IAAIF;oBAE7BF,cAAcI,MAAMJ,cAAcI,OAAO,IACzCJ,cAAcI,IAAIC,aAAaL,cAAcI,IAAIC,cAAc;oBAC/DL,cAAcI,IAAIC,WAAWG,KAAKN;;gBAGnC,IAAIN,eAAetJ,KAAK,KAMvB,KALA,IAAI0J,gBAAgB1J,KAAK,GAAG0J,eAC3BX,OAAO/I,KAAK,IAGTmK,UAAUhK,OAAOiK,MAAM,MAClBC,OAAO,GAAGA,OAAOF,QAAQ7H,QAAQ+H,QAAQ;oBACjD,IAAIC,UAAUH,QAAQE,MAAMD,MAAM,MACjCN,KAAKQ,QAAQ,IACbP,YAAYO,QAAQ,MAAM;oBAC3BT,SAASC,IAAIC;;gBAGf,OAAO/J;;YAERuK,KAAK,SAAAA,IAAUpK,QAAQyJ;gBACtB,IAAIF,eAAeX;gBAEnB,SAASyB,YAAYV,IAAIC,WAAWH;oBACnC,IAAIE,MAAMJ,kBAAkB,GAO3B,IALIX,KAAK0B,sBACR1B,KAAK0B,oBAAoBX,IAAIF,UAAS,KAC5Bb,KAAK2B,eACf3B,KAAK2B,YAAY,OAAOZ,IAAIF;oBAEX,aAAdG,WACH,KAAK,IAAIY,QAAQjB,cAAcI,KAC9BJ,cAAcI,IAAIa,MAAMC,OAAOlB,cAAcI,IAAIa,MAAMnJ,QAAQoI,UAAU,SAG1EF,cAAcI,IAAIC,WAAWa,OAAOlB,cAAcI,IAAIC,WAAWvI,QAAQoI,UAAU;;gBAKtF,SAASiB,iBAAiBf,IAAIC;oBAC7B,IAAIe,OAAO,IACVC,MAAMC;oBACP,IAAgB,IAAZlB,GAAGxH,QACN,SAAgBpC,MAAZ0J,SACH,KAAKmB,OAAO,GAAGC,OAAOtB,cAAcI,IAAIC,WAAWzH,QAAQyI,OAAOC,MAAMD,QACvED,KAAKZ,KAAK;wBACTJ,IAAIA;wBACJC,WAAWA,aAAgC,IAAnBA,UAAUzH,SAAayH,YAAY;wBAC3DH,SAASF,cAAcI,IAAIC,WAAWgB;6BAIxCD,KAAKZ,KAAK;wBACTJ,IAAIA;wBACJC,WAAWA,aAAgC,IAAnBA,UAAUzH,SAAayH,YAAY;wBAC3DH,SAASA;6BAGL,IAAuB,IAAnBG,UAAUzH,QACpB,KAAK,IAAI2I,SAASvB,eACjB,KAAK,IAAIiB,QAAQjB,cAAcuB,QAC9B,IAAIN,SAASZ,WACZ,SAAgB7J,MAAZ0J,SACH,KAAKmB,OAAO;oBAAGC,OAAOtB,cAAcuB,OAAON,MAAMrI,QAAQyI,OAAOC,MAAMD,QACrED,KAAKZ,KAAK;wBACTJ,IAAImB;wBACJlB,WAAWY;wBACXf,SAASF,cAAcuB,OAAON,MAAMI;6BAItCD,KAAKZ,KAAK;wBACTJ,IAAImB;wBACJlB,WAAWY;wBACXf,SAASA;;oBAQf,OAAOkB;;gBAGR,IAAIxB,eAAetJ,KAAK,KAAK;oBAC5B0J,gBAAgB1J,KAAK,GAAG0J,eACxBX,OAAO/I,KAAK;oBAIZ,KADA,IAAImK,UAAUhK,OAAOiK,MAAM,MAClBC,OAAO,GAAGA,OAAOF,QAAQ7H,QAAQ+H,QAGzC,KAFA,IAAIC,UAAUH,QAAQE,MAAMD,MAAM,MACjCc,YAAYL,iBAAiBP,QAAQ,IAAIA,QAAQ,KACzCxN,IAAI,GAAGqO,aAAaD,UAAU5I,QAAQxF,IAAIqO,YAAYrO,KAC9D0N,YAAYU,UAAUpO,GAAGgN,IAAIoB,UAAUpO,GAAGiN,WAAWmB,UAAUpO,GAAG8M;;gBAIrE,OAAO5J;;YAER6G,SAAS,SAAAA,QAAU1G;gBAClB,IAAImJ,eAAetJ,KAAK,KAIvB,KAHA,IAAI0J,gBAAgB1J,KAAK,GAAG0J,eAC3BX,OAAO/I,KAAK,IACTmK,UAA4B,mBAAXhK,SAAsBA,OAAOiK,MAAM,OAAO,EAACjK,OAAOiL,QAC9Df,OAAO,GAAGA,OAAOF,QAAQ7H,QAAQ+H,QAAQ;oBACjD,IAAIC,UAAUH,QAAQE,MAAMD,MAAM,MACjCN,KAAKQ,QAAQ,IACbP,YAAYO,QAAQ,MAAM;oBAC3B,SAAiBpK,MAAbT,YAAwC,aAAdsK,WAAwB;wBAErD,IAAIsB,MAAMvO,GAAGwO,SAAS;4BACrBC,UAAS;4BACTC,aAAY;4BACZC,QAAQC,UAAU;;wBAGnB,IAAIjM,SAASkM,aAAa;4BACzB;gCACCN,OAAO,IAAIO,YAAY9B,IAAIwB;8BAC1B,OAAOO;gCACRR,OAAO5L,SAASkM,YAAY,gBAC5BN,KAAKS,gBAAgBhC,IAAIwB,OAAOC,SAASD,OAAOE,YAAYF,OAAOG;;4BAEhEtL,OAAOiL,QAAM5B,cAAclJ,OAAO+K,MAAMlL,SAC5C4I,KAAKgD,cAAcV;+BAEnBA,OAAO5L,SAASuM,qBAChBX,KAAKY,YAAYnC,IACjBuB,KAAKI,SAASC,UAAU;wBACpBvL,OAAOiL,QAAM5B,cAAclJ,OAAO+K,MAAMlL,SAC5C4I,KAAKmD,UAAU,OAAOb,KAAKY,WAAWZ;2BAEjC,SAA0BnL,MAAtBwJ,cAAcI,KAGxB,IApCe3J,gBAkCaiL,OAlCbjL,SAkCmCqJ,cAAc2C,MAlCjDhM;oBAAAA,OAmCFsL,SAASC,UAAUU,MAAM,IACpB,aAAdrC,WACH,KAAK,IAAIY,QAAQjB,cAAcI,KAC9B,KAAKhN,IAAI,GAAGA,IAAI4M,cAAcI,IAAIa,MAAMrI,QAAQxF,KAC/C4M,cAAcI,IAAIa,MAAM7N,GAAGuP,MAAMtD,MAAM2C,iBAIzC,KAAK5O,IAAI,GAAGA,IAAI4M,cAAcI,IAAIC,WAAWzH,QAAQxF,KACpD4M,cAAcI,IAAIC,WAAWjN,GAAGuP,MAAMtD,MAAM2C;;gBAMjD,OAAO1L;;WAKTwJ,cAAcjG,aAAa,SAAU2F;YACpC,OAAsB,qBAARA;WAEfM,cAAc1G,OAAO,eAErB0G,cAAc8C,UAAUC,MAAMD,SAC9B9C,cAAcgD,UAAU,SAAUzD,MAAM0D,KAAK3P;YAC5C,OAAc,QAAP2P,OAAe,IAAIjL,QAAQiL,KAAK1D,MAAMjM;WAE9C0M,cAAckD,gBAAWxM,GAGzBsJ,cAAcnJ,gBAAgB,SAAU6I;YAKvC,OAAmB,aAAf/C,QAAO+C,SAAoBA,IAAIG,aAAYJ,SAASC,UAIpDA,IAAIyD,gBAAgBvK,OAAOwK,eAAepJ,KAAK0F,IAAIyD,YAAY5L,WAAW;WAS/EyI,cAAclJ,SAAS;YACtB,IAAIR,SAAS+M,MAAMC,KAAKC,MAAMC,aAAaC,OAC1CC,SAASxB,UAAU,MAAM,IACzB5O,IAAI,GACJwF,SAASoJ,UAAUpJ,QACnB6K,QAAO;YAsBR,KAnBsB,oBAAXD,WACVC,OAAOD,QAGPA,SAASxB,UAAU5O,MAAM;YACzBA,MAIqB,aAAlBqJ,QAAO+G,WAAwB1D,cAAcjG,WAAW2J,YAC3DA,SAAS;YAINpQ,MAAMwF,WACT4K,SAASlN,MACTlD,MAGMA,IAAIwF,QAAQxF,KAElB,IAAgC,SAA3BgD,UAAU4L,UAAU5O,KAExB,KAAK+P,QAAQ/M,SACZgN,MAAMI,OAAOL;YACbE,OAAOjN,QAAQ+M,OAGXK,WAAWH,SAKXI,QAAQJ,SAASvD,cAAcnJ,cAAc0M,UAAUC,cAAcxD,cAAc8C,QAAQS,WAG7FE,QAFGD,eACHA,eAAc;YACNF,OAAOtD,cAAc8C,QAAQQ,OAAOA,MAAM,MAG1CA,OAAOtD,cAAcnJ,cAAcyM,OAAOA,MAAM;YAIzDI,OAAOL,QAAQrD,cAAclJ,OAAO6M,MAAMF,OAAOF,cAG9B7M,MAAT6M,SACVG,OAAOL,QAAQE;YAOnB,OAAOG;WAGR1D,cAAc7D,OAAO,SAAUuD,KAAKkE;YACnC,IAAI/G,OAAOvJ,IAAI;YAEf,IAAIqM,YAAYD,MACf,KAAK,IAAI5G,SAAS4G,IAAI5G,QAAQxF,IAAIwF,WACjC+D,QAAQ+G,SAAS5J,KAAK0F,IAAIpM,IAAIA,GAAGoM,IAAIpM;aACvB,MAAVuJ,QAFqCvJ,YAO1C,KAAKA,KAAKoM,KAET,IADA7C,QAAQ+G,SAAS5J,KAAK0F,IAAIpM,IAAIA,GAAGoM,IAAIpM;aACvB,MAAVuJ,OACH;YAKH,OAAO6C;WAGRM,cAAcxD,OAAO,SAAUqH,OAAOC,KAAKjH;YAC1C,SAAcnG,MAAVmG,OACH,OAAOgH,MAAME,SAASF,MAAME,OAAOD,OAAO;YAE1CD,MAAME,SAASF,MAAME,UAAU,IAC/BF,MAAME,OAAOD,OAAOjH;WAIY,qBAAvBtJ,OAAO6O,cACjBpC,cAAc2C,QAAQpP,OAAO6O,eAE7BpC,cAAc2C,QAAQ,SAAUqB,OAAOlC;YACtCA,SAASA,UAAU;gBAACC,UAAS;gBAAOC,aAAY;gBAAOC,aAAQvL;;YAC/D,IAAIuN,MAAMhO,SAASkM,YAAY;YAE/B,OADA8B,IAAI3B,gBAAgB0B,OAAOlC,OAAOC,SAASD,OAAOE,YAAYF,OAAOG;YAC9DgC;WAERjE,cAAc2C,MAAMpL,YAAYhE,OAAOoP,MAAMpL,YAG9CrE,OAAOD,UAAU+M;;;;;;;;;;QClXhB7M;YACC,OAAyB,sBAAXI,SAAyBA,SAAS,KAAK2Q,KAAK,0BAAV,CAAqC,IAAI3Q;UADpFyG,KAAA/G,SAAAkR,qBAAAlR,SAAAC,cAAAwD,MAAA0N,kCAAAlR,OAAAD,UAAAmR;;QCDP,IAAIpO,IAAIxC,oBAAQ;QAEhB,SAAS0C,gBAAgBtB,MAAMyP;YAC9B,IAAIC;YAEJ,SAASC,aAAajQ,MAAM6I,UAAUvI;gBACrC,IAAI4P,aAAY,GAoBZC,mBAAmBC;gBANvB,IAba,SAATpQ,QAA0B,OAATA,SACpBkQ,YAA2B,SAAf5P,KAAKV,OAGhBI,OAFGkQ,aACHlQ,OAAOM,KAAKV;gBACLI,KAAKmB,QAAQ,kBAAkB,UAEtC+O,aAAY,GACL,QAGW,MAAhBlQ,KAAKwE,WAAgC,MAAhBlE,KAAKS,UAAoC,MAAhBT,KAAK6E,WACtD7E,KAAKmE,cAAc;gBAEF,IAAdnE,KAAK6E,UAA8B,QAAhB7E,KAAK6E,UAAkC,QAAhB7E,KAAK6E,QAAgB;oBAClE,IAAIkL,cAA8B,QAAhB/P,KAAK6E,SAAiB,IAAqB,QAAhB7E,KAAK6E,SAAiB,IAAI7E,KAAK6E;oBAC5EnF,OAAOM,KAAKsE,YAAY,KAAK5E,OAAOM,KAAKsE,YAAY,KAAKtE,KAAKqE,iBAAiB,KAAK0L,cAAc,MAAM/P,KAAK6E,SAAS7E,KAAKqE,iBAAiB;;gBA+B9I,OA1BAyL,aAAaF,YAAY,WAAW5P,KAAKV,QAAQU,KAAKwC,eAAe9C,KAAKsM,MAAM,IAAIgE,UAAU3G,KAAK,MAAM3J;iBACjF,MAApBM,KAAK8F,eACRgK,aAAa,QAAQA,kBAG6BhO,MAA/CjD,UAAU8D,UAAUsE,WAAW6I,gBAAyC,MAAZL,WAC/DI,oBAAoB;oBACnBnQ,MAAQA;oBACRuQ,WAAapR,UAAU8D,UAAUpB,YAAY7B,MAAMkQ,WAAW5P;oBAC9DkQ,gBAAkB;oBAClBC,cAAWrO;oBACX7B,aAAU6B;oBACVsO,OAAS;oBACTC,UAAY;oBACZ9H,UAAYA;oBACZ+H,iBAAcxO;oBACdyO,WAAa;oBAEE,MAAZd,YACH5Q,UAAU8D,UAAUsE,WAAW6I,cAAcD;gBAC7CA,oBAAoBzO,EAAEc,QAAO,GAAM,IAAIrD,UAAU8D,UAAUsE,WAAW6I,iBAGvED,oBAAoBzO,EAAEc,QAAO,GAAM,IAAIrD,UAAU8D,UAAUsE,WAAW6I;gBAGhED;;YAMR,IAHIzO,EAAE+D,WAAWnF,KAAKN,UACrBM,KAAKN,OAAOM,KAAKN,KAAKM,QAEnBoB,EAAE8M,QAAQlO,KAAKN,OAAO;gBACzB,IAAuB,IAAnBM,KAAKN,KAAKwE,QAAY;oBACzB,IAAwB,SAApBlE,KAAK8F,YAAqB;wBAC7B9F,KAAK8F,aAAa;wBAClB,KAAK,IAAIpH,IAAI,GAAGA,IAAIsB,KAAKN,KAAKwE,QAAQxF,KACrC,IAAIsB,KAAKN,KAAKhB,GAAG8R,OAAO,OAAOxQ,KAAKN,KAAK,GAAG8Q,OAAO,IAAI;4BACtDxQ,KAAK8F,cAAa;4BAClB;;;oBAIH,IAAI2K,UAAUzQ,KAAKsE,YAAY;oBAa/B,OAZAlD,EAAEmG,KAAKvH,KAAKuC,QAAQvC,KAAKN,KAAKsQ,YAAYhQ,KAAKN,MAAM,SAAU8H,KAAKkJ;wBAC9C,IAAjBD,QAAQvM,WACXuM,WAAWzQ,KAAKsE,YAAY,KAAKtE,KAAKuE,mBAAmBvE,KAAKsE,YAAY;6BAE1DxC,MAAb4O,IAAIhR,QAAuB0B,EAAE+D,WAAWuL,IAAIhR,QAG/C+Q,WAAWC,MAFXD,WAAWC,IAAIhR;wBAKjB+Q,WAAWzQ,KAAKsE,YAAY,IAErBqL,aAAac,SAASzQ,KAAKN,MAAMM;;gBAExCA,KAAKN,OAAOM,KAAKN,KAAKiR;;YAUxB,OALCjB,KADG1P,KAAKN,aAA2BoC,MAAnB9B,KAAKN,KAAKA,SAAuB0B,EAAE+D,WAAWnF,KAAKN,KAAKA,QACnEiQ,aAAa3P,KAAKN,KAAKA,MAAMM,KAAKN,MAAMM,QAExC2P,aAAa3P,KAAKN,MAAMM,KAAKN,MAAMM;YAGlC0P;;QAGR,SAASnO,YAAY7B,MAAMkQ,WAAW5P;YACrC,IAAI4Q,YAAY,6EAEfC,iBAAiB,mNACjBC,WAAU,GACVC,eAAe,IAAIC,aACnBC,OACAC,GACAC,aAAa,IACbC,aAAa,IACbC,cACAC,qBACAC,YACAC,WACAC,mBAAkB;YAEnB,SAAST,UAAUU,SAASC,YAAYC,cAAcC;gBACrDjQ,KAAKkQ,UAAU,IACflQ,KAAKmQ,YAAYL,YAAW,GAC5B9P,KAAKoQ,mBAAkB,GACvBpQ,KAAK8P,UAAUA,YAAW;gBAC1B9P,KAAK+P,aAAaA,eAAc,GAChC/P,KAAKgQ,eAAeA,iBAAgB,GACpChQ,KAAKiQ,eAAeA,iBAAgB;gBACpCjQ,KAAKqQ,aAAa;oBACjBC,KAAK;oBACLC,KAAK;;;YAKP,SAASC,qBAAqBC,QAAQC,SAASC;gBAC9CA,gBAAwBzQ,MAAbyQ,WAAyBA,WAAWF,OAAOP,QAAQ5N;gBAC9D,IAAIsO,YAAYH,OAAOP,QAAQS,WAAW;gBAC1C,IAAI3C,WAC0B,MAAzB0C,QAAQlP,QAAQ,QAAe0N,WAAW,gBAAgB3Q,KAAKmS,YAAyB,QAAZA,UAC/ED,OAAOP,QAAQtF,OAAO+F,YAAY,GAAG;oBACpCE,IAAI,IAAIvS,OAAOoS,SAAStS,KAAKf,SAAS,MAAM;oBAC5CyT,SAAQ;oBACRC,cAAa;oBACbC,qBAA8B9Q,MAAd0Q,YAA0B,WAAWA,UAAUK,QAAQP;oBACvErT,QAAQ;oBACR4T,KAAKP;oBACLnO,kBAAarC;oBACbgR,WAAWR;sBAGRxB,YAASwB,UAAUA,QAAQA,QAAQpO,SAAS,KAChD9C,EAAEmG,KAAK+K,QAAQtG,MAAM,KAAK,SAAUxE,KAAKuL;oBACxCP,YAAYH,OAAOP,QAAQS,WAAW,IACtCF,OAAOP,QAAQtF,OAAO+F,YAAY,GAAG;wBACpCE,IAAI,SAAStS,KAAMH,KAAKsG,0BAA0ByM,QAAS,IAAI7S,OAAO,OAAOF,KAAKsG,0BAA0ByM,QAAQ,KAAK/S,KAAKf,SAAS,MAAM,MAAM;wBACnJyT,SAAQ;wBACRC,cAAa;wBACbC,qBAA8B9Q,MAAd0Q,YAA0B,WAAYA,UAAUK,QAAQE,SAA6B,MAArBP,UAAS;wBACzFvT,QAAQ;wBACR4T,KAAK7S,KAAKsG,0BAA0ByM;wBACpC5O,kBAA6CrC,MAAhC9B,KAAKsG,yBAAuCyM,YAAOjR;wBAChEgR,YAAYhC,UAAU,MAAM,MAAMiC;;qBAIrCjC,WAAU,QACJ;oBACN,IAAIkC,WAAWhT,KAAKL,cAAcK,KAAKL,YAAY2S,gBAAWxQ,MAAcjD,UAAU8D,UAAUhD,YAAY2S;oBACxGU,YAAYlC,UACfuB,OAAOP,QAAQtF,OAAO+F,YAAY,GAAG;wBACpCE,IAAIO,QAAQhU,YAAwC,mBAArBgU,QAAQhU,YAAwB,IAAIkB,OAAO8S,QAAQhU,WAAWgB,KAAKf,SAAS,MAAM,MAAM,IAAI;4BAC1H2C,KAAKzB,OAAO6S,QAAQhU;yBADkG,KAEnH,IAAIkB,OAAO;wBACfwS,SAAQ;wBACRC,cAAa;wBACbC,qBAA8B9Q,MAAd0Q,YAA0B,WAAWA,UAAUK,SAASG,QAAQhM,oBAAoBsL;wBACpGrT,QAAQ+T,QAAQ/T;wBAChB4T,KAAKG,QAAQhM,oBAAoBsL;wBACjCnO,aAAa6O,QAAQ7O;wBACrB2O,WAAWR;0BAGZD,OAAOP,QAAQtF,OAAO+F,YAAY,GAAG;wBACpCE,IAAI,SAAStS,KAAMH,KAAKsG,0BAA0BgM,WAAY,IAAIpS,OAAO,OAAOF,KAAKsG,0BAA0BgM,WAAW,KAAKtS,KAAKf,SAAS,MAAM,MAAM;wBACzJyT,SAAQ;wBACRC,cAAa;wBACbC,qBAA8B9Q,MAAd0Q,YAA0B,WAAYA,UAAUK,QAAQP,YAAgC,MAArBE,UAAS;wBAC5FvT,QAAQ;wBACR4T,KAAK7S,KAAKsG,0BAA0BgM;wBACpCnO,kBAA6CrC,MAAhC9B,KAAKsG,yBAAuCgM,eAAUxQ;wBACnEgR,YAAYhC,UAAU,MAAM,MAAMwB;wBAEnCxB,WAAU;;;YAKb,SAASmC,kBAAkBhD;gBACtBA,aAAaA,UAAU6B,WAC1B1Q,EAAEmG,KAAK0I,UAAU6B,SAAS,SAAUtK,KAAK0L;oBACxC,IAAIC,YAAYlD,UAAU6B,QAAQtK,MAAM;0BACrB1F,MAAdqR,kBAAkDrR,MAAtBqR,UAAUrB,YAAoD,MAA3BqB,UAAUvB,iBAA4BsB,SAASA,MAAMxB,YACxHwB,MAAMxB,WAAU;oBACX9B,cACJwC,qBAAqBc,OAAOlT,KAAKsE,YAAY,IAAI,KACzB,MAApB4O,MAAMnB,aACTK,qBAAqBc,OAAOlT,KAAKsE,YAAY;oBAIhD2O,kBAAkBC;;;YAKrB,SAASE;gBACR,IAAwB,IAApBjC,WAAWjN;oBAGd,IAFAoN,sBAAsBH,WAAWA,WAAWjN,SAAS,IACrDkO,qBAAqBd,qBAAqBJ;oBACtCI,oBAAoBO,cAAc;wBACrCN,aAAaJ,WAAWR;wBACxB,KAAK,IAAI0C,OAAO,GAAGA,OAAO9B,WAAWO,QAAQ5N,QAAQmP,QAChD9B,WAAWO,QAAQuB,MAAM3B,YAASH,WAAWO,QAAQuB,MAAM3B,WAAU;wBAElD,IAApBP,WAAWjN,UACdoN,sBAAsBH,WAAWA,WAAWjN,SAAS;wBACrDoN,oBAAoBQ,QAAQhG,KAAKyF,eAEjCR,aAAae,QAAQhG,KAAKyF;;uBAI5Ba,qBAAqBrB,cAAcG;;YAIrC,SAASoC,cAAcrD;gBACtB,SAASsD,cAAcC;oBAStB,OARIA,OAAOxT,KAAKoE,eAAe,KAC9BoP,KAAKxT,KAAKoE,eAAe,KACfoP,OAAOxT,KAAKoE,eAAe,KACrCoP,KAAKxT,KAAKoE,eAAe,KACfoP,OAAOxT,KAAKsE,YAAY,KAClCkP,KAAKxT,KAAKsE,YAAY,KACZkP,OAAOxT,KAAKsE,YAAY,OAAIkP,KAAKxT,KAAKsE,YAAY;oBAEtDkP;;gBAIR,KAAK,IAAIvC,SADThB,UAAU6B,UAAU7B,UAAU6B,QAAQ9B,WACpBC,UAAU6B,SAC3B,IAAI7B,UAAU6B,QAAQtD,eAAeyC,QAAQ;oBAC5C,IAAIwC,WAAWC,SAASzC;oBACxB,IAAIhB,UAAU6B,QAAQb,OAAOW,gBAAgB3B,UAAU6B,QAAQ2B,WAAW,MAAMxD,UAAU6B,QAAQ2B,WAAW,GAAG/B,SAAS;wBACxH,IAAIiC,KAAK1D,UAAU6B,QAAQb;wBAC3BhB,UAAU6B,QAAQtF,OAAOyE,OAAO,IAChChB,UAAU6B,QAAQtF,OAAOiH,WAAW,GAAG,GAAGE;;yBAEF7R,MAArCmO,UAAU6B,QAAQb,OAAOa,UAC5B7B,UAAU6B,QAAQb,SAASqC,cAAcrD,UAAU6B,QAAQb,UAE3DhB,UAAU6B,QAAQb,SAASsC,cAActD,UAAU6B,QAAQb;;gBAK9D,OAAOhB;;YAGR,SAAS2D,SAAS9B;gBACjB,IAAI+B,aAAa,IAAI7C,WAAU;gBAG/B,OAFA6C,WAAW9B,aAAY,GACvB8B,WAAW/B,UAAUA,SACd+B;;YAGR,SAASC;gBAIR,IAFAzC,eAAeF,WAAWR,OAC1BU,aAAaU,aAAY,QACJjQ,MAAjBuP,cACH,IAAwB,IAApBF,WAAWjN;oBAGd,IAFAoN,sBAAsBH,WAAWA,WAAWjN,SAAS,IACrDoN,oBAAoBQ,QAAQhG,KAAKuF;oBAC7BC,oBAAoBO,cAAc;wBACrCN,aAAaJ,WAAWR;wBACxB,KAAK,IAAI0C,OAAO,GAAGA,OAAO9B,WAAWO,QAAQ5N,QAAQmP,QACpD9B,WAAWO,QAAQuB,MAAM3B,WAAU;wBACnCH,WAAWO,QAAQuB,MAAMrB,mBAAkB;wBAEpB,IAApBb,WAAWjN,UACdoN,sBAAsBH,WAAWA,WAAWjN,SAAS;wBACrDoN,oBAAoBQ,QAAQhG,KAAKyF,eAEjCR,aAAae,QAAQhG,KAAKyF;;uBAI5BR,aAAae,QAAQhG,KAAKuF,oBAG3B+B;;YAIF,SAASW,gBAAgBjC;gBACxB,IAAIN,YAAYM,QAAQnB;gBAIxB,OAHIa,UAAUI,iBACbJ,YAAYoC,SAAS,EAAC9B,QAAQnB,OAAOa;gBAE/BA;;YAOR,KAJI5B,cACH5P,KAAKoE,eAAe,UAAKtC,GACzB9B,KAAKoE,eAAe,UAAKtC,IAElBmP,QAAQrB,YAAYiB,eAAemD,KAAKtU,QAAQkR,UAAUoD,KAAKtU,SAAQ;gBAG9E,IAFAwR,IAAID,MAAM,IAENrB,WACH,QAAQsB,EAAEV,OAAO;kBAEhB,KAAK;oBACJU,IAAI;oBACJ;;kBACD,KAAK;kBACL,KAAK;oBACJA,IAAI,MAAMA,IAAI;oBACd;;kBACD,KAAK;oBAEJ,IAA0B,MAAtBC,WAAWjN,QAAc;wBAC5B,IAAI+P,gBAAgBL,SAAS7C,aAAae;wBAC1CmC,cAAclC,aAAY,GAC1BZ,WAAWrF,KAAKmI,gBAChBlD,aAAae,UAAU;wBACvBL,mBAAkB;;oBAGnB;;gBAIH,IAAIX,SACHsC,oBAGD,QAAQlC,EAAEV,OAAO;kBAChB,KAAK;oBACJ;;kBACD,KAAK;oBACJ;;kBACD,KAAK;oBACJ;;kBACD,KAAK;oBACJ;;kBACD,KAAKxQ,KAAKwE;oBACTsM,WAAU,GACNlB,aACHwD;oBAED;;kBAED,KAAKpT,KAAKoE,eAAe;kBACzB,KAAKpE,KAAKsE,YAAY;oBACrBwP;oBACA;;kBACD,KAAK9T,KAAKoE,eAAe;oBAExB+M,WAAWrF,KAAK,IAAIkF,WAAU,IAAO;oBACrC;;kBACD,KAAKhR,KAAKsE,YAAY;oBAErB6M,WAAWrF,KAAK,IAAIkF,WAAU;oBAC9B;;kBACD,KAAKhR,KAAKqE,iBAAiB;oBAE1B,IAAI4N,aAAa,IAAIjB,WAAU,IAAO,IAAO;oBAE7CE,IAAIA,EAAErQ,QAAQ,SAAS;oBACvB,IAAIqT,MAAMhD,EAAElF,MAAM,MACjBmI,KAAKD,IAAI,GAAGlI,MAAM,MAClBoI,MAAMC,MAAMF,GAAG,MAAMA,GAAG,KAAKT,SAASS,GAAG,KACzCG,MAAoB,MAAdH,GAAGjQ,SAAekQ,MAAOC,MAAMF,GAAG,MAAMA,GAAG,KAAKT,SAASS,GAAG;oBACvD,QAARC,OAAuB,QAARA,QAClBA,MAAc,QAARE,MAAc,IAAI,IAEzBrC,WAAWA,aAAa;wBACvBC,KAAKkC;wBACLjC,KAAKmC;wBACLC,KAAKL,IAAI;;oBAEV,IAAIpC,UAA8B,IAApBX,WAAWjN,SAAaiN,WAAWA,WAAWjN,SAAS,GAAG4N,UAAUf,aAAae;oBAE/F,IADAb,QAAQa,QAAQnB,OACZM,MAAMY,cAAc;wBACvBC,QAAQhG,KAAKmF,QACba,UAAUb,MAAMa;wBAChB,IAAI+B,aAAa,IAAI7C,WAAU,IAC3BwD,WAAW1C,QAAQnB;wBACvBmB,QAAQhG,KAAK+H,aACb/B,UAAU+B,WAAW/B,SACrBb,QAAQuD;;oBAEJvD,MAAMS,YAKVT,QAAQ2C,SAAS,EAAC3C,WAEnBa,QAAQhG,KAAKmF,QACba,QAAQhG,KAAKmG;oBAEb;;kBACD,KAAKjS,KAAKuE;oBAGT,IAAwB,IAApB4M,WAAWjN,QAAY;wBAC1BoN,sBAAsBH,WAAWA,WAAWjN,SAAS;wBACrD,IAAIuQ,WAAWnD,oBAAoBQ,QAAQR,oBAAoBQ,QAAQ5N,SAAS;wBAG/EsN,YAFGF,oBAAoBS,mBACDjQ,MAArB2S,SAAS3C,YAA+C,MAArB2C,SAAS/C,YAA+C,MAA1B+C,SAAS5C,gBAC/DV,WAAWR,QAEXoD,gBAAgBzC,oBAAoBQ;2BAGjDN,YAAYuC,gBAAgBhD,aAAae;oBAE1C,IAAIN,UAAUK,cACbV,WAAWrF,KAAK0F,iBAUhB,IARIA,UAAUQ,mBACbT,aAAaJ,WAAWR;oBACxBa,UAAUQ,mBAAkB,KAE5BT,aAAa,IAAIP,WAAU,IAAO,IAAO,IAAO,IAEjDO,WAAWO,QAAQhG,KAAK0F;oBACxBL,WAAWrF,KAAKyF,aACZC,UAAUO,WAAW;wBACxBP,UAAUO,aAAY;wBACtB,IAAIC,kBAAkB,IAAIhB,WAAU;wBACpCgB,gBAAgBA,mBAAkB,GAClCb,WAAWrF,KAAKkG;;oBAGlB;;kBACD;oBACCoB;;;YAMH,KAFI3B,mBAAiBqC,cAEM,IAApB3C,WAAWjN,UACjBmN,eAAeF,WAAWR;YAC1BI,aAAae,QAAQhG,KAAKuF;YAW3B,OATkC,IAA9BN,aAAae,QAAQ5N,WACxB+O,kBAAkBlC,eAClBK,WAAWtF,KAAKiF;aAGb/Q,KAAKwC,gBAAgBxC,KAAKuC,UAC7B+Q,cAAclC,WAAW,KAGnBA;;QAGR9S,OAAOD,UAAU;YAChBiD,iBAAiBA;YACjBC,aAAaA;;;;;;;;;;QCrdd,IAAIH,IAAIxC,oBAAQ,IAA6CD,SAASC,oBAAQ,IAC7EyC,WAAW1C,OAAO0C,UAClBqT,KAAK/V,OAAOgW,UAAUC,WACtBC,KAA4B,IAAtBH,GAAGtR,QAAQ,YAA2C,IAAzBsR,GAAGtR,QAAQ,aAC9C0R,SAASC,sBAAsB,eAC/BC,WAAW,YAAY7U,KAAKuU,KAC5BO,SAAS,UAAU9U,KAAKuU,QAAQM;QAEjC,SAASD,sBAAsBG;YAC9B,IAAIrT,KAAKR,SAAS8T,cAAc,UAC/BC,SAAS,OAAOF,WAChBG,cAAeD,UAAUvT;YAM1B,OALKwT,gBACJxT,GAAGyT,aAAaF,QAAQ,YACxBC,cAAoC,qBAAfxT,GAAGuT;YAEzBvT,KAAK,MACEwT;;QAKR/W,OAAOD,UAAU,SAASmD,UAAU+T,WAAW1V,SAASG;YACvDH,UAAUA,WAAW+B,KAAK/B,SAC1BG,OAAOA,QAAQ4B,KAAK5B;YAEpB,IAAI0H,YAAY9F,MACfC,KAAKD,KAAKC,IACVU,QAAQX,KAAKW,UAAUX,KAAKW,QAAQvC,KAAKwC,eACzCgT,WACAC,KACAC,qBAAoB,GACpBC,kBAAiB,GACjBC,aAAY,GACZC,WACAC,cAAa,GACblP,WACAmP,qBACAC,aAAa;YAGd,SAASC,gBAAgBC,aAAaC,YAAYC,aAAaC,OAAOC;gBAGrE,IAAI7V,SAAST,KAAKS;gBACd6V,sBAAmBtW,KAAKS,UAAS,IACrC0V,aAAaA,cAAc;gBAC3B,IAAII,eAAe,IAClBC,WAAW1W,MAAM,GACjBK,MAAMsW;gBACP,GAAG;oBACF,KAAoB,MAAhBP,eAAwBrW,QAAQqQ,eAAepQ,MAClD2W,UAAWH,sBAAuE,MAAlDzW,QAAQqQ,eAAepQ,KAAKmR,MAAM0B,oBAC1B7Q,MAApCjC,QAAQqQ,eAAepQ,MAAM,QACmB,MAA/CD,QAAQqQ,eAAepQ,KAAK4W,kBAA4B7W,QAAQqQ,eAAepQ,KAAK6I,SAAS3I,KAAKyF,6BAAmC,IAAN3F,OACjI6W,sBAAsB7W,KAAK8W,SAAS9W,KAAK0W,WAAW1W,MAAM,MAC1DD,QAAQqQ,eAAepQ;oBAC1BK,OAAOsW,QAAQxF,OACfuF,YAAYC,QAAQI,QAAQ7I,SAC5BuI,aAAazK,MAAqB,MAAhBsK,cAAuBK,QAAQ9N,SAAwB,MAAhByN,cAAwBjW,KAAK2S,YAAYgE,eAAehX,KAAKK,aAChH;wBACNsW,UAAUM,gBAAgBjX,KAAK0W,WAAW1W,MAAM,IAChDK,OAAOsW,QAAQxF,OACfuF,YAAYC,QAAQI,QAAQ7I;wBAC5B,IAAIzH,cAAuB,MAAV8P,WAA8C,MAApBrW,KAAKuG,aAAuBvG,KAAKuG,aAAapG,KAAKoU;0BAC3E,MAAfhO,mBAAuCzE,MAAfyE,cAAoE,mBAAfA,cAA2ByQ,SAASzQ,eAA4BzG,MAAbyG,eACnIgQ,aAAazK,MAAqB,MAAhBsK,cAAwBjW,KAAK2S,YAAYgE,eAAehX,KAAKK;;oBAGzD,WAApBH,KAAK8F,cACJ3F,KAAKyS,mBAAkC,MAAhBzS,KAAI,WAC9BH,KAAK8F,aAAahG,MAAM;oBAI1BA;+BACuBgC,MAAd+T,aAA2B/V,MAAM+V,gBAA+B,MAAhB1V,KAAI,UAAiC,OAAbA,KAAK0S,QAA4B/S,MAAbqW;gBAWtG,OAV8C,OAA1CI,aAAaA,aAAarS,SAAS,MACtCqS,aAAa5F,QAEM,MAAhByF,oBACoBtU,MAAvBjC,QAAQyQ,eAERzQ,QAAQyQ,aAAaxQ,MAAM;gBAG5BE,KAAKS,SAASA,QACP8V;;YAGR,SAASU,aAAaC;gBACrBrX,QAAQI,cAAS6B,IACJ,MAAToV,SACHrX,QAAQqQ,iBAAiB,IACzBrQ,QAAQ2D,IAAI;;YAId,SAAS2T,qBAAqBC,WAAWrX,QAAQmQ;gBAChD,IAAImH,UAAU,GACbC,SAAS,GACTC,SAASrH,kBAAkBrQ,QAAQqQ;gBAEpC,KAAK,IAAIsH,eADS1V,MAAdsV,cAAyBA,aAAa,IACvBG,QAAQ;oBAC1B,IAAIE,QAAQ/D,SAAS8D;oBACjBD,OAAOE,WAAW1X,WAA2C,MAAjCwX,OAAOE,OAAOf,oBACzCe,SAASL,cAAWC,SAASI;oBACpBL,aAATK,UAAoBH,QAAQG;;gBAGlC,QAAoB,MAAZJ,UAAiBA,UAAUD,YAAaE,SAAkB,KAAVA,QAAcD,SAAUD,YAAYC,SAAWC,QAAQF,YAAaC,SAASC;;YAGtI,SAASI,iBAAiBC;gBACzB,IAAIC,gBAAgBD,IAAId,QAAQc,IAAIE;gBAIpC,OAH4B,mBAAjBD,iBAAoD,IAAvBA,cAAc1T,WACrD0T,gBAAgBA,cAAc5L,MAAM,KAAK;qBAEjBlK,MAAlB8V,gBAA8BA,cAAcE,aAAa;;YAGjE,SAASC,WAAWJ,KAAKK;gBACxB,IAAInB,WAA8B/U,QAAnB6V,IAAIE,cAA2BF,IAAIM,KAAKP,iBAAiBC,QAAQA,IAAId,SAASxN,KAAK;gBAClG,IAAgB,OAAZwN,SAAgB,MAAOA,QAAQ3S,SAAS8T,SAAOnB,WAAW;gBAC9D,OAAOA;;YAGR,SAASF,sBAAsB7W,KAAKsQ;gBACnCtQ,MAAY,IAANA,MAAUA,MAAM,IAAI;gBAE1B,KADA,IAAIoY,UAAUC,QAAQrY,MAAMsY,gBAAgBL,WAAWG,UAAUG,YAAYC,SAASC,WAC7E/Q,MAAM,GAAGA,MAAM4I,MAAMlM,QAAQsD,OAAO;oBAC5C,IAAImQ,MAAMvH,MAAM5I;oBAChB6Q,aAAaN,WAAWJ,KAAKS,cAAclU;oBAC3C,IAAIsU,WAAWC,KAAKC,IAAIL,aAAaD;0BACrBtW,MAAZwW,WACgB,OAAfD,cAAqBG,WAAWF,WAChCC,cAAcvY,KAAKS,UAAU8X,UAAUtH,MAAM0B,eAAkD,aAAnC4F,UAAUtH,MAAM2B,oBAAiC+E,IAAI1G,MAAM0B,gBAAgBgF,IAAI1G,MAAM2B,mBACjJ2F,aAAaA,UAAUtH,MAAM0H,uBAAuBhB,IAAI1G,MAAM0H,wBAClEL,UAAUE;oBACVD,YAAYZ;;gBAId,OAAOY;;YAIR,SAASxB,gBAAgBjX,KAAK0W,WAAWoC;gBACxC,OAAO/Y,QAAQqQ,eAAepQ,QAAQ6W,sBAAsB7W,KAAK8W,SAAS9W,KAAK0W,YAAYA,UAAUxI,UAAUwI,WAAWoC;;YAG3H,SAAST,QAAQrY,KAAKsQ;gBACrB,OAAIvQ,QAAQqQ,eAAepQ,OACnBD,QAAQqQ,eAAepQ,QAEvBsQ,SAASwG,SAAS9W,MAAM;;YAGjC,SAAS+Y,2BAA2B/Y,KAAK+S;gBAGxC,KAFA,IAAIiG,SAAQ,GACX1I,QAAQwG,SAAS9W,MACTiZ,OAAO,GAAGA,OAAO3I,MAAMlM,QAAQ6U,QACvC,IAAI3I,MAAM2I,MAAM9H,SAASb,MAAM2I,MAAM9H,MAAM4B,QAAQA,KAAK;oBACvDiG,SAAQ;oBACR;;gBAQF,QALc,MAAVA,cAC4BhX,MAA3BjC,QAAQ0Q,UAAUzQ,SACrBgZ,QAAQD,2BAA2B/Y,MAAMD,QAAQ0Q,UAAUzQ,MAAM+S;gBAG5DiG;;YAIR,SAASlC,SAAS9W,KAAK0W,WAAWoC;gBACjC,IAAIxH,aAAavR,QAAQoQ,WACxBwG,UAAUD,YAAYoC,QAAQ,GAC9BI,iBAAiBxC,YAAYA,UAAUxI,UAAU,EAAC,KAClD8D,UAAU,IACVmH,cAAa,GACbC,aACAC,kBAAkB3C,YAAYA,UAAUnN,KAAK,MAAM;gBAEpD,SAAS+P,qBAAqBnJ,WAAW+I,gBAAgBK,SAASC;oBACjE,SAASC,YAAYtI,OAAOoI,SAASC;wBACpC,SAASE,aAAaN,aAAaO;4BAClC,IAAIC,aAA4D,MAA/CtY,EAAEgN,QAAQ8K,aAAaO,WAAW3H;4BASnD,OARK4H,cACJtY,EAAEmG,KAAKkS,WAAW3H,SAAS,SAAUtK,KAAKyJ;gCAIzC,KAH2B,MAAvBA,MAAMW,eACT8H,aAAaF,aAAaN,aAAaO,WAAW3H,QAAQtK,MAAM,MACtDyJ,MAAMzC,eAAe,eAAYkL,aAAaF,aAAaN,aAAajI;gCAC/EyI,YAAY,QAAO;gCAGlBA;;wBAGR,SAASC,sBAAsB7Z,KAAK8Z,cAAcC;4BACjD,IAAItB,WAAWuB;4BAgBf,KAdIja,QAAQuQ,MAAMtQ,QAAQD,QAAQqQ,eAAepQ,SAChDsB,EAAEmG,KAAK1H,QAAQuQ,MAAMtQ,QAAQ,EAACD,QAAQqQ,eAAepQ,QAAO,SAAU0H,KAAKuL;gCAC1E,IAAIA,KAAKkF,KAAK2B,eAEb,OADArB,YAAYxF,OACL;gCAER,IAAI8E,mBAAoC/V,MAAtB+X,oBAAkCA,oBAAoB9G,KAAK8E,aAC5EkC,cAAuCjY,MAA9BiR,KAAK8D,QAAQgB,eAA6B9E,KAAK8D,QAAQgB,aAAaC,WAAW1U,QAAQwW,iBAAiB;sCAChG9X,MAAbgY,YAA0BC,SAASD,cAAyB,MAAZC,WACpDxB,YAAYxF;gCACZ+G,WAAWC;gCAIVxB,WAAW;gCACd,IAAIyB,oBAAoBzB,UAAU1B,QAAQ0B,UAAUV,cAChDhB,UAAU0B,UAAUN,KAAK2B,iBAAiBrB,UAAUN,KAAK+B,sBAAsBzB,UAAU1B;gCAC7F,OAAOA,QAAQ7I,YAA6BlM,MAAtB+X,oBAAkCA,oBAAoBtB,UAAUV,eAAe;;4BAErG,YAA6B/V,MAAtB+X,oBAAkCF,sBAAsB7Z,KAAK8Z,qBAAgB9X;;wBAItF,SAASmY,WAAWC,QAAQpL;4BAC3B,SAASqL,OAAOC;gCAEf,KADA,IAAIC,WAAW,IAAIC,SAAS,GAAGC,KACtB7b,IAAI,GAAG8b,IAAIJ,QAAQlW,QAAQxF,IAAI8b,GAAG9b,KAC1C,IAA0B,QAAtB0b,QAAQ5J,OAAO9R,IAElB,KADA6b,MAAMH,QAAQK,WAAW/b,IAAI,MACpB4b,QAAQC,OAAKF,SAASvO,KAAK4O,OAAOC,aAAaL,cAExDA,QAAQF,QAAQK,WAAW/b;gCAC3B2b,SAASvO,KAAKsO,QAAQ5J,OAAO9R;gCAG/B,OAAO2b,SAAShR,KAAK;;4BAGtB,OAAIrJ,KAAKV,UAAiC,MAAxB4a,OAAOjJ,MAAP,WAAwD,MAAxBnC,OAAOmC,MAAP,UACkE,MAA5GkJ,OAAOrL,OAAOmC,MAAM4B,IAAIhS,QAAQ,UAAU,KAAKuC,QAAQ+W,OAAOD,OAAOjJ,MAAM4B,IAAIhS,QAAQ,UAAU,QAElGqZ,OAAOjJ,MAAM4B,QAAQ/D,OAAOmC,MAAM6B;;wBAG1C,SAAS8H,yBAAyBV,QAAQpL;4BACzC,IAAI+L,OAAOX,OAAOrD,QAAQ7I,MAAMkM,OAAOrC,aAAaxO,KAAK,KACxDyR,OAAOhM,OAAO+H,QAAQ7I,MAAMc,OAAO+I,aAAaxO,KAAK,KAAK0R,WAAWF,QAAQC;4BAG9E,OAFAC,cAAWA,aAAoC,MAAxBb,OAAOjJ,MAAP,WAAwD,MAAxBnC,OAAOmC,MAAP,WAA+BnC,OAAOmC,MAAMwB,GAAGtS,KAAK+Z,OAAOjJ,MAAM4B,KAAKhT,SAASC,MAAK,GAAOE,OAAM;4BAEjJ+a;;wBAIR,SAASC,iBAAiBC,aAAaC;4BACtC,SAAiBpZ,MAAboZ,YAA2BD,YAAYpD,gBAAgBqD,SAASrD,gBAC0C,MAA7GoD,YAAYpE,QAAQoE,YAAYpD,aAAaC,WAAW1U,QAAQ8X,SAASrE,QAAQqE,SAASrD,eAAuB;gCACjHoD,YAAYhD,OAAOgD,YAAYhD,QAAQ;gCACvC,IAAIkD,SAASF,YAAYpE,QAAQoE,YAAYpD;gCAC7C,SAAe/V,MAAXqZ,QAEG;oCAGN,IAFsB,mBAAXA,WAAqBA,SAASA,OAAOnP,MAAM,KAAK,UAC1BlK,MAA7BmZ,YAAYhD,KAAKkD,YAAuBF,YAAYhD,KAAKkD,UAAUF,YAAYpE,QAAQ7I;yCAC1ElM,MAAboZ,UAAwB;wCAC3B,KAAK,IAAI1T,OAAO0T,SAASjD,MACL,mBAARzQ,QAAkBA,MAAMA,IAAIwE,MAAM,KAAK;6CACpBlK,MAA1BmZ,YAAYhD,KAAKzQ,SAAoByT,YAAYhD,KAAKzQ,OAAO0T,SAASjD,KAAKzQ;wCAEhFyT,YAAYpE,QAAQoE,YAAYpD,eAAe7T,OAAOC,KAAKgX,YAAYhD,MAAM5O,KAAK;;oCAEnF,QAAO;;gCAXP4R,YAAYpD,mBAAc/V;;4BAc5B,QAAO;;wBAGR,IAAc,MAAV2U,gBAAuC3U,MAAtBwX,mBACpB,MAAM,wJAAwJzZ,QAAQH;wBAEvK,IAAI+W,YAAY3W,YAAyBgC,MAAlBmP,MAAMa,SAO5B,OANAA,QAAQhG,KAAK;4BACZmF,OAASA;4BACT4F,SAAWwC,QAAQrJ;4BACnBoL,IAAMjC;4BACNlB,MAAQ;6BAEF;wBACD,SAAsBnW,MAAlBmP,MAAMa;4BAChB,IAAIb,MAAMS,WAAW4H,sBAAsBrI;gCAE1C,IADAA,QAAQsI,YAAYtJ,UAAU6B,QAAQ1Q,EAAEgN,QAAQ6C,OAAOhB,UAAU6B,WAAW,IAAIuH,SAASC;gCACrFrI,OAAO,QAAO;mCACZ,IAAIA,MAAMU,YAAY;gCAC5B,IAAI0J,gBAAgBpK,OAAOqK,WAAWxJ,QAAQ5N;gCAE9C,IADA+M,QAAQmI,qBAAqBnI,OAAO+H,gBAAgBK,SAASC;gCACzDrI,OAAO;oCAQV,IANA7P,EAAEmG,KAAKuK,SAAS,SAAUtK,KAAK+T;wCACnBD,YAAP9T,QACH+T,KAAKtK,MAAM0B,eAAc;wCAG3BuG,cAAcpH,QAAQA,QAAQ5N,SAAS,GAAG+M,YAChBnP,MAAtBwX,sBAAmCE,aAAaN,aAAamC,gBAIhE,QAAO;oCAHPpC,cAAa,GACbxC,UAAU3W;;mCAKN,IAAImR,MAAMY,cAAc;gCAC9B,IAAI2J,iBAAiBvK,OACpBwK,oBAAoB,IACpBC,aACAC,iBAAiB7J,QAAQ9D,SACzB4N,aAAavC,QAAQnV,QAClB2X,WAAmC,IAAxB7C,eAAe9U,SAAa8U,eAAe8C,WAAW;gCACrE,KAAkB,MAAdD,YAAuC,mBAAbA,UAAuB;oCACpD,IAAIE,aAAatF,SAChBuF,sBAAsBhD,eAAehL,SACrCiO,cAAc,IACdC;oCACD,IAAuB,mBAAZL,UACVI,cAAcJ,SAAS7P,MAAM,WAE7B,KAAKkQ,QAAQ,GAAGA,QAAQV,eAAe1J,QAAQ5N,QAAQgY,SACtDD,YAAYnQ,KAAKoQ,MAAMpE;oCAIzB,IAAIjY,QAAQwQ,SAASvQ,MAAM;wCAE1B,KADA,IAAIqc,mBAAmBF,YAAYjO,SAC1BtP,IAAI,GAAGmD,KAAKhC,QAAQwQ,SAASvQ,KAAKoE,QAAQxF,IAAImD,IAAInD,KAC1Dud,YAAYzP,OAAOyP,YAAY7Y,QAAQvD,QAAQwQ,SAASvQ,KAAKpB,GAAGoZ,aAAa;wCAEnD,MAAvBmE,YAAY/X,WACfrE,QAAQwQ,SAASvQ,YAAOgC,GACxBma,cAAcE;;sCAGQ,MAApBnc,KAAK8F,cAAwBkR,SAAStD,SAAS1T,KAAK8F,gBAAgBiW,cAAc/b,KAAK8F,gBAAamW,cAAcA,YAAYjO,MAAM,GAAG;oCAE3I,KADA,IAAIoO,wBAAuB,GAClB5U,MAAM,GAAGA,MAAMyU,YAAY/X,QAAQsD,OAAO;wCAClD0U,QAAQxI,SAASuI,YAAYzU,OAC7BsK,UAAU,IAEVkH,iBAAqC,mBAAb6C,YAAwBlC,sBAAsBlD,SAASyF,OAAON,eAA6CI,oBAAoBhO;wCACnJwN,eAAe1J,QAAQoK,UAAU3C,YAAYiC,eAAe1J,QAAQoK,QAAQ,EAACA,QAAOG,OAAOhD,UAAUC,qBACxGrI,SAAQ,IACU,MAARzJ,QACV4U,wBAAuB;wCAGxBV,cAAc5J,QAAQ9D,SACtByI,UAAUsF,YACVjK,UAAU;wCAGV,KAAK,IAAIwK,OAAO,GAAGA,OAAOZ,YAAYxX,QAAQoY,QAAQ;4CACrD,IAAIpB,WAAWQ,YAAYY,OAC1BC,aAAY;4CACbrB,SAASjK,MAAMsD,MAAM2G,SAASjK,MAAMsD,OAAO6H,sBAC3ClB,SAASrD,cAAcqD,SAASrD,eAAe+D;4CAC/CZ,iBAAiBE;4CACjB,KAAK,IAAIsB,OAAO,GAAGA,OAAOf,kBAAkBvX,QAAQsY,QAAQ;gDAC3D,IAAIC,YAAYhB,kBAAkBe;gDAClC,IAAwB,mBAAbX,iBAAmD/Z,MAAzBoZ,SAASrD,gBAA4G,MAA/EzW,EAAEgN,QAAQ8M,SAASrE,QAAQqE,SAASrD,aAAaC,YAAYmE,cAAsB;oDAC7J,IAAIf,SAASjK,MAAM6B,cAAc2J,UAAUxL,MAAM6B,WAAW;wDAC3DyJ,aAAY,GACZvB,iBAAiByB,WAAWvB;wDAC5B;;oDACM,IAAIjB,WAAWiB,UAAUuB,YAAY;wDACvCzB,iBAAiBE,UAAUuB,eAC9BF,aAAY,GACZd,kBAAkBjP,OAAOiP,kBAAkBrY,QAAQqZ,YAAY,GAAGvB;wDAEnE;;oDACM,IAAIjB,WAAWwC,WAAWvB,WAAW;wDAC3CF,iBAAiByB,WAAWvB;wDAC5B;;oDACM,IAAIN,yBAAyBM,UAAUuB,YAAY;wDACrDzB,iBAAiBE,UAAUuB,eAE9BF,aAAY,GACZd,kBAAkBjP,OAAOiP,kBAAkBrY,QAAQqZ,YAAY,GAAGvB;wDAEnE;;;;4CAIEqB,aACJd,kBAAkB3P,KAAKoP;;;oCAK1BpJ,UAAU6J,eAAeU,OAAOZ,oBAChChF,UAAU3W,KACVmZ,aAA8B,IAAjBnH,QAAQ5N;oCACrB+M,QAAmC,IAA3BwK,kBAAkBvX,QAG1B8U,iBAAiBgD,oBAAoBhO;uCAErCiD,QAAQsI,YAAYiC,eAAe1J,QAAQ+J,aAAa5L,UAAU6B,QAAQ+J,WAAW,EAACA,WAAUQ,OAAOhD,UAAUC;gCAElH,IAAIrI,OAAO,QAAO;mCACZ,IAAIA,MAAMW,gBAAgB0H,sBAAsBrJ,UAAU6B,QAAQ1Q,EAAEgN,QAAQ6C,OAAOhB,UAAU6B,WAAW,IAE9G,KADA,IAAI6B,KAAK1C,OACAyL,OAAgC,IAAxB1D,eAAe9U,SAAc8U,eAAe8C,UAAU,GAAIY,QAAQrI,MAAMV,GAAG1B,WAAWE,OAAOuK,OAAO,IAAI/I,GAAG1B,WAAWE,QAASsE,WAAW3W,KAAK4c,QAAQ;gCACvK,IAAIjD,aAAaxJ,UAAU6B,QAAQ1Q,EAAEgN,QAAQuF,IAAI1D,UAAU6B,WAAW;gCAEtE,IADAb,QAAQsI,YAAYE,YAAY,EAACiD,OAAML,OAAOhD,UAAUI,aACpDxI,OAAO;oCAQV,IANAiI,cAAcpH,QAAQA,QAAQ5N,SAAS,GAAG+M,OAG1CiI,YAAYP,qBAAqB+D,QAAQ/I,GAAG1B,WAAWC;oCAEvDgH,YAAY3E,OAAOmI,QAAQ,KAAKjD,WAAW3H,QAAQ1O,QAAQ8V,gBAAgBvF,GAAG1B,WAAWsC;oCACrF2E,YAAYP,sBAAsBa,aAAaN,aAAaO,aAAa;wCAC5ER,cAAa,GACbxC,UAAU3W;wCACV;;oCAMD,OAJIoZ,YAAY3E,QAEf1U,QAAQ0Q,UAAUzQ,OAAO2Z,WAAW3H,QAAQ5N,SAASuV,WAAW3H,QAAQ1O,QAAQ8V;qCAE1E;;mCAKT,IADAjI,QAAQmI,qBAAqBnI,OAAO+H,gBAAgBK,SAASC;4BACzDrI,OAAO,QAAO;+BAGnBwF;;oBAKF,KAAK,IAAIsC,OAAgC,IAAxBC,eAAe9U,SAAa8U,eAAe8C,UAAU,GAAI/C,OAAO9I,UAAU6B,QAAQ5N,QAAQ6U,QAC1G,KAA6C,MAAzC9I,UAAU6B,QAAQiH,MAAMnH,cAAuB;wBAClD,IAAIX,QAAQsI,YAAYtJ,UAAU6B,QAAQiH,OAAO,EAACA,OAAMsD,OAAOhD,UAAUC;wBACzE,IAAIrI,SAASwF,YAAY3W,KACxB,OAAOmR;wBACD,IAAcnR,MAAV2W,SACV;;;gBAMJ,SAASkG,cAAc7c,KAAKsQ;oBAC3B,IAAIyG,UAAU;oBAsBd,OArBKzV,EAAE8M,QAAQkC,WAAQA,QAAQ,EAACA,UACb,IAAfA,MAAMlM,gBACoBpC,MAAzBsO,MAAM,GAAGyH,gBAAiD,MAApB7X,KAAK8F,cAC9C+Q,UAAUF,sBAAsB7W,KAAKsQ,MAAMpC,SAAS6I,QAAQ7I;oBACrC,MAAnB6I,QAAQ3S,WAAc2S,UAAUzG,MAAM,GAAGyG,QAAQ7I,YAErD5M,EAAEmG,KAAK6I,OAAO,SAAU5I,KAAKmQ;wBAC5B,IAAgB,OAAZA,IAAI9E,KACP,IAAuB,MAAnBgE,QAAQ3S,QACX2S,UAAUc,IAAId,QAAQ7I,cAEtB,KAAK,IAAItP,IAAI,GAAGA,IAAImY,QAAQ3S,QAAQxF,KAC/BiZ,IAAId,QAAQnY,OAAyD,MAAnDmY,QAAQnY,GAAGoZ,WAAW1U,QAAQuU,IAAId,QAAQnY,QAC/DmY,QAAQnY,MAAM,MAAMiZ,IAAId,QAAQnY;yBAQhCmY;;gBAGR,KAAW,IAAP/W,aAA2BgC,MAAd+T,aAA2B/V,MAAM+V,YAAY;oBAC7D,SAAkB/T,MAAd0U,WAAyB;wBAG5B,KAFA,IAAIoG,cAAc9c,MAAM,GACvBK,WACqF2B,OAA9E3B,OAAON,QAAQqQ,eAAe0M,gBAAgB/c,QAAQuQ,MAAMwM,kBAA8C,IAAfA,eAClGA;6BAEY9a,MAAT3B,SAAqC,IAAfyc,gBACzB5D,iBAAiB2D,cAAcC,aAAazc;wBAC5CgZ,kBAAkBH,eAAe3P,KAAK,KACtCoN,UAAUmG;;oBAGZ,IAAI/c,QAAQuQ,MAAMtQ,QAAQD,QAAQuQ,MAAMtQ,KAAK,GAAGsb,OAAOjC,iBACtD,OAAOtZ,QAAQuQ,MAAMtQ;oBAEtB,KAAK,IAAI+c,QAAQ7D,eAAe8C,SAASe,QAAQzL,WAAWlN,QAAQ2Y,SAAS;wBAC5E,IAAI5L,QAAQmI,qBAAqBhI,WAAWyL,QAAQ7D,gBAAgB,EAAC6D;wBACrE,IAAK5L,SAASwF,YAAY3W,OAAkBA,MAAV2W,SACjC;;;gBAoBH,OAhBuB,MAAnB3E,QAAQ5N,WAAgB+U,cAC3BnH,QAAQhG,KAAK;oBACZmF,OAAO;wBACNwB,IAAI;wBACJC,SAAQ;wBACRC,cAAa;wBACb1T,QAAQ;wBACR4T,KAAK;wBACL1O,aAAa;;oBAEd0S,SAAS;oBACToB,MAAM;oBACNmD,IAAIjC;yBAIYrX,MAAd0U,aAA2B3W,QAAQuQ,MAAMtQ,OACrCsB,EAAEc,QAAO,GAAM,IAAI4P,YAE3BjS,QAAQuQ,MAAMtQ,OAAOsB,EAAEc,QAAO,GAAM,IAAI4P;gBAEjCjS,QAAQuQ,MAAMtQ;;YAGtB,SAASgd;gBAMR,YALwBhb,MAApBjC,QAAQsQ,YAEXtQ,QAAQsQ,UAAU8F,iBAAgB,GAAO;qBAClBnU,MAAnBjC,QAAQI,WAAsBJ,QAAQI,SAASJ,QAAQsQ,QAAQnC,WAE7DnO,QAAQsQ;;YAGhB,SAAS4M,UAAUC;gBAKlB,YAJuBlb,MAAnBjC,QAAQI,WAAoC,MAAZ+c,YACnCnd,QAAQI,SAASgW,iBAAgB,GAAMkB,yBAAwB;qBACvCrV,MAApBjC,QAAQsQ,YAAuBtQ,QAAQsQ,UAAUtQ,QAAQI,OAAO+N,WAE9DnO,QAAQI;;YAGhB,SAASgd,kBAAkB3C,OAAOC,KAAKta;gBACtC,IAAIvB,GAAG8E;gBACP,KAAc,MAAV8W,OACHrD,gBACApX,QAAQuQ,QAAQ,IAChBkK,QAAQ,GACRC,MAAMta,OAAOiE,aAEb,KAAKxF,IAAI4b,OAAO5b,IAAI6b,KAAK7b,YACjBmB,QAAQqQ,eAAexR;gBAIhC,KADA8E,IAAI8W,OACC5b,IAAI4b,OAAO5b,IAAI6b,KAAK7b,KAExB,IAAIuB,OAAOvB,OAAOsB,KAAKyF,2BAA2B;oBACjD,IAAIyX,YAAY7U,QAAQ7E,GAAGvD,OAAOvB,KAAIsB,KAAKmd,kBAAiB,EAACze,QAAOsB,KAAKmd,eAAeC,QAAcpd,KAAKmd,kBAAiB,EAACze,QAAOsB,KAAKmd,eAAeC;qBACtI,MAAdF,cAEH1Z,SAAwB1B,MAApBob,UAAUG,QAAsBH,UAAUG,QAAQH,UAAUpd,MAAM;;;YAM1E,SAASb,OAAO0L,MAAMxK,MAAML;gBAC3B,QAAQE,KAAKf,UAAUkB,KAAKlB;kBAC3B,KAAK;oBACJ0L,OAAOA,KAAK2S;oBACZ;;kBACD,KAAK;oBACJ3S,OAAOA,KAAK/J;oBACZ;;kBACD,KAAK;oBACJ,IAAI2c,YAAY1d,QAAQqQ,eAAepQ,MAAM;oBAE5C6K,OADW,MAAR7K,OAAayd,aAAaA,UAAU5U,UAAU+R,OAAOC,aAAa9b,UAAUyK,QAAQc,SAChFO,KAAK2S,gBAEL3S,KAAK/J;oBAEb;;kBACD;oBACC,IAAIQ,EAAE+D,WAAWnF,KAAKf,SAAS;wBAC9B,IAAIue,OAAOrP,MAAMxL,UAAUqL,MAAM5I,KAAKkI;wBACtCkQ,KAAK1R,KAAKjM,QAAQqQ,iBAClBvF,OAAO3K,KAAKf,OAAOgP,MAAMrM,MAAM4b;;;gBAIlC,OAAO7S;;YAGR,SAAS8S,sBAAsBC,SAASC,SAASC;gBAOhD,KANA,IAAIC,UAAU7d,KAAKS,SAASkd,UAAUA,QAAQ3P,MAAM,GAAG,IACtD8P,WAAU,GACVC,aAAejc,MAAP8b,KAAmBA,GAAG5R,MAAM,OAAO,IAC3CgS,OAGQtf,IAAI,GAAGA,IAAIqf,MAAM7Z,QAAQxF,MACY,OAAxCsf,QAAQN,QAAQta,QAAQ2a,MAAMrf,QAClCgf,QAAQlR,OAAOwR,OAAO;gBAIxB,KAAK,IAAIC,QAAQ,GAAGA,QAAQP,QAAQxZ,QAAQ+Z,SAC3C,KAA4C,MAAxC7c,EAAEgN,QAAQsP,QAAQO,QAAQJ,UAAiB;oBAC9CC,WAAU;oBACV;;gBAGF,OAAOA;;YAGR,SAASI,UAAUpe,KAAKqe,GAAGpe,QAAQqe,aAAaC;gBAC/C,IAAIC,eAAeld,EAAEc,QAAO,GAAM,IAAIrC,QAAQqQ,iBAC7CqO,SACA1G,aACA2G,eAAc,GAAOC,cAAa,GAClCC,QAAQC,YAAYjgB,GAAGkgB,UACvBC,aACAC,eAAsBhd,MAAZuc,UAAwBA,UAAUlH;gBAE7C,SAAS4H,eAAeC;oBACvB,IAAIA,UACCR,oBAAqB1c,MAANqc,GAAiB;wBACnC,IAAIc,YAAY9H,qBAAqBrX,OAAO;wBAC5C,KAAKpB,IAAImgB,aAAangB,IAAIyY,yBAAyB,GAAGzY,KACrDkgB,WAAW/e,QAAQqQ,eAAexR;8BAChBoD,MAAb8c,YAAmD,KAAzBA,SAAS3N,MAAT,WAAkCvS,IAAKoB,MAAMof,aAC3EA;wBAGFpf,OAAYof,WACZV,cAAcC,aAAapW,QAAc4W,YAANnf,MAAkBmf,YAAYnf,KAAKqe,GAAGpe,QAAQqe,cAAa;;;gBAKjG,KAAiB,MAAbU,gBAA8Bhd,MAAZuc,SACrBE,UAAU,GACVI,aAAaxG,QAAQoG;gBACrB1G,cAAc8G,WAAW9G,kBAGzB,MAAkB,KAAXiH,SAAcA,WAEpB,IADAJ,SAAS7e,QAAQqQ,eAAe4O;gBAC5BJ,eAAiC5c,MAAvB4c,OAAO7G,aAA2B;oBAC/C,IAAI8G,cAAcA,WAAW9H,QAAQ6H,OAAO7G,iBAAiB6G,OAAO7H,QAAQ6H,OAAO7G,cAClF;oBAED0G,UAAUO,SACVjH,cAAchY,QAAQqQ,eAAeqO,SAAS1G,aAC9C8G,aAAaD;;gBAKhB,SAAoB5c,MAAhB+V,aAA2B;oBAC9BgH,cAAcnL,SAAS6K,UACvB1e,QAAQwQ,SAASwO,eAAehf,QAAQwQ,SAASwO,gBAAgB;qBACrD,MAAR/e,OACHD,QAAQwQ,SAASwO,aAAa/S,KAAK4L,iBAAiBiH;oBAGrD,IAAIQ,mBAAmB,IAAIC,wBAAwB;oBACnD,KAAK1gB,IAAImgB,aAAangB,IAAIyY,0BAAqBrV,IAAW,KAAQ,GAAGpD,KACpEkgB,WAAW/e,QAAQqQ,eAAexR;oBAC9BkgB,aAAwC,MAA5BA,SAASlI,iBACxByI,iBAAiBrT,KAAK8S,SAASjW,SACrBjK,IAAIoB,OAAKsf;2BACbvf,QAAQqQ,eAAexR;oBAG/B,MAAOmB,QAAQwQ,SAASwO,gBAAgBhf,QAAQwQ,SAASwO,aAAa3a,SAAS,MAAI;wBAClF,IAAIgb,aAAqC,IAAzBE,uBACfC,cAAcF,iBAAiBnR;wBAKhC,KAJAnO,QAAQuQ,MAAMyO,oBAAe/c,GAC7BmV,cAAa,IACbuH,eAAc,GACdO,eAAuB,MAARjf,MACa,IAArBuf,YAAYnb,UAAY;4BAC9B,IAAIyE,QAAQ0W,YAAYvD;4BACxB,MAAM0C,cAAcnW,QAAQmW,YAAYnB,SAAUlG,0BAAqBrV,IAAW,KAAQ,GAAI6G,QAAO,GAAOyV,cAAa,KACxH;;wBAIF,IADAW,eAAqB,IAANjf,MACV0e,aAkBJ;wBAbA,IAJAvH,gBACA0H,aAAaxG,QAAQ0G,cAErBhf,QAAQqQ,iBAAiB9O,EAAEc,QAAO,GAAM,IAAIoc;yBACxCze,QAAQwQ,SAASwO,cAQd;4BACNL,cAAcN,UAAUpe,KAAKqe,GAAGpe,QAAQqe,aAAaS,cAAc;4BACnE;;wBATA,IAAIjH,gBAAgBF,iBAAiBiH;wBACrC,KAA8D,MAA1D9e,QAAQwQ,SAASwO,aAAazb,QAAQwU,gBAAuB;4BAChE4G,cAAcN,UAAUpe,KAAKqe,GAAGpe,QAAQqe,aAAaS,cAAc;4BACnE;;wBAGD,KADAhf,QAAQwQ,SAASwO,aAAa/S,KAAK8L,gBAC9BlZ,IAAImgB,aAAangB,IAAIyY,0BAAqBrV,IAAW,KAAQ,GAAGpD,YAAYmB,QAAQqQ,eAAexR;;;gBAY5G,OADAmB,QAAQwQ,SAASwO,oBAAe/c,GACzB2c;;YAGR,SAASpW,QAAQvI,KAAKqe,GAAGpe,QAAQqe,aAAakB,eAAeC;gBAC5D,SAASC,YAAYC;oBACpB,OAAOld,QAAsC,IAA7Bkd,OAAOC,QAAQD,OAAOlF,OAAckF,OAAOC,QAAQD,OAAOlF,OAAS,IACpD,IAA7BkF,OAAOlF,MAAMkF,OAAOC,SAAgBD,OAAOlF,MAAMkF,OAAOC,SAAW;;gBAGtE3f,UAAoB,MAAXA;gBAET,IAAI4f,UAAU7f;gBAKd,SAAS8f,qBAAqBC;oBAC7B,SAAmB/d,MAAf+d,YAA0B;wBAoB7B,SAnB0B/d,MAAtB+d,WAAWlY,WACTvG,EAAE8M,QAAQ2R,WAAWlY,YAASkY,WAAWlY,SAAS,EAACkY,WAAWlY;wBACnEvG,EAAEmG,KAAKsY,WAAWlY,OAAOmY,KAAK,SAAUrhB,GAAGshB;4BAC1C,OAAOA,EAAEjgB,MAAMrB,EAAEqB;4BACd,SAAU0H,KAAKuL;4BAClBiN,eAAe;gCAACN,OAAO3M;gCAAMwH,KAAKxH,OAAO;;4BAE1C8M,WAAWlY,cAAS7F,SAEKA,MAAtB+d,WAAWb,WACT5d,EAAE8M,QAAQ2R,WAAWb,YAASa,WAAWb,SAAS,EAACa,WAAWb;wBACnE5d,EAAEmG,KAAKsY,WAAWb,OAAOc,KAAK,SAAUrhB,GAAGshB;4BAC1C,OAAOthB,EAAEqB,MAAMigB,EAAEjgB;4BACd,SAAU0H,KAAKuL;4BAClB1K,QAAQ0K,KAAKjT,KAAKiT,KAAKoL,QAAmBrc,MAAhBiR,KAAKhT,UAAuBgT,KAAKhT,aAAoC+B,MAArBiR,KAAKqL,cAA4BrL,KAAKqL,cAAcA;4BAE/HyB,WAAWb,cAASld,IAGjB+d,WAAW5C,qBAAqB4C,WAAW5f,QAAQ;4BACtD,IAAIggB,UAAUJ,WAAW5C;4BACzBA,mBAA8B,MAAZgD,UAAmBA,UAAUA,QAAQ3F,OAAO2F,QAAQ1F,KAAKsF,WAAW5f;4BACtF4f,WAAW5C,yBAAoBnb;;6BAGGA,MAA/B+d,WAAWK,oBACdP,UAAUE,WAAWK;wBACrBL,cAAa,GACbA,WAAWK,uBAAkBpe;;oBAG/B,OAAO+d;;gBAGR,SAASM,SAAS5N,UAAU4L,GAAGpe;oBAC9B,IAAIqgB,QAAO;oBAqCX,OAnCAhf,EAAEmG,KAAKqP,SAASrE,WAAW,SAAU/K,KAAKmQ;wBACzC,IAAIxX,OAAOwX,IAAI1G;wBAWf,IATA8L,WAAU,IAEVqD,OAAkB,QAAXjgB,KAAKsS,KACXtS,KAAKsS,GAAGtS,KAAKge,GAAGte,SAAS0S,UAAUxS,QAAQC,MAAMwf,YAAY1f,SAASqe,MAAMhe,KAAK0S,OAAOsL,MAAMne,KAAKyF,8BAA2C,OAAbtF,KAAK0S,OACrI;4BACCsL,GAAGrH,eAAevE,UAAUpS,OAAM,MAASA,KAAK0S;4BAChD/S,KAAKyS;4BAGK,MAAT6N,MAAgB;4BACnB,IAAIzV,YAAkB7I,MAAXse,KAAKjC,IAAkBiC,KAAKjC,IAAIA,GAAGkC,eAAe9N;4BAU7D,OATA5H,OAAQA,SAAS3K,KAAKyF,8BAA6C,MAAhBtF,KAAI,SACrD2W,eAAevE,UAAUpS,OAAM,MAASA,KAAK0S,MAAOlI;4BAEtDyV,OAAOR,qBAAqBQ,QAEf,MAATA,aAA8Bte,MAAbse,KAAKtgB,OAAqBsgB,KAAKtgB,QAAQyS,aAC3D8N,eAAeD,KAAKtgB;6BAGR,MAATsgB,aAA8Bte,MAAbse,KAAKtgB,YAAgCgC,MAAXse,KAAKjC,KAC5C,KAGH6B,eAAelgB,KAAKsB,EAAEc,OAAO,IAAIyV,KAAK;gCAC1ChP,OAAS1J,OAAO0L,MAAMxK,MAAMkgB;gCACzBjC,aAAaiC,kBAChBD,QAAO,KAED;;wBAGFA;;qBA9EUte,MAAdhC,IAAI4f,UACPC,UAAUpd,QAAQzC,IAAIya,MAAMza,IAAI4f;gBAgFjC,IAAIY,UAAS,GACZC,iBAAiBnf,EAAEc,QAAO,GAAM,IAAIrC,QAAQqQ;gBAM7C,IAJI9O,EAAE+D,WAAWnF,KAAKoG,mBAAmBrG,WAA0B,MAAhBqe,gBAAyC,MAAjBmB,iBAA2C,MAAlBD,kBACnGgB,SAAStgB,KAAKoG,cAAc2W,aAAa4C,SAASxB,GAAGqB,YAAY1f,MAAME,MAAMH;gBAC7EygB,SAASV,qBAAqBU,WAEhB,MAAXA,QAAiB;oBACpB,UAAkBxe,MAAd+T,aAA2B8J,UAAU9J,eACxCyK,SAASH,SAASR,SAASxB,GAAGpe;sBACxBA,WAA0B,MAAhBqe,iBAAoC,MAAXkC,WAAqC,MAAjBf,eAAuB;wBACnF,IAAIiB,kBAAkB3gB,QAAQqQ,eAAeyP;wBAC7C,KAAIa,oBAAoD,MAAjCA,gBAAgBvP,MAAhB,UAA0CuP,gBAAgBvP,MAAM4B,QAAQsL,KAAKA,MAAMne,KAAKyF;4BAK9G,IAAIzF,KAAKgF,mBAA4DlD,MAA9CjC,QAAQqQ,eAAeuQ,SAASd,WAAyB;gCAC/E,IAAIe,QAAO;gCAQX,IAPI7gB,QAAQ0Q,UAAUoP,iBAA0D7d,MAA9CjC,QAAQqQ,eAAeuQ,SAASd,cACjEW,SAASjY,QAAQsX,UAAU9f,QAAQ0Q,UAAUoP,UAAUxB,IAAG;iCAC3C,MAAXmC,YACmB,MAAlBhB,kBAAwBgB,OAAOjD,QAAQsC,UAC3Ce,QAAO;iCAGJA,SAASC,OAAOhB,UAAS,IAC7B,KAAK,IAAIiB,OAAOjB,UAAU,GAAGkB,QAAQJ,SAASd,UAAUiB,QAAQC,OAAOD,QAKtE,IADAN,SAASH,SAASS,MAAMzC,GAAGpe;iCACZ,MAAXugB,QAAkB;oCACrBA,SAASQ,mBAAmBnB,cAAwB7d,MAAfwe,OAAOxgB,MAAoBwgB,OAAOxgB,MAAM8gB,SAASN;oCACtFX,UAAUiB;oCACV;;;+BAtBJN,SAAS;4BACRjD,OAASoD,SAASd;;;qBA6BP,MAAXW,WAAwC,MAApBtgB,KAAK8F,cAAuC,QAAd9F,KAAKV,UAAiB6G,WAAW4W,gBAAkBhd,WAA4B,MAAlBuf,kBAClHgB,SAASpC,UAAUyB,SAASxB,GAAGpe,QAAQqe;qBAEzB,MAAXkC,WACHA,SAAS;wBACRxgB,KAAO6f;;;gBAIV,IAAIve,EAAE+D,WAAWnF,KAAKqG,oBAA8B,MAAXia,WAAqBvgB,WAA0B,MAAhBqe,gBAAyC,MAAjBmB,cAAuB;oBACtH,IAAIwB,aAAa/gB,KAAKqG,eAAe0W,WAAU,SAAqBjb,MAAdhC,IAAI4f,QAAuBnd,QAAQzC,IAAIya,MAAMza,IAAI4f,QAAS5f,KAAKwgB,QAAQtgB;yBAC1G8B,MAAfif,eACHT,UAAwB,MAAfS,aAAsBT,SAASS;;gBAItCT,eAAyBxe,MAAfwe,OAAOxgB,QACpBwgB,OAAOxgB,MAAM6f,WAGC,MAAXW,WAAqC,MAAjBf,gBACvBtI,cAAa;gBACbpX,QAAQqQ,iBAAiB9O,EAAEc,QAAO,GAAM,IAAIqe,mBAE5CO,wBAAmBhf,GAAW6d,UAAS;gBAGxC,IAAIqB,YAAYpB,qBAAqBU;gBAErC,OAAOU;;YAIR,SAASF,mBAAmBG,aAAaC,QAAQC;gBAEhD,SAAoBrf,MAAhBmf,aAEH,KAAKA,cAAcC,SAAS,GAAiB,IAAdD,gBAC1BphB,QAAQqQ,eAAe+Q,cADoBA;gBAIjD,KAAK,IAAIG,KAAKH,aAAaG,KAAKF,QAAQE,MACvC,SAAmCtf,MAA/BjC,QAAQqQ,eAAekR,QAAsBT,OAAOS,KAAI,IAAO;oBAClE,IAAIC,KAAW,KAAND,KAAUjJ,QAAQiJ,MAAMvhB,QAAQqQ,eAAekR,KAAK;oBAC7D,IAAIC,IAAI;wBACP,IAAIjR,QAAQwG,SAASwK,IAAIpT;wBACiB,OAAtCoC,MAAMA,MAAMlM,SAAS,GAAG+M,MAAM4B,OAAYzC,MAAMO;wBACpD,IAAI4H,YAAY5B,sBAAsByK,IAAIhR,QAAQkR;wBAClD,IAAI/I,eAAsC,MAAxBA,UAAUtH,MAAMsD,OAAoD,aAAnCgE,UAAUtH,MAAM2B,mBAAgC0O,KAAKzhB,QAAQqQ,eAAekR,KAAK,QAAuC,MAAhCE,GAAGrQ,MAAM0H,wBACnJJ,YAAYnX,EAAEc,OAAO,IAAIqW,WAAW;4BACnC5P,OAASmO,eAAesK,IAAI7I,UAAUtH,QAAO,MAASsH,UAAUtH,MAAM4B;4BAEvE0F,UAAU7B,kBAAiB,GAC3BsJ,eAAeoB,IAAI7I,YAAW,KAEb,MAAb4I,WAAmB;4BAEtB,IAAII,WAAW1hB,QAAQqQ,eAAegR,QAAQvY;4BAE9C,OADA9I,QAAQqQ,eAAegR,eAAUpf,GAC1BuG,QAAQ6Y,QAAQK,WAAU,IAAM;;;;;YAQ7C,SAASvB,eAAelgB,KAAK0hB,WAAWpD,aAAaiC;gBACpD,SAASoB,iBAAiB3hB,KAAKyX,QAAQmK;oBACtC,IAAIC,WAAWpK,OAAOzX;oBACtB,SAAiBgC,MAAb6f,cAAsD,MAA1BA,SAAS1Q,MAAT,WAAiE,MAA/B0Q,SAAS1Q,MAAM0B,gBAAyBgP,SAAShZ,UAAU3I,KAAK2F,YAKlI,QAAO;oBAJN,IAAI6M,YAAYkP,UAAUhC,SAAS5f,MAAM,IAAIyX,OAAOzX,MAAM,OAAuC,MAAjCyX,OAAOzX,MAAM,GAAGmR,MAAhB,UAAyCsG,OAAOzX,MAAM,KAAKyX,OAAOzX,MAAM,IACvI8hB,YAAYF,UAAUnH,MAAMza,MAAM,IAAIyX,OAAOzX,MAAM,OAAuC,MAAjCyX,OAAOzX,MAAM,GAAGmR,MAAhB,UAAyCsG,OAAOzX,MAAM,KAAKyX,OAAOzX,MAAM;oBAClI,OAAO0S,aAAaoP;;gBAKtB,IAAIlC,aAAsB5d,MAAdhC,IAAI4f,QAAsB5f,IAAI4f,QAAQ5f,KAAKya,WAAkBzY,MAAZhC,IAAIya,MAAoBza,IAAIya,MAAMza;gBAM/F,IALIA,IAAI4f,QAAQ5f,IAAIya,QACnBmF,QAAQ5f,IAAIya,KACZA,MAAMza,IAAI4f,QAEXW,oBAAgCve,MAAjBue,eAA6BA,eAAeX;gBACvDA,UAAUnF,OAAQva,KAAKgF,mBAAuDlD,MAAzCjC,QAAQqQ,eAAemQ,sBAA+Cve,MAAhBsc,aAA4B;oBAE1H,IAAImC,iBAAiBnf,EAAEc,QAAO,GAAM,IAAIrC,QAAQqQ,iBAC/C2R,MAAM1K,0BAAqBrV,IAAW,IACtCpD;oBAGD,KAFAmB,QAAQ2D,IAAIkc,OAEPhhB,IAAImjB,KAAUnC,SAALhhB,GAAYA,YAClBmB,QAAQqQ,eAAexR;yBACZoD,MAAd0f,oBAAgC3hB,QAAQuQ,MAAM1R,IAAI;oBAGvD,IAAIoa,SAAQ,GAAMgJ,IAAIzB,cACrB0B,mBAAkB,GAAOJ,WAAWG;oBASrC,KARApjB,IAAIojB,GAEAN,cACH3hB,QAAQqQ,eAAemQ,gBAAgBjf,EAAEc,QAAO,GAAM,IAAIsf;oBAC1DG,YACAG,KACIpC,QAAQnF,OAAK7b,MAEXA,KAAKmjB,KAAKnjB,KAAK;wBACrB,IAAIsjB,IAAIzB,eAAe7hB;wBACvB,SAAUoD,MAANkgB,MACGzH,OAAL7b,KAAkBghB,SAALhhB,MAAmC,MAArBsjB,EAAEtL,kBAA2B+K,iBAAiB/iB,GAAG6hB,gBAAgB;4BAC5Fb,OAAOA;4BACPnF,KAAKA;6BACA;4BACN,MAAuC,OAAhCpC,QAAQwJ,UAAU1Q,MAAM4B,OAAY;gCAC1C,KAAwB,MAApBkP,mBAA6BxB,eAAeoB,aAAapB,eAAeoB,UAAU1Q,MAAM6B,cAAckP,EAAE/Q,MAAM6B,WACjHjT,QAAQqQ,eAAeyR,YAAYvgB,EAAEc,QAAO,GAAM,IAAIqe,eAAeoB;gCACrE9hB,QAAQqQ,eAAeyR,UAAUhZ,QAAQqZ,EAAErZ,OAC3CmY,wBAAmBhf,GAAW6f,WAAU;gCACxCG,IAAIH,WAAW,GACf7I,SAAQ,QAEF,IAAI9Y,KAAK8G,mBAAmB+R,2BAA2B8I,UAAUK,EAAE/Q,MAAM4B,QAAwB,QAAhBmP,EAAE/Q,MAAM4B,MAAc;oCACzF,QAAhBmP,EAAE/Q,MAAM4B,OAAakK,WAAU;oCACnC,IAAIuD,SAASjY,QAAQsZ,UAAUK,EAAErZ,OAAuB,QAAhBqZ,EAAE/Q,MAAM4B,KAA6B,QAAhBmP,EAAE/Q,MAAM4B;oCACrEiG,SAAmB,MAAXwH,QAGRwB,KAAKxB,OAAOxgB,OAAO6hB,YAAY,GAC/BI,mBAAkB;uCAElBjJ,SAA6B,MAArBkJ,EAAEtL;gCAEX,IAAIoC,OAAO;gCACX,KAAKA,SAAoByB,MAAXoH,YAAkBhB,OAAOgB,WAAU,QAA6B,MAAnBK,EAAE/Q,MAAF,UAA2B0Q,WAAW9hB,QAAQyQ,aACxG;gCAEDqR;;4BAEkC,MAA/BxJ,QAAQwJ,UAAU1Q,MAAM4B,QAC3BiG,SAAQ,IAGT6I,WAAWG;;wBAEZ,KAAKhJ,OAAO;;oBAGb,KAAKA,OAGJ,OAFAjZ,QAAQqQ,iBAAiB9O,EAAEc,QAAO,GAAM,IAAIqe,iBAC5CtJ,cAAa;qBACN;uBAEEuK,cACV3hB,QAAQqQ,eAAemQ,gBAAgBjf,EAAEc,QAAO,GAAM,IAAIsf;gBAI3D,OADAvK,cAAa,KACN;;YAGR,SAAS0J,OAAO7gB,KAAKC;gBACpB,IAAII,OAAO4W,gBAAgBjX,KAAKmR;gBAGhC,IAFiB,OAAb9Q,KAAK0S,QAAY1S,OAAOgY,QAAQrY,KAAKmR,QAEtB,KAAf9Q,KAAI,QACP,OAAOA,KAAKsS;gBAEb,KAAe,MAAX1S,WAA0B,IAAPD,KAAU;oBAChC,IAAIsQ,QAAQwG,SAAS9W;oBACrB,OAAOsQ,MAAMlM,SAAS,KAA2C,OAAtCkM,MAAMA,MAAMlM,SAAS,GAAG+M,MAAM4B,MAAa,IAAI;;gBAE3E,QAAO;;YAGR,SAAS4N,SAAS3gB,KAAKmiB;gBAEtB,KADA,IAAI1P,WAAWzS,MAAM,GACkB,OAAhCqY,QAAQ5F,UAAUtB,MAAM4B,SAChB,MAAboP,cAAiE,MAA3C9J,QAAQ5F,UAAUtB,MAAM2B,mBAA4B+N,OAAOpO,eACpE,MAAb0P,aAAsBtB,OAAOpO,cAC9BA;gBAED,OAAOA;;YAGR,SAAS2P,aAAapiB,KAAKmiB;gBAC1B,IAAI1P,WAAWzS,KACdsQ;gBACD,IAAImC,YAAY,GAAG,OAAO;gBAE1B,MAAoB,MAAXA,cACM,MAAb0P,aAAgE,MAA3C9J,QAAQ5F,UAAUtB,MAAM2B,mBAChC,MAAbqP,aAAsBtB,OAAOpO,cAE5BnC,QAAQwG,SAASrE;gBAAWnC,MAAMlM,SAAS,KAAuB,MAAjBkM,MAAMlM,UAAuC,OAAvBkM,MAAM,GAAGa,MAAM4B;gBAEzF,OAAON;;YAGR,SAAS4P,YAAYxZ,OAAO1I,QAAQmiB,UAAUhT,OAAOiT;gBACpD,IAAIjT,SAAShO,EAAE+D,WAAWnF,KAAKqF,gBAAgB;oBAE9C,IAAIib,SAAStgB,KAAKqF,cAAcD,KAAKsC,WAAW0H,OAAOnP,QAAQmiB,UAAUpiB;oBACzE,IAAIsgB,QAAQ;wBACX,IAAIA,OAAOrD,mBAAmB;4BAC7B,IAAIgD,UAAUK,OAAOrD;4BACrBA,mBAA8B,MAAZgD,UAAmBA,UAAUA,QAAQ3F,OAAO2F,QAAQ1F,KAAK+F,OAAOrgB,UAAUA;4BAC5FA,SAAS8c,WAAU;;6BAEHjb,MAAbsgB,aAAwBA,gBAA4BtgB,MAAjBwe,OAAOjD,QAAsBiD,OAAOjD,QAAQ+E;;;gBAGrF,SAActgB,MAAV6G,UACHA,MAAMjB,UAAU4a,UAAUriB,OAAOoJ,KAAK,WACrBvH,MAAbsgB,iBAAqCtgB,MAAVsN,SAAsC,WAAfA,MAAMpC,OAG3DuV,gBAAgB5Z,OAAOyZ,UAA4B,MAAlBniB,OAAOiE,UAFxCmZ,MAAM1U,OAAOyZ;iBAIQ,MAAlBC,gBAAwB;oBAC3B,IAAIG,SAASphB,EAAEuH,QAAQ8Z,SAAS9Z,MAAMjB,UAAUgb;oBAChD/M,kBAAiB,GACjB6M,OAAO/Z,QAAQ,UACfka,WAAW;wBACNF,WAAW3F,oBAAoBzT,KAAK,MACvCmZ,OAAO/Z,QAAQ,cACkB,MAAvBtC,WAAWlG,WACrBuiB,OAAO/Z,QAAQ;uBAEd;;;YAKN,SAASqO,eAAehX,KAAKK,MAAMyiB;gBAElC,IADAziB,OAAOA,QAAQgY,QAAQrY,KAAKmR,YACHnP,MAArB3B,KAAKgE,gBAA0C,MAAbye,UACrC,OAAOxhB,EAAE+D,WAAWhF,KAAKgE,eAAehE,KAAKgE,YAAYnE,QAAQG,KAAKgE;gBAChE,KAAoB,MAAhBhE,KAAI,QAuBf,OAAOH,KAAKmE,YAAYqM,OAAO1Q,MAAME,KAAKmE,YAAYD;gBAtBrD,KAAW,IAAPpE,YAA4CgC,MAAhCjC,QAAQqQ,eAAepQ,MAAoB;oBAC1D,IAAIsQ,QAAQwG,SAAS9W,MACpB+iB,qBAAqB,IACrBC;oBACD,IAAI1S,MAAMlM,SAAS,KAA2C,OAAtCkM,MAAMA,MAAMlM,SAAS,GAAG+M,MAAM4B,MAAa,IAAI,IACtE,KAAK,IAAInU,IAAI,GAAGA,IAAI0R,MAAMlM,QAAQxF,KACjC,KAAmC,MAA/B0R,MAAM1R,GAAGuS,MAAM0B,gBAA8D,MAAtCvC,MAAM1R,GAAGuS,MAAM0H,wBAC9B,MAA1BvI,MAAM1R,GAAGuS,MAAT,eAAgDnP,MAAbghB,aAAmG,MAAzE1S,MAAM1R,GAAGuS,MAAMwB,GAAGtS,KAAK2iB,SAAS7R,MAAM4B,KAAKhT,SAASC,MAAK,GAAME,WAC7H6iB,mBAAmB/W,KAAKsE,MAAM1R;qBACA,MAA1B0R,MAAM1R,GAAGuS,MAAT,WAAgC6R,WAAW1S,MAAM1R,KACrB,IAA5BmkB,mBAAmB3e,UAClB,cAAc/D,KAAK0iB,mBAAmB,GAAG5R,MAAM4B,OAClD,OAAO7S,KAAKmE,YAAYqM,OAAO1Q,MAAME,KAAKmE,YAAYD;;gBAO5D,OAAO/D,KAAK0S;;YAMd,SAASkQ,wBAAwBjgB,KAAKmF;gBACrC,IAAI4M;oBACH,IAAI/R,IAAI4E,UAAUgb,gBAAgBza,UAAUnF,IAAIqB,gBAAgB8D,SAA6B,OAApBnF,IAAIqB,cAAqB;wBACjG,IAAIlE,SAAS8c,YAAY/O,SACxBgV,WAAWlgB,IAAI4E,UAAUgb;wBAC1B,IAAIM,aAAa/a,OAAO;4BACvB,IAAI4Z,MAAM1K;6BACG,MAAT0K,OAAcmB,aAAalG,oBAAoBzT,KAAK,MACvDpJ,SAAS,MACU,MAAT4hB,OACVvL,kBAAkBrW;4BAEnBkiB,YAAYrf,KAAK7C;;;uBAGT6C,IAAIqB,gBAAgB8D,UAC9BnF,IAAIqB,cAAc8D,OACM,OAApBnF,IAAIqB,eAAoBrB,IAAIiB,gBAAgB;;YAIlD,SAASkf,0BAA0BC,eAAeC;gBACjD,SAASC,aAAaC;oBACrB,IAAwB,OAApBrjB,KAAK2F,YAAmB;wBAC3B,IAAI2d,MAAMzjB,QAAQqQ;wBAClB,SAAsBpO,MAAlBwhB,IAAID,aAA4BC,IAAID,UAAU1a,UAAUmO,eAAeuM,WAAY;4BACtF,IAAIA,WAAW5C,UAAU,IAAI,QAAO;4BACpC,IAAI8C,WAAWniB,EAAEgN,QAAQpO,KAAK2F,YAAYoX;4BAC1C,KAAkB,MAAdwG,UAAiB;gCACpB,KAAK,IAAIlC,MAAMiC,KACd,IAAIA,IAAIjC,OAAOkC,WAAWlC,MAAMiC,IAAIjC,IAAI1Y,UAAUmO,eAAeuK,KAChE,QAAO;gCAGT,QAAO;;;;oBAIV,QAAO;;gBAUR,IAPI8B,WACC5gB,QACH2gB,cAAc3I,MAAM2I,cAAcxD,QAElCwD,cAAcxD,QAAQwD,cAAc3I;gBAGlC2I,cAAcxD,UAAUwD,cAAc3I,KACzC,QAAQva,KAAK2G;kBACZ,KAAK;oBACJ;;kBACD,KAAK;oBACJ,OAAO;wBAAC+Y,OAAO;wBAAGnF,KAAKwC,YAAY7Y;;;kBACpC,KAAK;oBACJ,OAAOuc,SAAStJ;;kBACjB,KAAK;oBACJ,IAAIiM,aAAaF,cAAcxD,QAAQ;wBACtC,IAAI6D,WAAWxG,YAAY1T,KAAK,IAAIjG,QAAQpD,KAAK2F;wBACjD,OAAO3F,KAAKwC,eAAeie,SAAS8C,YAAYA;;;kBAGlD;oBACC,IAAIC,gBAAgBN,cAAcxD,OACjC+D,kBAAkBtM,qBAAqBqM,gBAAe,IACtDE,eAAejD,UAA+B,MAArBgD,mBAA2B9C,OAAO,KAAU8C,kBAAJ;oBAClE,IAAID,gBAAgBE,cACnB,OAAQ/C,OAAO6C,gBAAe,MAAU7C,OAAO6C,gBAAgB,IAAG,KAAkCA,gBAA1B/C,SAAS+C;oBAEnF,IAAI3B,MAAMhiB,QAAQqQ,eAAeuT,kBAChCE,KAAK5M,gBAAgB2M,cAAc7B,MAAMA,IAAI5Q,MAAM4F,eAAU/U,GAAW+f,MACxE1d,cAAc2S,eAAe4M,cAAcC,GAAG1S;oBAC/C,IAAqB,OAAhB9M,eAAsB4Y,YAAY2G,kBAAkBvf,gBAA+C,MAAhCwf,GAAG1S,MAAM0H,uBAA2D,MAA5BgL,GAAG1S,MAAM2B,mBAA8B+N,OAAO+C,cAAc1jB,KAAK8F,eAAe6d,GAAG1S,MAAM4B,QAAQ1O,aAAc;wBAC9N,IAAI+c,SAAST,SAASiD;yBACDxC,UAAjBsC,iBAA2BA,kBAAkBE,kBAChDA,eAAexC;;oBAGjB,OAAOwC;;;YAMZ,IAAIE,aAAa;gBAChBrY,IAAI,SAAAA,GAAU5C,OAAOuM,WAAW2O;oBAC/B,IAAInY,KAAK,SAALA,GAAe+B;wBAClB,IAAItG,OAAOvF,MAAM4b;wBAEjB,SAAuB1b,MAAnBqF,KAAKO,aAA6C,WAAlB9F,KAAK0F,UAAqB;4BAC7D,IAAIwc,SAAS1iB,EAAEwG,KAAKT,MAAM;4BACtB2c,SACF,IAAIjlB,UAAUilB,QAASpkB,KAAKyH,QAE7Byc,WAAWzX,IAAIhF;+BAEV;4BAAA,IAAe,eAAXsG,EAAET,QAAyC,WAAlBpL,KAAK0F,cAAwBH,KAAK4c,YAAa5c,KAAK6c,cAAyB,cAAXvW,EAAET,QAAuBS,EAAEwW,WAAyB,OAAdxW,EAAEnE,YAAwC,MAApBtJ,KAAKgG,cAAwByH,EAAEnE,YAAYzK,UAAUyK,QAAQe,OAExN;gCACN,QAAQoD,EAAET;kCACT,KAAK;oCACJ,KAAuB,MAAnB2I,gBAEH,OADAA,kBAAiB,GACVlI,EAAEyW;oCAGV,IAAIpP,QAMH,OALA0I,OAAOlQ,WACPqV,WAAW;wCACVkB,aAAa5V,MAAM9G,MAAMqW,OACzBH,MAAMlW,MAAMA,KAAKO,UAAU0a,eAAUtgB,IAAW;uCAC9C,KACI;oCAER;;kCACD,KAAK;oCAEJ4T,qBAAoB,GACpBC,kBAAiB;oCACjB;;kCACD,KAAK;oCACJ,KAA0B,MAAtBD,mBACH,OAAOjI,EAAEyW;oCAEVxO,qBAAoB;oCACpB;;kCACD,KAAK;kCACL,KAAK;oCAMJ,OALA8H,OAAOlQ,WACPqV,WAAW;wCACVkB,aAAa5V,MAAM9G,MAAMqW;uCACvBxH,aACHA,aAAa,IACN;;kCACR,KAAK;oCACJA,aAAa;;gCAEf,IAAImO,YAAYN,aAAa5V,MAAM9G,MAAMmG;gCAKzC,QAJkB,MAAd6W,cACH1W,EAAEyW,kBACFzW,EAAE2W,oBAEID;;4BA7CP1W,EAAEyW;;;oBAiDJvb,MAAMjB,UAAU3F,OAAOmT,aAAavM,MAAMjB,UAAU3F,OAAOmT,cAAc,IACzEvM,MAAMjB,UAAU3F,OAAOmT,WAAWpJ,KAAKJ;qBAEY,MAA/CtK,EAAEgN,QAAQ8G,WAAW,EAAC,UAAU,aAChB,SAAfvM,MAAM0b,QAAejjB,EAAEuH,MAAM0b,MAAM9Y,GAAG2J,WAAWxJ,MAErDtK,EAAEuH,OAAO4C,GAAG2J,WAAWxJ;;gBAGzBS,KAAK,SAAAA,IAAUxD,OAAOyG;oBAEpB,IAAIrN;oBADD4G,MAAMjB,aAAaiB,MAAMjB,UAAU3F,WAElCqN,SACHrN,SAAS,IACTA,OAAOqN,SAASzG,MAAMjB,UAAU3F,OAAOqN,UAEvCrN,SAAS4G,MAAMjB,UAAU3F;oBAE1BX,EAAEmG,KAAKxF,QAAQ,SAAUmT,WAAWoP;wBACnC,MAAsB,IAAfA,MAAMpgB,UAAY;4BACxB,IAAIwH,KAAK4Y,MAAM3T;6BAC+C,MAA1DvP,EAAEgN,QAAQ8G,WAAW,EAAC,UAAU,SAAS,eACzB,SAAfvM,MAAM0b,QAAejjB,EAAEuH,MAAM0b,MAAMlY,IAAI+I,WAAWxJ,MAEtDtK,EAAEuH,OAAOwD,IAAI+I,WAAWxJ;;+BAGnB/C,MAAMjB,UAAU3F,OAAOmT;;;eAK9BqP,gBAAgB;gBACnBC,cAAc,SAAAA,aAAU/W;oBACvB,IAAI9E,QAAQ/G,MACX4gB,SAASphB,EADEQ,OAEX6iB,IAAIhX,EAAEnE,SACNxJ,MAAMud,MAHKzb,OAKR8iB,WAAW1kB,KAAKiF,UAAUG,KAAKxD,MAAM6L,GAAGsP,aAAajd,IAAI4f,OAAO1f;oBACpE,SAAiB8B,MAAb4iB,UAAwB,OAAOA;oBAGnC,IAAID,MAAM5lB,UAAUyK,QAAQC,aAAakb,MAAM5lB,UAAUyK,QAAQG,UAAWwL,UAAUwP,MAAM5lB,UAAUyK,QAAQE,oBAAsBiE,EAAEwW,WAAWQ,MAAM5lB,UAAUyK,QAAQiB,MAAMwK,sBAAsB,QACpMtH,EAAEyW;oBACFS,aAXW/iB,MAWS6iB,GAAG3kB,MACvBqiB,YAZWvgB,MAYQmb,WAAU,IAAOld,QAAQ2D,GAAGiK,GAZpC7L,KAY6C8F,UAAUgb,gBAAgB3F,YAAY1T,KAAK,WAC7F,IAAIob,MAAM5lB,UAAUyK,QAAQK,OAAO8a,MAAM5lB,UAAUyK,QAAQW,WAAW;wBAC5EwD,EAAEyW;wBACF,IAAI9B,WAAW3B,SAAStJ;wBACxBkG,MAhBWzb,MAgBE6L,EAAEmX,WAAW9kB,IAAI4f,QAAQ0C,UAAUA,WAAU;2BAC/CqC,MAAM5lB,UAAUyK,QAAQQ,SAAS2D,EAAEmX,YAAaH,MAAM5lB,UAAUyK,QAAQY,WACnFuD,EAAEyW;oBACF7G,MAnBWzb,MAmBE,GAAG6L,EAAEmX,WAAW9kB,IAAI4f,QAAQ,IAAG,OAChC1f,KAAK0F,gBAAgB+e,MAAM5lB,UAAUyK,QAAQO,UAAkB,OAAN4a,KAAYhX,EAAEwW,aAA0B,MAAbxW,EAAEoX,UAClGC,SArBWljB,OAqBK,IAAM,GAAO4T,UAAUxJ,MAAM;oBAC7CwW,OAAO/Z,QAAQ,YACLgc,MAAM5lB,UAAUyK,QAAQS,UAAY0D,EAAEmX,YAAYnX,EAAEwW,WAGhC,MAApBjkB,KAAKgG,cAAuBye,MAAM5lB,UAAUyK,QAAQe,SAC3C,MAAfoD,EAAEmX,aACmC,MAApCzM,QAAQrY,IAAI4f,OAAOzO,MAAnB,WACHnR,IAAI4f,QAAQe,SAAS3gB,IAAI4f;oBAE1B5f,IAAIya,MAAM2H,aAAapiB,IAAI4f,QAAO,IAClC5f,IAAI4f,QAAQwC,aAAapiB,IAAIya,MAAK,OAElCza,IAAI4f,QAAQe,SAAS3gB,IAAI4f,QAAO;oBAChC5f,IAAIya,MAAMkG,SAAS3gB,IAAI4f,QAAO,IAC1B5f,IAAIya,MAAM1a,QAAQyQ,cAAYxQ,IAAIya,QAEnCza,IAAI4f,QAAQ7f,QAAQyQ,eACvB7C,EAAEyW;oBACF7G,MAxCUzb,MAwCG9B,IAAI4f,OAAO5f,IAAIya,UAhB7Bva,KAAKgF,cAAchF,KAAKgF,YAxBbpD,KAyBL0T,aAAa,kBAAkBtV,KAAKgF;oBAmB3C4Q,aAA+C,MAAnCxU,EAAEgN,QAAQqW,GAAGzkB,KAAKkG;;gBAE/B6e,eAAe,SAAAA,cAAUtX,GAAGuX,UAAUC,UAAUllB,QAAQyH;oBACvD,IAAImB,QAAQ/G,MACX4gB,SAASphB,EAAEuH,QACX8b,IAAIhX,EAAEyX,SAASzX,EAAE0X,YAAY1X,EAAEnE;oBAEhC,OAAiB,MAAb0b,YAAwBvX,EAAEwW,WAAWxW,EAAEoX,YAAYpX,EAAEwW,WAAWxW,EAAE2X,WAAWxP,YAQhF,OAPI6O,MAAM5lB,UAAUyK,QAAQM,SAAS4L,cAAcuH,YAAY1T,KAAK,QACnEmM,YAAYuH,YAAY1T,KAAK;oBAE7BsZ,WAAW;wBACVH,OAAO/Z,QAAQ;uBACb,MAEG;oBACD,IAAIgc,GAAG;wBAEH,OAANA,MAA2B,MAAfhX,EAAEmX,YAA0C,OAApB5kB,KAAK2F,eAAmB8e,IAAIzkB,KAAK2F,WAAW8U,WAAW;wBAC/F,IAAI3a,MAAMklB,WAAW;4BACnBtF,OAAOlY;4BACP+S,KAAK/S;4BACF6V,MAAM1U,QACV0c,iBAAiBlH,IAAIzD,OAAOC,aAAa8J;wBAE1C5kB,QAAQylB,kBAAiB;wBACzB,IAAIpI,YAAY7U,QAAQvI,KAAKqe,GAAGpe;wBAQhC,KAPkB,MAAdmd,cACHjG,cAAa,IACboO,uBAAsCvjB,MAApBob,UAAUG,QAAsBH,UAAUG,QAAQoD,SAASvD,UAAUpd,IAAI4f,QAAQxC,UAAUpd,IAAI4f,QAAQxC,UAAUpd;wBACnID,QAAQ2D,IAAI6hB,kBAGbA,kBAAoBrlB,KAAKwC,qBAAoCV,MAApBob,UAAUG,QAAuB6E,aAAamD,mBAAmBA;yBACzF,MAAbJ,aACHtC,WAAW;4BACV3iB,KAAKwF,gBAAgBJ,KAAKuD,OAAO8b,GAAGvH,WAAWld;2BAC7C,IACCH,QAAQylB,mBAAgC,MAAdpI,YAAqB;4BAClD,IAAIjd,SAAS8c;4BACboF,YAAYxZ,OAAO1I,QAAQolB,iBAAiB5X,IAAgB,MAAbuX;;wBAMjD,IAFAvX,EAAEyW,kBAEEc,UAEH,QADkB,MAAd9H,cAAqBA,UAAUmI,kBAAkBA;wBAC9CnI;;;gBAIVqI,YAAY,SAAAA,WAAU9X;oBACrB,IAAI9E,QAAQ/G,MACX8J,KAAK+B,EAAE+X,iBAAiB/X,GACxBgY,aAFW7jB,KAEQ8F,UAAUgb,WAAU,IACvCN,WAAW/E,MAHAzb,OAIX8jB;oBAEGnjB,UACHmjB,YAAYtD,SAAS7H,KACrB6H,SAAS7H,MAAM6H,SAAS1C,OACxB0C,SAAS1C,QAAQgG;oBAGlB,IAAIC,mBAAmBF,WAAWG,OAAO,GAAGxD,SAAS1C,QACpDmG,kBAAkBJ,WAAWG,OAAOxD,SAAS7H,KAAKkL,WAAWvhB;oBAK9D,IAHIyhB,sBAAsBpjB,QAAQua,oBAAoB9M,YAAY8M,qBAAqB9O,MAAM,GAAGoU,SAAS1C,OAAOrW,KAAK,QAAKsc,mBAAmB;oBACzIE,qBAAqBtjB,QAAQua,oBAAoB9M,YAAY8M,qBAAqB9O,MAAMoU,SAAS7H,KAAKlR,KAAK,QAAKwc,kBAAkB;oBAElIlnB,OAAOmnB,iBAAiBnnB,OAAOmnB,cAAcC,SAChDN,aAAaE,mBAAmBhnB,OAAOmnB,cAAcC,QAAQ,UAAUF,sBACjE;wBAAA,KAAIna,GAAGoa,kBAAiBpa,GAAGoa,cAAcC,SAG/C,QAAO;wBAFPN,aAAaE,mBAAmBja,GAAGoa,cAAcC,QAAQ,gBAAgBF;;oBAK1E,IAAIG,aAAaP;oBACjB,IAAIrkB,EAAE+D,WAAWnF,KAAKU,gBAAgB;wBAErC,IADAslB,aAAahmB,KAAKU,cAAc0E,KAAKsC,WAAW+d,YAAYzlB,QACzC,MAAfgmB,YACH,OAAOvY,EAAEyW;wBAEL8B,eACJA,aAAaP;;oBAKf,OAFAX,SApCYljB,OAoCI,IAAO,GAAOokB,WAAWlO,WAAW9L,MAAM,MAC1DmW,YArCYvgB,MAqCOmb,aAAa0D,SAAStJ,yBAAyB1J,GAAG+H,cAAcuH,YAAY1T,KAAK;oBAC7FoE,EAAEyW;;gBAEV+B,oBAAoB,SAAAA,mBAAUxY;oBAC7B,SAASyY,kBAAkBvd,OAAO8c,YAAYrD;wBAQ7C,OAN8C,QAA1CqD,WAAWjV,OAAO4R,SAAS1C,QAAQ,MAAkC,OAApB1f,KAAK2F,eACzD8f,aAAaA,WAAWzZ,MAAM;wBAC9ByZ,WAAWrD,SAAS1C,QAAQ,KAAK1f,KAAK2F,WAAW6K,OAAO,IACxDiV,aAAaA,WAAWpc,KAAK;wBAGvBoc;;oBAGR,SAASU,gBAAgBxd,OAAO8c,YAAYrD;wBAC3C,IAAIpN,UAAU;4BACb,IAAIoR,YAAYX,WAAW5kB,QAAQkc,YAAY1T,KAAK,KAAK;4BACzD,IAAyB,MAArB+c,UAAUliB,QAAc;gCAC3B,IAAImiB,KAAKZ,WAAWzZ,MAAM;gCAC1Bqa,GAAG7Z,OAAO4V,SAAS1C,OAAO,GAAG0G,YAC7BX,aAAaY,GAAGhd,KAAK;;;wBAGvB,OAAOoc;;oBAGR,IAAI9c,QAAQ/G,MACX6jB,aAAa9c,MAAMjB,UAAUgb;oBAE9B,IAAI3F,YAAY1T,KAAK,QAAQoc,YAAY;wBAExC,IAAIrD,WAAW/E,MAAM1U;wBAIrB,IAHA8c,aAAaS,kBAAkBvd,OAAO8c,YAAYrD,WAClDqD,aAAaU,gBAAgBxd,OAAO8c,YAAYrD;wBAE5CrF,YAAY1T,KAAK,QAAQoc,YAAY;4BACxC,IAAIxlB,SAAS8c,YAAY1T,KAAK,KAC7Bid,UAAWtmB,KAAKwC,gBAAgBijB,WAAWvhB,SAASjE,OAAOiE,UAAW,IAAI,GAC1EqiB,YAAYd,WAAWG,OAAO,GAAGxD,SAAS1C,QAC1C8G,WAAWf,WAAWG,OAAOxD,SAAS1C,QACtC+G,kBAAkBxmB,OAAO2lB,OAAO,GAAGxD,SAAS1C,QAAQ4G,SACpDI,iBAAiBzmB,OAAO2lB,OAAOxD,SAAS1C,QAAQ4G,SAG7C5E,YAAYU,UACfuE,UAAU,IACVC,WAAU;4BACX,IAAIL,cAAcE,iBAAiB;gCAClC,IAAII,OAAQD,UAAUL,UAAUriB,UAAUuiB,gBAAgBviB,UAAWqiB,UAAUriB,SAASuiB,gBAAgBviB,QACvGxF;gCACD,KAAKA,IAAI,GAAG6nB,UAAU/V,OAAO9R,OAAO+nB,gBAAgBjW,OAAO9R,MAAMA,IAAImoB,KAAKnoB;gCACtEkoB,YACHlF,UAAUhC,QAAQhhB,IAAI4nB,QACtBK,WAAWJ,UAAUvY,MAAMtP,GAAGgjB,UAAUnH;;4BAuB1C,IApBIiM,aAAaE,mBACZF,SAAStiB,SAASwiB,eAAexiB,SACpCyiB,WAAWH,SAASxY,MAAM,GAAG,KAEzBwY,SAAStiB,SAASwiB,eAAexiB,WACpCwd,UAAUnH,OAAOmM,eAAexiB,SAASsiB,SAAStiB;4BAE7C0iB,WAA+B,OAApB5mB,KAAK2F,cAAkC,OAAb6gB,YAAmBD,UAAU/V,OAAOkR,UAAUhC,QAAQ4G,SAAS,OAAOtmB,KAAK2F,eACpH+b,UAAUhC;4BACViH,UAAU3mB,KAAK2F,eAOnBwc,YAAYxZ,OAAOoU,aAAa;gCAC/B2C,OAASgC,UAAUhC,QAAQ4G;gCAC3B/L,KAAOmH,UAAUnH,MAAM+L;gCAEH,IAAjBK,QAAQziB,QACX9C,EAAEmG,KAAKof,QAAQ3a,MAAM,KAAK,SAAUxE,KAAKsf;gCACxC,IAAIC,WAAW,IAAI3lB,EAAE2M,MAAM;gCAC3BgZ,SAAS7B,QAAQ4B,MAAMrM,WAAW,IAClC7E,aAAY,GACZ2O,cAAcQ,cAAc3f,KAAKuD,OAAOoe;qCAEnC;gCACFrF,UAAUhC,UAAUgC,UAAUnH,MAAM,MACvCmH,UAAUhC,QAAQwC,aAAaR,UAAUhC,QAAQ;gCAC7CgC,UAAUhC,UAAUgC,UAAUnH,MAAM,IACvC8C,MAAM1U,OAAO+Y,UAAUhC,SAEvBrC,MAAM1U,OAAO+Y,UAAUhC,OAAOgC,UAAUnH;gCAG1C,IAAIyM,UAAU,IAAI5lB,EAAE2M,MAAM;gCAC1BiZ,QAAQ1d,UAAUtJ,KAAKwC,eAAe3D,UAAUyK,QAAQC,YAAY1K,UAAUyK,QAAQG;gCACtF8a,cAAcC,aAAapf,KAAKuD,OAAOqe;;4BAGxCvZ,EAAEyW;;;;gBAIL+C,kBAAkB,SAAAA,iBAAUxZ;oBAC3B,IAAIA,EAAEL,YAAY;wBACjB,IAAIzE,QAAQ/G,MAAMolB,SAASD;wBAC3B,QAAQtZ,EAAEyZ;0BACT,KAAK;4BAOJ,OANA9lB,EAAEmG,KAAKkG,EAAE7F,KAAKoE,MAAM,KAAK,SAAUxE,KAAKsf;gCACvCC,WAAW,IAAI3lB,EAAE2M,MAAM,aACvBgZ,SAAS7B,QAAQ4B,MAAMrM,WAAW,IAClC7E,aAAY;gCACZ2O,cAAcQ,cAAc3f,KAAKuD,OAAOoe;gCAElCtZ,EAAEyW;;0BACV,KAAK;4BAIJ,OAHA8C,UAAU,IAAI5lB,EAAE2M,MAAM,YACtBiZ,QAAQ1d,UAAUzK,UAAUyK,QAAQC;4BACpCgb,cAAcC,aAAapf,KAAKuD,OAAOqe,UAChCvZ,EAAEyW;;0BACV,KAAK;4BAIJ,OAHA8C,UAAU,IAAI5lB,EAAE2M,MAAM,YACtBiZ,QAAQ1d,UAAUzK,UAAUyK,QAAQG;4BACpC8a,cAAcC,aAAapf,KAAKuD,OAAOqe,UAChCvZ,EAAEyW;;;;gBAIbiD,eAAe,SAAAA,cAAU1Z;oBACxB,IAAI9E,QAAQ/G,MACXqG,QAASwF,KAAKA,EAAEJ,SAAUI,EAAEJ,OAAO,KAAKC,UAAU;oBACnDrF,QAAQA,SAFIrG,KAEW8F,UAAUgb,WAAU,IAE3C0E,gBAJYxlB,MAIWqG,SAElBwF,EAAEJ,eAA0BvL,MAAhB2L,EAAEJ,OAAO,WAAsCvL,MAAjBwL,UAAU,OACxD+P,MAPWzb,MAOE6L,EAAEJ,SAASI,EAAEJ,OAAO,KAAKC,UAAU;;gBAGlD+Z,YAAY,SAAAA,WAAU5Z;oBACrB,IAAI9E,QAAQ/G,MACXohB,WADWphB,KACM8F,UAAUgb;oBACxB1iB,KAAKsF,oBACJ0d,aAAajG,YAAY1T,KAAK,MACjC8Y,YAJUvgB,MAISmb,aAAa0D,SAAStJ,4BAChB,MAAfrB,cACVuH,MANUzb,MAMG6e,SAAStJ;qBAGQ,MAA5BnX,KAAK+F,uBAA8C,MAAf+P,cACvCyO,cAAc+C,WAAWrZ,MAVdrM,MAU2B,EAAC6L,IAAG;oBAE3C+H,YAAYuH,YAAY1T,KAAK;;gBAE9Bke,iBAAiB,SAAAA;oBAChB,IAAI5e,QAAQ/G;oBACZkU,cAAa,GACT9V,KAAK+E,wBAAwB1D,SAASmmB,kBAF9B5lB,QAGXmhB,wBAHWnhB,MAGoBmU;;gBAGjCuR,YAAY,SAAAA,WAAU7Z,GAAG0V;oBACxB,IAAIxa,QAAQ/G;oBACZ,IAAIP,SAASmmB,kBADD5lB,MAC0B;wBACrC,IAAI6lB,mBAAmBxE,0BAA0B5F,MAFtCzb,OAEoDuhB;6BACtCrhB,MAArB2lB,oBACHpK,MAJUzb,MAIG6lB;;;gBAIhBC,UAAU,SAAAA,SAAUja;oBACnB,IAAI9E,QAAQ/G,MACX9B,MAAMud,MADKzb,OAEX8J,KAAK+B,EAAE+X,iBAAiB/X,GAGrBqY,gBAAgBnnB,OAAOmnB,iBAAiBpa,GAAGoa,eAC9C6B,WAAWplB,QAAQwa,YAAY/O,MAAMlO,IAAIya,KAAKza,IAAI4f,SAAS3C,YAAY/O,MAAMlO,IAAI4f,OAAO5f,IAAIya;oBAC7FuL,cAAc8B,QAAQ,QAAQrlB,QAAQolB,SAAS3X,UAAU3G,KAAK,MAAMse,SAASte,KAAK;oBAC9EhI,SAASwmB,eAAaxmB,SAASwmB,YAAY,SAE/ClD,aAVY/iB,MAUQ/C,UAAUyK,QAAQG,QAAQ3J;oBAC9CqiB,YAXYvgB,MAWOmb,aAAald,QAAQ2D,GAAGiK,GAAG+H,cAAcuH,YAAY1T,KAAK;;gBAE9Eye,WAAW,SAAAA,UAAUra;oBACpB,IAAI+U,SAASphB,EAAEQ,OACd+G,QAAQ/G;oBACT,IADSA,KACC8F,WAAW;wBACpBqb,wBAFQnhB,MAEuBmU;wBAC/B,IAAIiN,WAHIphB,KAGa8F,UAAUgb,aAC9BziB,SAAS8c,YAAY/O;wBAEL,OAAbgV,iBAAiClhB,MAAd8E,cAClB5G,KAAK+E,0BACwB,MAA5BoS,0BAAiC6L,aAAalG,oBAAoBzT,KAAK,MAC1EpJ,SAAS,KAETqW,kBAAkBrW;yBAGO,MAAvBkG,WAAWlG,YACd0iB,WAAW;4BACVH,OAAO/Z,QAAQ;2BACb,IACCzI,KAAKmB,oBACR8V,gBAEChX,SADGD,KAAK+E,uBACC,KAEA+X,oBAAoB9O;wBAKhCmU,YA5BOvgB,MA4BY3B,aAAQ6B,GAAW2L,KAGnC+H,cAAcuH,YAAY1T,KAAK,QAClCmM,YAAYuH,YAAY1T,KAAK;wBAC7BmZ,OAAO/Z,QAAQ;;;gBAIlBsf,iBAAiB,SAAAA;oBAChB,IAAIpf,QAAQ/G;oBACZkU,cAAa,GACTzU,SAASmmB,kBAFD5lB,cAGDuC,gBAAgB4R,wBACzBA,sBAJUnU,KAIkBuC;oBAEzBnE,KAAKuF,mBACRwd,wBAPUnhB,OAOsBW,QAAQwa,YAAY/O,QAAQgC,YAAY+M,aAAa1T,KAAK;;gBAI7F2e,aAAa,SAAAA;oBACRxS,cAAcuH,YAAY1T,KAAK,OAClCoM,IAAIhN,QAAQ,WAETzI,KAAK+E,yBAAoD,MAA5BoS,0BAAiCtV,GAAG6F,UAAUgb,aAAa7gB,GAAG6F,UAAUgb,gBAAgB5F,oBAAoBzT,KAAK,OACjJxH,GAAG6F,UAAU4a,UAAU;oBAEpBtiB,KAAKmB,oBAA+C,MAA5BgF,WAAW4W,gBACtClb,GAAG6F,UAAU4a,UAAU;oBAEpBtiB,KAAK8E,uBACRjD,GAAG6F,UAAU4a,UAAUzgB,GAAG6F,UAAUM,kBAAiB;oBACrD2a,WAAW;wBACVR,YAAYtgB,IAAIkb;uBACd;;gBAGLkL,YAAY,SAAAA;oBACXpmB,GAAG6F,UAAU1F,gBAAe,GAC5B2gB,WAAW;wBACVyE,gBAAgBvlB,IAAIA,GAAG6F,UAAUgb,WAAU;uBACzC;;gBAEJwF,cAAc,SAAAA,aAAUza;eA2tBrB0a;YAttBJ,SAASrD,SAASnc,OAAOsc,UAAUllB,QAAQqoB,OAAOC;gBACjD,IAAI3gB,YAAY9F,QAAQ+G,MAAMjB,WAC7B+d,aAAa2C,MAAMpa,SACnBsa,YAAY,IACZC,cAAc,GACdjI,cAASxe;gBAIV,SAAS0mB,gBAAgBhhB,KAAK8gB;oBAC7B,IAAItoB,KAAKV,OAAO,QAAO;oBAIvB,KAHA,IAAImpB,iBAAiBxS,iBAAgB,GAAM,IAAG,GAAOjI,MAAMxG,KAAKiZ,SAASjZ,MAAM6B,KAAK,IAAIxI,QAAQ,MAAM,KACrG6nB,cAAcD,eAAerlB,QAAQklB,YAEjB,IAAdI,eAAuD,QAApCD,eAAeC,cAAc,MAAYA;oBAEnE,IAAIzX,QAAwB,MAAhByX,gBAAsB/H,OAAOnZ,SACpC2Q,QAAQ3Q,KAAKyJ,MAAM6B,cAAcwV,UAAU9X,OAAO,OACnB,MAA9B2H,QAAQ3Q,KAAKyJ,MAAb,UAAsCkH,QAAQ3Q,KAAKyJ,MAAM6B,cAAe,MAAMwV,UAAU9X,OAAO,MAC9D,QAAjC2H,QAAQ3Q,KAAKyJ,MAAM6B,cAAsBqF,QAAQ3Q,MAAM,GAAGyJ,MAAM6B,cAAcwV,UAAU9X,OAAO,OAC5D,MAAlC2H,QAAQ3Q,MAAM,GAAGyJ,MAAjB,UAA0CkH,QAAQ3Q,MAAM,GAAGyJ,MAAM6B,cAAe,MAAMwV,UAAU9X,OAAO;oBAG9G,QADKS,SAAuB,IAAdyX,gBAAiBhhB,UAAU0a,WAAW;wBAAC1C,OAAOe,SAASiI;wBAC9DzX;;gBAGRgG,gBACAsR,aAAavoB,KAAK2F,aAAasd,0BAA0B,KAAK;gBAC9DpjB,QAAQ2D,IAAI+kB,YACZ7gB,UAAU0a,WAAW;oBAAC1C,OAAO6I;;gBAE7B,IAAII,gBAAgB,IAAIC,eAAelhB,UAAU0a,UAoC5CyG,MAAMjK,UAAUkK;gBADrB,IAlCA1nB,EAAEmG,KAAKke,YAAY,SAAUje,KAAK2d;oBACjC,SAAiBrjB,MAAbqjB,UACH,SAAoCrjB,MAAhCjC,QAAQqQ,eAAe1I,QAAsBie,WAAWje,SAASsP,eAAetP,QAAQmZ,OAAOnZ,MAAK,OACnC,MAApEa,QAAQb,KAAKie,WAAWje,OAAM,QAAM1F,QAAWA,IAAW,IAC1DjC,QAAQ2D,UACF;wBACN,IAAIujB,WAAW,IAAI3lB,EAAE2M,MAAM;wBAC3BgZ,SAAS7B,QAAQC,SAAS1K,WAAW,IACrC6N,aAAanD;wBACb,IAAItD,MAAM1K,0BAAqBrV,IAAW;wBACrC0mB,gBAAgBD,YAAYD,aAQhChI,SAASiE,cAAcQ,cAAc3f,KAAKuD,OAAOoe,WAAU,IAAM,GAAOhnB,QAAQ8hB,MAAM,MAPtFvB,SAASiE,cAAcQ,cAAc3f,KAAKuD,OAAOoe,WAAU,IAAM,GAAOhnB,QAAQ2H,UAAU0a,SAAS1C;wBAE/FY,WACHiI,aAAa7gB,UAAU0a,SAAS1C,QAAQ,GACxC4I,YAAY,MAKVhI,UACCA,OAAOxgB,OAAOD,QAAQqQ,eAAeoQ,OAAOxgB,SAA4D,MAApDD,QAAQqQ,eAAeoQ,OAAOxgB,KAAKmR,MAAnC,WACvD0X,cAAc7c,KAAKwU,OAAOxgB;wBAC1BwgB,OAAO+E,kBAAkB/E,OAAOxgB,MAAM,IAEvCqiB,iBAAYrgB,GAAWib,aAAauD,OAAO+E,iBAAiB0B,WAAU;wBACtErf,UAAU0a,WAAW;4BAAC1C,OAAOY,OAAO+E;4BAAiB9K,KAAK+F,OAAO+E;2BACjEuD,eAAelhB,UAAU0a,YAEzB1a,UAAU0a,WAAWwG;;oBAKE,IAAvBD,cAAczkB,QAEjB,IAAKiC,WAAW4W,cAef,MAAQ8L,OAAOF,cAAchY,SAC5BiO,WAAW/e,QAAQqQ,eAAe2Y;gBAC9BjK,aACHA,SAASlI,kBAAiB,SAjB5B,MAAQmS,OAAOF,cAAchY,SAAQ;oBACpC,IAAIoW,WAAW,IAAI3lB,EAAE2M,MAAM,cAC1Bgb,WAAWF,OAAO;oBAKnB,KAHAjK,WAAW/e,QAAQqQ,eAAe2Y,OAClCjK,SAASlI,kBAAiB,GAC1BqQ,SAAS7B,QAAQtG,SAASjW,MAAM8R,WAAW,KACnCqO,YAAYjpB,QAAQqQ,eAAe6Y,cAAcD,UAAUngB,UAAUiW,SAASjW,SACrFogB;oBAGD,IADAxE,cAAcQ,cAAc3f,KAAKuD,OAAOoe,WAAU,IAAM,GAAOhnB,QAAQgpB;oBACnE5iB,WAAW4W,cAAc;;gBAW5BkI,YACH9C,YAAYxZ,OAAOoU,aAAauD,SAASA,OAAO+E,uBAAkBvjB,GAAWumB,mBAAmB,IAAIjnB,EAAE2M,MAAM,aAAasa,mBAA4C,YAAzBA,gBAAgBrb;;YAI9J,SAAShF,cAAcW;gBACtB,IAAIA,OAAO;oBACV,SAAwB7G,MAApB6G,MAAMjB,WACT,OAAOiB,MAAMV;oBAEVU,MAAMjB,aAAaiB,MAAMjB,UAAU1F,gBACtColB,gBAAgBze,OAAOA,MAAMjB,UAAUgb,WAAU;;gBAGnD,IAAIsG,UAAU,IACb1F,MAAMzjB,QAAQqQ;gBACf,KAAK,IAAI+Y,QAAQ3F,KACZA,IAAI2F,SAAS3F,IAAI2F,MAAMhY,SAAmC,KAA1BqS,IAAI2F,MAAMhY,MAAV,UACnC+X,QAAQld,KAAKwX,IAAI2F,MAAMtgB;gBAGzB,IAAIrI,gBAAmC,MAAnB0oB,QAAQ9kB,SAAe,MAAM3B,QAAQymB,QAAQhZ,YAAYgZ,SAAS3f,KAAK;gBAC3F,IAAIjI,EAAE+D,WAAWnF,KAAKI,WAAW;oBAChC,IAAI8oB,eAAe3mB,QAAQwa,YAAY/O,QAAQgC,YAAY+M,aAAa1T,KAAK;oBAC7E/I,gBAAgBN,KAAKI,SAASgF,KAAKsC,WAAWwhB,aAAa5oB,eAAeN;;gBAE3E,OAAOM;;YAGR,SAAS+c,MAAM1U,OAAO+W,OAAOnF,KAAK4O;gBACjC,SAASC,kBAAkBtpB;oBAI1B,QAHIyC,SAAwB,mBAARzC,OAAsBE,KAAKS,UAA+B,OAArBT,KAAKmE,gBAAuBtC,OACpF/B,MAAM+B,GAAG6F,UAAUgb,YAAYxe,SAASpE;oBAElCA;;gBAGR,IAAIupB;gBACJ,SAAcvnB,MAAV4d,OAoEH,OAhBI,oBAAoB/W,SAAS,kBAAkBA,SAClD+W,QAAQ/W,MAAM2gB;gBACd/O,MAAM5R,MAAM4gB,gBACF5qB,OAAO6qB,gBACjBH,QAAQ1qB,OAAO6qB,eAAeC,WAAW;gBACrCJ,MAAMK,wBAAwBC,eAAehhB,SAAS0gB,MAAMK,4BAA4B/gB,UAC3F+W,QAAQ2J,MAAMO;gBACdrP,MAAM8O,MAAMQ,cAEHxoB,SAASqgB,aAAargB,SAASqgB,UAAUoI,gBACnDT,QAAQhoB,SAASqgB,UAAUoI;gBAC3BpK,QAAQ,IAAI2J,MAAMU,YAAYC,UAAU,cAAcrhB,MAAMjB,UAAUgb,YAAYxe;gBAClFqW,MAAMmF,QAAQ2J,MAAMY,KAAK/lB,SAInB;oBACNwb,OAASyJ,cAAczJ,QAAQ0J,kBAAkB1J;oBACjDnF,KAAO4O,cAAc5O,MAAM6O,kBAAkB7O;;gBA7D9C,IARInZ,EAAE8M,QAAQwR,WACbnF,MAAMhY,QAAQmd,MAAM,KAAKA,MAAM,IAC/BA,QAAQnd,QAAQmd,MAAM,KAAKA,MAAM;qBAEd5d,MAAhB4d,MAAMA,UACTnF,MAAMhY,QAAQmd,MAAMA,QAAQA,MAAMnF,KAClCmF,QAAQnd,QAAQmd,MAAMnF,MAAMmF,MAAMA;gBAEd,mBAAVA,OAAoB;oBAC9BA,QAAQyJ,cAAczJ,QAAQ0J,kBAAkB1J,QAChDnF,MAAM4O,cAAc5O,MAAM6O,kBAAkB7O;oBAC5CA,MAAqB,mBAAPA,MAAmBA,MAAMmF;oBAKvC,IAAIwK,aAAaxW,WAAW/K,MAAMwhB,cAAcC,eAAezrB,QAAQ0rB,oBAAoB1hB,MAAMwhB,cAAcC,eAAezrB,QAAQ0rB,iBAAiB1hB,OAAO,QAAQA,MAAM2hB,cAAcC,YAAYhQ;oBAItM,IAHA5R,MAAM6hB,aAAaN,aAAavhB,MAAM8hB,cAAcP,aAAa,GAEjEvhB,MAAMjB,UAAU0a,WAAW;wBAAC1C,OAAOA;wBAAOnF,KAAKA;uBAC3C5R,UAAUtH,SAASmmB,eAAe;wBACrC,IAAI,uBAAuB7e,OAC1BA,MAAM+hB,kBAAkBhL,OAAOnF,WACzB,IAAI5b,OAAO6qB,cAAc;4BAE/B,IADAH,QAAQhoB,SAASyoB,oBACQhoB,MAArB6G,MAAMgiB,cAAiD,SAArBhiB,MAAMgiB,YAAqB;gCAChE,IAAIC,WAAWvpB,SAASwpB,eAAe;gCACvCliB,MAAMmiB,YAAYF;;4BAEnBvB,MAAM0B,SAASpiB,MAAMgiB,YAAYjL,QAAQ/W,MAAMjB,UAAUgb,YAAYxe,SAASwb,QAAQ/W,MAAMjB,UAAUgb,YAAYxe;4BAClHmlB,MAAM2B,OAAOriB,MAAMgiB,YAAYpQ,MAAM5R,MAAMjB,UAAUgb,YAAYxe,SAASqW,MAAM5R,MAAMjB,UAAUgb,YAAYxe;4BAC5GmlB,MAAM4B,UAAS;4BACf,IAAIC,MAAMvsB,OAAO6qB;4BACjB0B,IAAIC,mBACJD,IAAIE,SAAS/B;+BAEH1gB,MAAM0iB,oBAChBhC,QAAQ1gB,MAAM0iB,mBACdhC,MAAM4B,UAAS;wBACf5B,MAAMiC,QAAQ,aAAa/Q,MAC3B8O,MAAMW,UAAU,aAAatK,QAC7B2J,MAAMkC;wBAGPhJ,gBAAgB5Z,OAAO;4BACtB+W,OAAOA;4BACPnF,KAAKA;;;;;YA6BV,SAASiR,8BAA8BC;gBACtC,IAAIxrB,SAASgW,iBAAgB,GAAMkB,yBAAwB,IAAM,IAChEuU,KAAKzrB,OAAOiE,QACZpE,KAAK+hB,MAAM1K,wBACXwU,YAAY,IACZC,SAAS/rB,QAAQqQ,eAAe2R,MAChCrL,iBAAuB1U,MAAX8pB,SAAuBA,OAAO/U,QAAQ7I,eAAUlM,GAC5D2U;gBACD,KAAK3W,MAAM+hB,MAAM,GAAG/hB,MAAMG,OAAOiE,QAAQpE,OACxC2W,UAAUM,gBAAgBjX,KAAK0W,WAAW1W,MAAM;gBAChD0W,YAAYC,QAAQI,QAAQ7I,SAC5B2d,UAAU7rB,OAAOsB,EAAEc,QAAO,GAAM,IAAIuU;gBAGrC,IAAIoV,YAAYD,eAAiC9pB,MAAvB8pB,OAAO/T,cAA4B+T,OAAO/U,QAAQ+U,OAAO/T,oBAAe/V;gBAClG,KAAKhC,MAAM4rB,KAAK,GAAS7J,MAAN/hB,QAClB2W,UAAUkV,UAAU7rB,OACf2W,QAAQxF,MAAM0B,eAChB8D,QAAQxF,MAAM0H,sBAAsBlC,QAAQxF,MAAM2B,kBAClDiZ,cAEEA,cAAcF,UAAU7rB,KAAK+W,QAAQ+U,OAAO/T,gBAAwC,KAAxBpB,QAAQxF,MAAR,WACnC,MAAzBwF,QAAQxF,MAAR,UACAwF,QAAQI,QAAQ+U,OAAO/T,gBACvB4F,sBAAsBhH,QAAQI,QAAQ+U,OAAO/T,aAAaC,WAAW9L,MAAM,MAAM6f,UAAU/T,WAAW9L,MAAM,SACnF,OAAzB4K,SAAS9W,KAAK,GAAG+S,SAIrB5S,OAAOH,SAASgX,eAAehX,KAAK2W,QAAQxF,SAdhBnR,OAe5B4rB;gBAKF,OAAOD,mBAAmB;oBACzBjR,GAAKkR;oBACL7Y,KAAO8Y,UAAUD,MAAMC,UAAUD,IAAIza,aAAQnP;oBAC1C4pB;;YAGL,SAASpV,kBAAkBrW;gBAC1BA,OAAOiE,SAAS;gBAEhB,KADA,IAAI0E,WAAWqN,iBAAgB,GAAM,IAAG,QAAMnU,IAAW,IAAOiR,WAC3BjR,OAA7BiR,OAAOnK,SAASkT,YAAwB7b,OAAO6L,KAAKiH;gBAC5D,OAAO9S;;YAGR,SAASkG,WAAWlG;gBACnB,IAAImB,EAAE+D,WAAWnF,KAAKmG,aAAa,OAAOnG,KAAKmG,WAAWlG,QAAQD;gBAClE,IAAoB,QAAhBA,KAAK6E,QAAT;oBACA,IAAIinB,YAAW,GACdC,MAAMP,+BAA8B,IACpCQ,MAAM9J,aAAa6J,IAAIvR;oBAExB,SAAgB1Y,MAAZiqB,IAAIlZ,OAAqBkZ,IAAIlZ,IAAID,kBAAkBmZ,IAAIlZ,IAAIF,eAAeoZ,IAAIlZ,IAAI8F,oBAAoB;wBACzGmT,YAAW;wBACX,KAAK,IAAIptB,IAAI,GAAGA,KAAKstB,KAAKttB,KAAK;4BAC9B,IAAIyB,OAAO4W,gBAAgBrY,GAAGuS;4BAC9B,KAAqB,MAAhB9Q,KAAI,eAAkD2B,MAA9BjC,QAAQqQ,eAAexR,OAAyC,MAArByB,KAAKwS,gBAAoD,MAA5BxS,KAAKwY,uBAAiD,MAAhBxY,KAAI,UAAoBF,OAAOvB,OAAOoY,eAAepY,GAAGyB,OAAQ;gCAC1M2rB,YAAW;gCACX;;;;oBAIH,OAAOA;;;YAIR,SAASnH,aAAahc,OAAO8b,GAAG3kB,KAAKC,QAAQqe;gBAC5C,KAAIpe,KAAKwC,gBAAgBD,WACpBkiB,MAAM5lB,UAAUyK,QAAQC,YAC3Bkb,IAAI5lB,UAAUyK,QAAQG,SACZgb,MAAM5lB,UAAUyK,QAAQG,WAClCgb,IAAI5lB,UAAUyK,QAAQC;gBAGnBhH,QAAO;oBACV,IAAI0pB,OAAOnsB,IAAIya;oBACfza,IAAIya,MAAMza,IAAI4f,OACd5f,IAAI4f,QAAQuM;;gBAoBd,IAhBIxH,MAAM5lB,UAAUyK,QAAQC,aAAczJ,IAAIya,MAAMza,IAAI4f,QAAQ,KAC/D5f,IAAI4f,QAAQwC,aAAapiB,IAAI4f;qBACa5d,MAAtCjC,QAAQqQ,eAAepQ,IAAI4f,UAAwB7f,QAAQqQ,eAAepQ,IAAI4f,OAAO/W,UAAU3I,KAAK6F,kBACvG/F,IAAI4f,WAEK+E,MAAM5lB,UAAUyK,QAAQG,UAAU3J,IAAI4f,UAAU5f,IAAIya,QAC9Dza,IAAIya,MAAMoG,OAAO7gB,IAAIya,MAAK,MAAU1a,QAAQqQ,eAAepQ,IAAIya,QAAQ1a,QAAQqQ,eAAepQ,IAAIya,KAAK5R,UAAU3I,KAAK2F,aACrH7F,IAAIya,MAAM,IACVkG,SAAS3gB,IAAIya,OAAO;qBACqBzY,MAAtCjC,QAAQqQ,eAAepQ,IAAI4f,UAAwB7f,QAAQqQ,eAAepQ,IAAI4f,OAAO/W,UAAU3I,KAAK6F,kBACvG/F,IAAIya;gBAINyF,eAAelgB,OAEA,MAAXC,WAAuC,MAApBC,KAAK8F,cAAuC,SAAf9F,KAAKV,OAAgB;oBACxE,IAAIghB,SAASpC,WAAU;oBACvB,IAAIoC,QAAQ;wBACX,IAAIY,cAA0Bpf,MAAjBwe,OAAOjD,QAAsBiD,OAAOjD,QAASiD,OAAOxgB,MAAM2gB,SAASH,OAAOxgB,IAAI4f,QAAQY,OAAOxgB,IAAI4f,QAAQY,OAAOxgB,OAAOqX,sBAAsB,IAAG;yBACzJsN,MAAM5lB,UAAUyK,QAAQG,UAAU3J,IAAI4f,QAAQwB,WACjDphB,IAAI4f;;;gBAIP,IAAImC,MAAM1K,qBAAqBrX,IAAI4f,QAAO;gBAC1C,IAAImC,MAAM/hB,IAAI4f,UAAwB,MAAf5f,IAAI4f,OAE1B7f,QAAQ2D,IAAIid,SAASoB,WACf,KAAe,MAAX9hB,WACVF,QAAQ2D,IAAI1D,IAAI4f;iBACI,MAAhBtB,cAEH,MAAOve,QAAQ2D,IAAIqe,YAA6C/f,MAAtCjC,QAAQqQ,eAAerQ,QAAQ2D,MACxD3D,QAAQ2D;;YAMZ,SAAS0oB,oBAAoBvjB;gBAC5B,IAAIwjB,iBAAiBxjB,MAAMwhB,cAAcC,eAAezrB,QAAQ0rB,iBAAiB1hB,OAAO;gBAExF,SAASyjB,aAAaC;oBAErB,IAAI5e,IAAIpM,SAAS8T,cAAc,SAC9BiN;oBACD,KAAK,IAAIve,SAASsoB,eACb9X,MAAMxQ,WAAqC,MAA3BA,MAAMT,QAAQ,YACjCqK,EAAE5J,MAAMA,SAASsoB,cAActoB;oBAGjC4J,EAAE5J,MAAMyoB,gBAAgBH,cAAcG,eACtC7e,EAAE5J,MAAM0oB,gBAAgBJ,cAAcI;oBACtC9e,EAAE5J,MAAM0O,WAAW,YACnB9E,EAAE5J,MAAM2oB,SAAS,QACjB/e,EAAE5J,MAAM4oB,QAAQ;oBAChBhf,EAAE5J,MAAM6oB,aAAa,UACrBjf,EAAE5J,MAAM8oB,aAAa,UAErBtrB,SAASurB,KAAK9B,YAAYrd;oBAC1B,IAAIof,YAAYlkB,MAAMjB,UAAUgb,aAC/BoK,gBAAgB,GAChBC;oBACD,KAAK3K,WAAW,GAAG2K,MAAMF,UAAU3oB,QAAQke,YAAY2K,KAAK3K,YAAY;wBAEvE,IADA3U,EAAEuf,aAAaH,UAAUrc,OAAO4R,aAAa,KACzC3U,EAAEwf,eAAeZ,SAAS;4BAC7B,IAAIa,UAAWb,UAAUS,eACrBK,UAAU1f,EAAEwf,cAAcZ;4BAC9B5e,EAAEuf,YAAYH,UAAUrc,OAAO4R,WAC/B8K,WAAYzf,EAAEwf,cAAc,GAC5B7K,WAAW8K,UAAUC,UAAU/K,WAAW,IAAIA;4BAC9C;;wBAED0K,gBAAgBrf,EAAEwf;;oBAGnB,OADA5rB,SAASurB,KAAKQ,YAAY3f,IACnB2U;;gBAGR,IAAIxZ,WAAWvH,SAAS8T,cAAc;gBACtCvM,SAAS/E,MAAM4oB,QAAQN,cAAcM,OACrC7jB,SAAS/E,MAAMC,YAAYqoB,cAAcroB;gBACzC8C,YAAYvF,SAAS8T,cAAc,QACnCxM,MAAMjB,UAAUd,YAAYA;gBAC5BA,UAAUymB,YAAY,gBACtB1kB,MAAMghB,WAAW2D,aAAa1mB,WAAW+B;gBACzCA,MAAMghB,WAAWyD,YAAYzkB,QAC7B/B,UAAUkkB,YAAYniB,QACtB/B,UAAUkkB,YAAYliB;gBACtBD,MAAM9E,MAAMgF,OAAOD,SAASE,aAAa,MAEzC1H,EAAEwF,WAAW2E,GAAG,cAAc,SAAUkC;oBACvC,OAAO8W,cAAcgD,gBAAgBniB,KAAKuD,OAAO,EAAC8E;oBAEnDrM,EAAEwF,WAAW2E,GAAG,cAAc,SAAUkC;oBACvC,OAAO8W,cAAcwD,gBAAgB3iB,KAAKuD,OAAO,EAAC8E;oBAEnDrM,EAAEwF,WAAW2E,GAAG,SAAS,SAAUkC;oBAElC,OADA4P,MAAM1U,OAAOyjB,aAAa3e,EAAE8f,WACrBhJ,cAAc+C,WAAWliB,KAAKuD,OAAO,EAAC8E;;;YAK/C,SAAS8U,gBAAgB5Z,OAAOyZ,UAAUoL;gBACzC,IAAIjX,eAAe,IAClBkX,YAAW,GACXttB,MAAMsW,SAASD,WAAW1W,MAAM;gBAGjC,SAAS4tB,SAAS5G;oBAEjB,SADchlB,MAAVglB,UAAqBA,QAAQ,KAC5B2G,aAA6B,MAAhBttB,KAAI,eAAsC2B,MAAlB2U,QAAQ9N,OAG3C,IAAI8kB,cAA8B,MAAhBttB,KAAI,eAAsC2B,MAAlB2U,QAAQ9N,SAAqC,OAAbxI,KAAK0S,MAAa;wBAClG4a,YAAW;wBACX,IAAIE,MAAMpX,aAAarS;wBACvBqS,aAAaoX,MAAM,KAAKpX,aAAaoX,MAAM,KAAK,WAChDpX,aAAazK,KAAKgb;2BAElBvQ,aAAazK,KAAKgb,aARlB2G,YAAW,GACXlX,aAAazK,KAAK,6BAA6Bgb;;gBAWjD,SAAS8G;oBACJvsB,SAASmmB,kBAAkB7e,UAC9B4N,aAAa/J,OAAO4V,SAAS1C,OAAO,GAClC0C,SAAS1C,UAAU0C,SAAS7H,OAAO6H,SAAS7H,MAAM1a,QAAQyQ,aAC1D,uFACA;oBACFiG,aAAa/J,OAAO4V,SAAS7H,MAAM,GAAG,GAAG;;gBAI3C,SAAkBzY,MAAd8E,WAAyB;oBAC5B,IAAI3G,SAAS8c;oBAUb,SATiBjb,MAAbsgB,WACHA,WAAW/E,MAAM1U,cACY7G,MAAnBsgB,SAAS1C,UACnB0C,WAAW;wBACV1C,OAAO0C;wBACP7H,KAAK6H;yBAIO,MAAVoL,OAAgB;wBAEnB,KADA,IAAI3L,MAAM1K,wBAELtX,QAAQqQ,eAAepQ,QAC1B2W,UAAU5W,QAAQqQ,eAAepQ;wBACjCK,OAAOsW,QAAQxF,OACfuF,YAAYC,QAAQI,QAAQ7I,SAC5B0f,SAASztB,OAAOH,UAEhB2W,UAAUM,gBAAgBjX,KAAK0W,WAAW1W,MAAM;wBAChDK,OAAOsW,QAAQxF,OACfuF,YAAYC,QAAQI,QAAQ7I,UACJ,MAApBhO,KAAKuG,cAAwBzG,MAAM+hB,OAAmC,mBAApB7hB,KAAKuG,cAA2ByQ,SAAShX,KAAKuG,eAAevG,KAAKuG,aAAazG,MACpI4tB,SAAS5W,eAAehX,KAAKK,SAE7BstB,YAAW;wBAGb3tB,aACuBgC,MAAd+T,aAA2B/V,MAAM+V,gBAA+B,MAAhB1V,KAAI,UAAiC,OAAbA,KAAK0S,QAAqB/S,MAAN+hB,OAAa4L;wBAC/GA,YAAUC,YACdE;;oBAGD,IAAIhlB,WAAWhC,UAAUinB,qBAAqB,OAAO;oBACrDjlB,SAASokB,YAAYzW,aAAalN,KAAK,KACvCV,MAAMjB,UAAUgB,kBAAkBC,OAAOC;;;YAI3C,SAASwe,gBAAgBze,OAAOV;gBAC/BU,MAAMjB,UAAU1F,gBAAe,GAC3BZ,EAAE+D,WAAWnF,KAAKkF,kBAAe+C,QAAQjI,KAAKkF,aAAaE,KAAKsC,WAAWO,OAAOjI,SAASiI;gBAC/FA,QAAQA,MAAM6P,WAAW9L,MAAM,KAC/B8Y,SAASnc,QAAO,IAAM,GAAOV,QAC7BuN,YAAYuH,YAAY1T,KAAK;iBACxBrJ,KAAK+E,wBAAwB/E,KAAKmB,oBAAoBwH,MAAMjB,UAAUgb,gBAAgB5F,oBAAoBzT,KAAK,QAAmC,MAA5B8N,0BAC1HxO,MAAMjB,UAAU4a,UAAU;;YAI5B,SAAS5iB,KAAKiL;gBACb,SAASmjB,uBAAuBnlB,OAAO3I;oBACtC,SAAS+tB,mBAAmBjrB;wBAC3B,IAAIkrB,UACAC;wBAEJ,SAASC,aAAalhB;4BACrB,IAAI5L,EAAEkN,kBAAkCxM,MAArBV,EAAEkN,SAAStB,UAA2D,MAApC5L,EAAEkN,SAAStB,MAAMmhB,iBAA0B;gCAC/F,IAAIC,aAAahtB,EAAEkN,SAAStB,SAAS5L,EAAEkN,SAAStB,MAAMqhB,MAAMjtB,EAAEkN,SAAStB,MAAMqhB,MAAM,SAAU1jB;oCAC5F,OAAOA,KAAK1C;mCAETqmB,aAAaltB,EAAEkN,SAAStB,SAAS5L,EAAEkN,SAAStB,MAAMuhB,MAAMntB,EAAEkN,SAAStB,MAAMuhB,MAAM,SAAU5jB,MAAM1C;oCAElG,OADA0C,KAAK1C,QAAQA,OACN0C;;gCAGRvJ,EAAEkN,SAAStB,QAAQ;oCAClBqhB,KAAK,SAAAA,IAAU1jB;wCACd,IAAIA,KAAKjD,WAAW;4CACnB,IAAIiD,KAAKjD,UAAU1H,KAAKR,YACvB,OAAOmL,KAAKjD,UAAUM;4CAEtB,IAAIsY,SAAS8N,WAAWzjB;4CACxB,QAA8F,MAAvFwM,0BAAqBrV,QAAWA,GAAW6I,KAAKjD,UAAU7H,QAAQqQ,oBAA4C,MAAlBlQ,KAAKwG,WAAoB8Z,SAAS;;wCAGtI,OAAO8N,WAAWzjB;;oCAGpB4jB,KAAK,SAAAA,IAAU5jB,MAAM1C;wCACpB,IAAIqY,SAASgO,WAAW3jB,MAAM1C;wCAI9B,OAHI0C,KAAKjD,aACR0f,gBAAgBzc,MAAM1C,QAEhBqY;;oCAER6N,iBAAgB;;;;wBAKnB,SAASK;4BACR,OAAI5sB,KAAK8F,YACD9F,KAAK8F,UAAU1H,KAAKR,aAC1BoC,KAAK8F,UAAUM,mBACc,MAA5BmP,2BAAmD,MAAlBnX,KAAKwG,WACrCnF,SAASmmB,kBAAkB5lB,QAAQ5B,KAAK+E,wBACvCxC,QAAQ+T,kBAAkByG,YAAY/O,SAASgC,YAAYsG,kBAAkByG,YAAY/O,UAAU3E,KAAK,MACzG2kB,SAAS5oB,KAAKxD,QACf,KAEKosB,SAAS5oB,KAAKxD;;wBAIvB,SAAS6sB,OAAOxmB;4BACfgmB,SAAS7oB,KAAKxD,MAAMqG,QAChBrG,KAAK8F,aACR0f,gBAAgBxlB,MAAMqG;;wBAIxB,SAASymB,8BAA8B5rB;4BACtC8gB,WAAWrY,GAAGzI,KAAK,cAAc;gCAChC,IAAI6F,QAAQ/G,MACXqG,QADWrG,KACG8F,UAAUgb,WAAU;gCAC/Bza,WAAW1F,QAAQwa,YAAY/M,YAAY+M,aAAa1T,KAAK,OAChE+d,gBAHWxlB,MAGYqG;;;wBAK1B,KAAKnF,IAAI4E,UAAUinB,YAAY;4BAC9B,KAA6B,MAAzB3uB,KAAK0G,iBAA0B;gCAClC,IAAI1C,OAAO4qB,0BAA0B;oCACC,qBAA1B5qB,OAAO6qB,mBACjB7qB,OAAO6qB,iBAA6C,aAA5B9mB,QAAO,OAAO+mB,aAAyB,SAAUC;wCACxE,OAAOA,OAAOD;wCACX,SAAUC;wCACb,OAAOA,OAAOxgB,YAAY5L;;oCAI5B,IAAIqsB,gBAAgBhrB,OAAO6qB,iBAAiB7qB,OAAO4qB,yBAAyB5qB,OAAO6qB,eAAe/rB,MAAM,gBAAWhB;oCAC/GktB,iBAAiBA,cAAcX,OAAOW,cAAcT,OACvDP,WAAWgB,cAAcX;oCACzBJ,WAAWe,cAAcT,KACzBvqB,OAAOirB,eAAensB,KAAK,SAAS;wCACnCurB,KAAKG;wCACLD,KAAKE;wCACLS,eAAc;0CAEW,YAAhBpsB,IAAIqsB,YACdnB,WAAW,SAAAA;wCACV,OAAOpsB,KAAKwtB;uCAEbnB,WAAW,SAAAA,SAAUhmB;wCACpBrG,KAAKwtB,cAAcnnB;uCAEpBjE,OAAOirB,eAAensB,KAAK,SAAS;wCACnCurB,KAAKG;wCACLD,KAAKE;wCACLS,eAAc;;uCAGN7tB,SAASguB,oBAAoBvsB,IAAIusB,iBAAiB,aAC5DrB,WAAWlrB,IAAIusB,iBAAiB;gCAChCpB,WAAWnrB,IAAIwsB,iBAAiB,UAEhCxsB,IAAIysB,iBAAiB,SAASf;gCAC9B1rB,IAAI0sB,iBAAiB,SAASf;gCAE/B3rB,IAAI4E,UAAUinB,aAAaX,UAC3BlrB,IAAI4E,UAAU+nB,aAAaxB;;4BAE5BnrB,IAAI4E,UAAUgb,YAAY,SAAUgN;gCACnC,OAAOntB,UAAyB,MAAhBmtB,cAAuB1B,SAAS5oB,KAAKxD,KAAKC,IAAImK,MAAM,IAAIgE,UAAU3G,KAAK,MAAM2kB,SAAS5oB,KAAKxD,KAAKC;+BAEjHiB,IAAI4E,UAAU4a,YAAY,SAAUra,OAAOynB;gCAC1CzB,SAAS7oB,KAAKxD,KAAKC,IAAKoG,gBAAyC,MAAuB,MAAhBynB,eAAwBntB,QAAS0F,MAAM+D,MAAM,IAAIgE,UAAU3G,KAAK,MAAMpB;oCAG9HnG,MAAbksB,aACHA,WAAW,SAAAA;gCACV,OAAOpsB,KAAKqG;+BAEbgmB,WAAW,SAAAA,SAAUhmB;gCACpBrG,KAAKqG,QAAQA;+BAEdimB,aAAaprB,IAAIkK,OACjB0hB,8BAA8B5rB;;;oBAKjC,IAAI6sB,cAAchnB,MAAMxF,aAAa,SACjCkS,cAAiC,YAAlB1M,MAAMwmB,YAA2E,MAApD/tB,EAAEgN,QAAQuhB,aAAa3vB,KAAKiG,sBAA8B0C,MAAMinB,qBAAuC,eAAlBjnB,MAAMwmB;oBAC3I,KAAK9Z,aACJ,IAAsB,YAAlB1M,MAAMwmB,SAAqB;wBAC9B,IAAIttB,KAAKR,SAAS8T,cAAc;wBAChCtT,GAAGyT,aAAa,QAAQqa,cACxBta,cAA0B,WAAZxT,GAAGmL,MACjBnL,KAAK;2BAELwT,cAAc;oBAQhB,QALoB,MAAhBA,cACH0Y,mBAAmBplB,SAEnBA,MAAMjB,iBAAY5F;oBAEZuT;;gBAIRuO,WAAWzX,IAAIxB;gBACf,IAAI0K,cAAcyY,uBAAuBnjB,MAAM3K;gBAC/C,KAAoB,MAAhBqV,gBACHxT,KAAK8I,MACL8K,MAAMrU,EAAES,KAERkU,sBAAsBlU,GAAGsC;gBAGzB0R,iBAAmB/T,MAAPD,KAAmBA,GAAGgU,iBAAY/T,IAC3B,MAAf+T,cAAkBA,iBAAY/T;iBAEX,MAAnB9B,KAAK4G,aACRslB,oBAAoBrqB,KAEjBiT,WACC,eAAejT,OAClBA,GAAGtB,YAAYP,KAAKO;gBACpBsB,GAAGyT,aAAa,aAAatV,KAAKO,cAEA,MAA/BP,KAAK6G,0BACJ,iBAAiBhF,KACpBA,GAAGguB,eAAc,MAEM,MAAnB7vB,KAAK4G,aACRslB,oBAAoBrqB;gBAErBA,GAAGmL,OAAO,gBAKO,MAAhBqI,gBACHxT,GAAGyT,aAAa,kBAAkBtV,KAAKgF;gBAGvC4e,WAAWrY,GAAG1J,IAAI,UAAU0iB,cAAcyD,cAC1CpE,WAAWrY,GAAG1J,IAAI,SAAS0iB,cAAc0D;gBACzCrE,WAAWrY,GAAG1J,IAAI,WAAW0iB,cAAc2D,eAC3CtE,WAAWrY,GAAG1J,IAAI,QAAQ0iB,cAAcuD;gBACxClE,WAAWrY,GAAG1J,IAAI,SAAS0iB,cAAc8C,cAClB,MAAnBrnB,KAAK4G,cACRgd,WAAWrY,GAAG1J,IAAI,SAAS0iB,cAAc+C;gBACzC1D,WAAWrY,GAAG1J,IAAI,cAAc0iB,cAAcgD,kBAC9C3D,WAAWrY,GAAG1J,IAAI,cAAc0iB,cAAcwD;gBAE/CnE,WAAWrY,GAAG1J,IAAI,SAAS0iB,cAAcgB,aACzC3B,WAAWrY,GAAG1J,IAAI,OAAO0iB,cAAcmD;gBACvC9D,WAAWrY,GAAG1J,IAAI,YAAY7B,KAAKyE,aACnCmf,WAAWrY,GAAG1J,IAAI,cAAc7B,KAAK2E;gBACrCif,WAAWrY,GAAG1J,IAAI,WAAW7B,KAAK4E,YAC7BkQ,WAAkC,MAAxB9U,KAAKyG,iBAInB5E,GAAGkC,gBAAgB,gBAHnB6f,WAAWrY,GAAG1J,IAAI,WAAW0iB,cAAcC;gBAC3CZ,WAAWrY,GAAG1J,IAAI,YAAY0iB,cAAcQ,iBAI7CnB,WAAWrY,GAAG1J,IAAI,SAAS0iB,cAAc0B;gBACzCrC,WAAWrY,GAAG1J,IAAI,eAAe0iB,cAAc0C,oBAEhDrD,WAAWrY,GAAG1J,IAAI,YAAY0iB,cAAc4C;gBAG5C3R,YAAYsH,oBAAoBzT,KAAK,KACA,OAAjCxH,GAAG6F,UAAUgb,WAAU,OAA8C,MAA9B1iB,KAAK+E,wBAAkC1D,SAASmmB,kBAAkB3lB,KAAI;oBAChH,IAAIiuB,eAAe1uB,EAAE+D,WAAWnF,KAAKkF,iBAAiBlF,KAAKkF,aAAaE,KAAKsC,WAAW7F,GAAG6F,UAAUgb,WAAU,IAAO1iB,SAAyC6B,GAAG6F,UAAUgb,WAAU;oBACjK,OAAjBoN,gBAAqBhL,SAASjjB,KAAI,IAAM,GAAOiuB,aAAa9jB,MAAM;oBACtE,IAAI/L,SAAS8c,YAAY/O;oBACzBwH,YAAYvV,OAAOoJ,KAAK,MAEG,MAAvBlD,WAAWlG,WACVD,KAAKmB,mBACR8V;oBAGEjX,KAAK+E,wBAAwB1D,SAASmmB,kBAAkB3lB,QAC3B,MAA5BsV,yBACHlX,SAAS,KAETqW,kBAAkBrW;sBAGc,MAA9BD,KAAK+E,wBAAmC/E,KAAKsF,mBAAmBjE,SAASmmB,kBAAkB3lB,MAAwC,OAAjCA,GAAG6F,UAAUgb,WAAU,OAC5HP,YAAYtgB,IAAI5B;oBAEboB,SAASmmB,kBAAkB3lB,MAC9Bwb,MAAMxb,IAAI4e,SAAStJ;;;YAQvB,SAAkBrV,MAAdyT,WACH,QAAQA,UAAU1N;cACjB,KAAK;gBAEJ,OADAhG,KAAK0T,UAAU1T,IACRsE,WAAW4W;;cACnB,KAAK;gBAOJ,YANWjb,MAAPD,WAAwCC,MAApByT,UAAUtN,UACjCkgB,cAAc5S,UAAUtN;gBACxBkgB,eAAe/mB,EAAE+D,WAAWnF,KAAKkF,iBAAiBlF,KAAKkF,aAAaE,KAAKsC,WAAWygB,aAAanoB,SAAwBmoB,aAAanc,MAAM;gBAC5I8Y,SAAS1f,KAAKxD,WAAME,IAAW,IAAO,GAAOqmB,cACzC/mB,EAAE+D,WAAWnF,KAAKqF,kBAAgBrF,KAAKqF,cAAcD,KAAKsC,gBAAW5F,GAAWib,aAAa,GAAG/c;gBAE9FgI,cAAcnG;;cACtB,KAAK;gBACJnC,KAAKmC;gBACL;;cACD,KAAK;gBAGJ,OAFAsmB,eAAe/mB,EAAE+D,WAAWnF,KAAKkF,iBAAiBlF,KAAKkF,aAAaE,KAAKsC,WAAW6N,UAAUtN,OAAOjI,SAA4BuV,UAAUtN,OAAO+D,MAAM;gBACxJ8Y,SAAS1f,KAAKxD,WAAME,IAAW,IAAM,GAAOqmB,cACxC5S,UAAUhN,WACN;oBACNN,OAAO1F,QAAQwa,YAAY/O,QAAQgC,UAAU3G,KAAK,MAAM0T,YAAY1T,KAAK;oBACzEd,UAAU/G,UAAU4D,KAAKxD,MAAM;wBAC9BiG,QAAU;uBACRhI,SAASG;oBAIPuC,QAAQwa,YAAY/O,QAAQgC,UAAU3G,KAAK,MAAM0T,YAAY1T,KAAK;;cAC1E,KAAK;gBACAkM,UAAUtN,SACbkgB,cAAc5S,UAAUtN,MAAM+D,MAAM,KACpC8Y,SAAS1f,KAAKxD,WAAME,IAAW,IAAM,GAAOqmB,gBAE5C5S,UAAUtN,QAAQ1F,QAAQwa,YAAY/O,QAAQgC,UAAU3G,KAAK,MAAM0T,YAAY1T,KAAK;gBAKrF,KAHA,IAAIpJ,SAAS8c,aACTgT,KAAKvE,iCACRwE,OAAO/vB,OAAOiE,SAAS,GACV6rB,KAAPC,SACFrP,OAAOqP,OADMA;gBAKlB,OAFA/vB,OAAOuM,OAAOujB,IAAIC,OAAO,IAAID,KAEtB5pB,WAAWlG,WAAWsV,UAAUtN,WAAW1F,QAAQwa,YAAY/O,QAAQgC,UAAU3G,KAAK,MAAM0T,YAAY1T,KAAK;;cACrH,KAAK;gBACJ,OAAOyT,oBAAoBzT,KAAK;;cACjC,KAAK;gBACJ,IAAIxH,MAAMA,GAAG6F,WAAW;oBACvBtG,EAAEwG,KAAK/F,IAAI,mBAAmB,OAC9B4T,MAAMrU,EAAES;oBAER,IAAIouB,KAAKjwB,KAAKR,aAAawI,cAAcnG,MAAMA,GAAG6F,UAAUgb,UAAU1iB,KAAKR,aAYvEwvB;oBAXAiB,OAAOnT,oBAAoBzT,KAAK,MAAKxH,GAAG6F,UAAU4a,UAAU2N,IAAIjwB,KAAKR,cAAkBqC,GAAG6F,UAAU4a,UAAU;oBAElHsB,WAAWzX,IAAItK,KAEXA,GAAG6F,UAAUd,cAChBA,YAAY/E,GAAG6F,UAAUd;oBACzBA,UAAUwmB,YAAYvrB,KACtB+E,UAAU+iB,WAAW2D,aAAazrB,IAAI+E,YACtCA,UAAU+iB,WAAWyD,YAAYxmB;oBAI9B5C,OAAO4qB,4BAA4B5qB,OAAO6qB,kBAC7CG,gBAAgBhrB,OAAO4qB,yBAAyB5qB,OAAO6qB,eAAehtB,KAAK;qBACvEmtB,iBACCntB,GAAG6F,UAAUinB,cAChB3qB,OAAOirB,eAAeptB,IAAI,SAAS;wBAClCwsB,KAAKxsB,GAAG6F,UAAUinB;wBAClBJ,KAAK1sB,GAAG6F,UAAU+nB;wBAClBP,eAAc;0BAIP7tB,SAASguB,oBAAoBxtB,GAAGwtB,iBAAiB,YACvDxtB,GAAG6F,UAAUinB,eAChB9sB,GAAG0tB,iBAAiB,SAAS1tB,GAAG6F,UAAUinB;oBAC1C9sB,GAAG2tB,iBAAiB,SAAS3tB,GAAG6F,UAAU+nB,cAI5C5tB,GAAG6F,iBAAY5F;;gBAEhB,OAAOD;;cACR,KAAK;gBACJ,IAAIT,EAAE8M,QAAQrO,QAAQ0I,WAAW;oBAChC,IAAI2nB,aAAaja,iBAAgB,GAAM,IAAG,GAAO5M,KAAK;oBAOtD,OANAjI,EAAEmG,KAAK1H,QAAQ0I,UAAU,SAAUf,KAAK2oB;wBACvC,IAAIA,KAAKzwB,SAASwwB,YAEjB,OADAA,aAAaC,OACN;wBAGFD;;gBAGR,OAAOrwB,QAAQ0I;;;;;;;;;;;QCh9EnB,IAAI1J,YAAYD,oBAAQ,IAAiBwC,IAAIvC,UAAU4L,eAItD2lB,aAAa;YACZC,GAAG,EAAC,yBAAyBC,KAAK3tB,UAAU4tB,SAAS,OAAOD,KAAK3tB,UAAU6tB;YAC3EC,IAAI,EAAC,0BAA0BH,KAAK3tB,UAAU4tB,SAAS,OAAO;gBAC7D,OAAOG,IAAIJ,KAAK3tB,UAAU6tB,QAAQprB,KAAKxD,OAAO;;YAE/C+uB,KAAK,EAAC;YACNC,MAAM,EAAC;YACP1f,GAAG,EAAC,gBAAgBof,KAAK3tB,UAAUkuB,UAAU,SAAS;gBACrD,OAAOP,KAAK3tB,UAAUmuB,SAAS1rB,KAAKxD,QAAQ;;YAE7CmvB,IAAI,EAAC,iBAAiBT,KAAK3tB,UAAUkuB,UAAU,SAAS;gBACvD,OAAOH,IAAIJ,KAAK3tB,UAAUmuB,SAAS1rB,KAAKxD,QAAQ,GAAG;;YAEpDovB,KAAK,EAAC;YACNC,MAAM,EAAC;YACPC,IAAI,EAAC,YAAYZ,KAAK3tB,UAAUwuB,aAAa,QAAQ;gBACpD,OAAOT,IAAIJ,KAAK3tB,UAAUyuB,YAAYhsB,KAAKxD,OAAO;;YAEnDyvB,MAAM,EAAC,YAAYf,KAAK3tB,UAAUwuB,aAAa,QAAQ;gBACtD,OAAOT,IAAIJ,KAAK3tB,UAAUyuB,YAAYhsB,KAAKxD,OAAO;;YAEnD0vB,GAAG,EAAC,gBAAgBhB,KAAK3tB,UAAU4uB,UAAU,SAASjB,KAAK3tB,UAAU6uB;YACrEC,IAAI,EAAC,iBAAiBnB,KAAK3tB,UAAU4uB,UAAU,SAAS;gBACvD,OAAOb,IAAIJ,KAAK3tB,UAAU6uB,SAASpsB,KAAKxD,OAAO;;YAEhD8vB,KAAK,EAAC,UAAUpB,KAAK3tB,UAAU4uB,UAAU,SAASjB,KAAK3tB,UAAU6uB;YACjEG,GAAG,EAAC,kBAAkBrB,KAAK3tB,UAAU4uB,UAAU,SAASjB,KAAK3tB,UAAU6uB;YACvEI,IAAI,EAAC,wBAAwBtB,KAAK3tB,UAAU4uB,UAAU,SAAS;gBAC9D,OAAOb,IAAIJ,KAAK3tB,UAAU6uB,SAASpsB,KAAKxD,OAAO;;YAEhDiwB,KAAK,EAAC,UAAUvB,KAAK3tB,UAAU4uB,UAAU,SAASjB,KAAK3tB,UAAU6uB;YACjEM,GAAG,EAAC,eAAexB,KAAK3tB,UAAUovB,YAAY,WAAWzB,KAAK3tB,UAAUqvB;YACxEC,IAAI,EAAC,6CAA6C3B,KAAK3tB,UAAUovB,YAAY,WAAW;gBACvF,OAAOrB,IAAIJ,KAAK3tB,UAAUqvB,WAAW5sB,KAAKxD,OAAO;;YAElDswB,GAAG,EAAC,eAAe5B,KAAK3tB,UAAUwvB,YAAY,WAAW7B,KAAK3tB,UAAUyvB;YACxEC,IAAI,EAAC,6CAA6C/B,KAAK3tB,UAAUwvB,YAAY,WAAW;gBACvF,OAAOzB,IAAIJ,KAAK3tB,UAAUyvB,WAAWhtB,KAAKxD,OAAO;;YAElD4Y,GAAG,EAAC,YAAY8V,KAAK3tB,UAAU2vB,iBAAiB,gBAAgB;gBAC/D,OAAO5B,IAAIJ,KAAK3tB,UAAU4vB,gBAAgBntB,KAAKxD,OAAO;;YAEvD4wB,GAAG,EAAC,YAAYlC,KAAK3tB,UAAU2vB,iBAAiB,gBAAgB;gBAC/D,OAAO5B,IAAIJ,KAAK3tB,UAAU4vB,gBAAgBntB,KAAKxD,OAAO;;YAEvDogB,GAAG,EAAC;YACJ2B,IAAI,EAAC;YACL8O,GAAG,EAAC;YACJC,IAAI,EAAC;YACLC,GAAG,EAAC;YACJC,GAAG,EAAC;YACJC,GAAG,EAAC;WAELC,cAAc;YACbC,SAAS;YACTC,SAAS;YACTC,aAAa;YACbC,gBAAgB;;QAGlB,SAASC,aAAanzB;YACrB,KAAKA,KAAK4Q,WAAW;gBACpB,IAAIwiB,SAAS;gBACb,KAAK,IAAI5rB,OAAO4oB,aACiB,MAA5BgD,OAAOhwB,QAAQoE,IAAI,OACtB4rB,OAAOtnB,KAAKtE,IAAI;gBAGlBxH,KAAK4Q,YAAY,MAAMwiB,OAAO/pB,KAAK,QAAQ,SAC3CrJ,KAAK4Q,YAAY,IAAI1Q,OAAOF,KAAK4Q,WAAW;;YAG7C,OAAO5Q,KAAK4Q;;QAGb,SAASyiB,YAAYC,WAAWC;YAC/B,SAAQvc,SAASsc,UAAUE,WACN,QAAjBF,UAAUG,QAAgBzc,SAASsc,UAAUI,YAC9C,IAAIpD,KAAKgD,UAAUK,KAAKvC,eAAepa,SAASsc,UAAUM,YAAYN,UAAUO,QAAQP,UAAUK,KAAK7C,aAAa,GAAG,GAAGN,aAAa8C,UAAUG,QACjJF;;QAIJ,SAASO,cAAcR,WAAWtzB;YACjC,IAAIsgB,UAAS;YACb,IAAItgB,KAAKkS,KAAK;gBACb,IAAIohB,UAAS,SAAa;oBACzB,IAAIS,UAAUT,UAAS,QAAYzyB,QAAQ,WAAW,KACrDmzB,UAAUh0B,KAAKkS,IAAI+hB,KAAKrO,OAAO,GAAGmO,QAAQ7vB;oBAC3Coc,SAAS0T,WAAWD;;gBAEjBT,UAAS,SAAaA,UAAS,WAC9BtzB,KAAKkS,IAAIyhB,KAAKO,aAAcl0B,KAAKkS,IAAIyhB,KAAKO,cAC7C5T,SAAStgB,KAAKkS,IAAIyhB,KAAKO,aAAaZ,UAAUK,KAAKO;;YAQtD,OAHI5T,UAAUtgB,KAAKmS,OAAOnS,KAAKmS,IAAIwhB,KAAKO,aAAcl0B,KAAKmS,IAAIwhB,KAAKO,cACnE5T,SAAStgB,KAAKmS,IAAIwhB,KAAKO,aAAaZ,UAAUK,KAAKO;YAE7C5T;;QAKR,SAAS5c,MAAM4E,QAAQ6rB,cAAcn0B,MAAMo0B;YAG1C,KADA,IAAI10B,OAAO,IAAIuR,OACPA,QAAQkiB,aAAanzB,MAAMgU,KAAK1L,WACvC,SAAqBxG,MAAjBqyB,cACH,IAAI/D,WAAWnf,MAAM,KACpBvR,QAAQ,MAAM0wB,WAAWnf,MAAM,IAAI,KAAK,UAExC,QAAQA,MAAM;cACb,KAAK;gBACJvR,QAAQ;gBACR;;cACD,KAAK;gBACJA,QAAQ;gBACR;;cACD;gBACCA,QAAQb,UAAUqK,YAAY+H,MAAM;mBAIvC,IAAImf,WAAWnf,MAAM,KACpB,KAAY,MAARmjB,OAAgBhE,WAAWnf,MAAM,IAAI,IAAI;gBAC5C,IAAIojB,QAAQjE,WAAWnf,MAAM,IAAI;gBACjCvR,QAAQ20B,MAAMjvB,KAAK+uB,aAAaR;mBACtBvD,WAAWnf,MAAM,IAAI,KAC/BvR,QAAQy0B,aAAa,QAAQ/D,WAAWnf,MAAM,IAAI,MAElDvR,QAAQuR,MAAM,SAGfvR,QAAQuR,MAAM;YAIjB,OAAOvR;;QAIR,SAASgxB,IAAI4D,KAAK1pB;YAGjB,KAFA0pB,MAAM5Z,OAAO4Z,MACb1pB,MAAMA,OAAO,GACN0pB,IAAIpwB,SAAS0G,OAAK0pB,MAAM,MAAMA;YACrC,OAAOA;;QAGR,SAAS/yB,YAAYgzB,YAAYjsB,QAAQtI;YACxC,IAAIw0B,UAAU;gBAACb,MAAQ,IAAIrD,KAAK,GAAG,GAAG;eAAKmE,YAAY/0B,OAAO60B,YAAYtjB,OAAOyjB;YAEjF,SAASC,eAAe1sB;gBACvB,IAAI2sB,iBAAiB3sB,MAAMpH,QAAQ,WAAW;gBAY9C,OAAO+zB;;YAGR,SAASpsB,SAASgsB,SAASvsB,OAAOjI;gBACjCw0B,QAAQC,cAAcE,eAAe1sB,QACrCusB,QAAQ,QAAQC,cAAcxsB;qBAERnG,MAAlB4yB,iBACHA,cAActvB,KAAKovB,QAAQb,MAAoB,WAAdc,aAAwB/gB,SAAS8gB,QAAQC,eAAe,IAAID,QAAQC;;YAIvG,IAAoB,mBAAT/0B,MAAmB;gBAC7B,MAAQuR,QAAQkiB,aAAanzB,MAAMgU,KAAK1L,WAAU;oBACjD,IAAIL,QAAQvI,KAAKsO,MAAM,GAAGiD,MAAM,GAAG/M;oBAC/BksB,WAAW5hB,eAAeyC,MAAM,QAEnCwjB,aAAarE,WAAWnf,MAAM,IAAI,IAClCyjB,gBAAgBtE,WAAWnf,MAAM,IAAI;oBACrCzI,SAASgsB,SAASvsB,OAAOjI,QAE1BN,OAAOA,KAAKsO,MAAM/F,MAAM/D;;gBAGzB,OAAOswB;;YACD,IAAI90B,QAAwB,aAAhBqI,QAAOrI,SAAqBA,KAAK8O,eAAe,SAClE,OAAO9O;;QAKTb,UAAUO,cAAc;YACvBy1B,UAAY;gBACXn1B,MAAM,SAAAA,KAAUM;oBAUf,OARAowB,WAAWyC,IAAI7yB,KAAK80B,KAAKC,cAAc1rB,KAAK,MAE5CrJ,KAAKg1B,cAAclC,YAAY9yB,KAAKg1B,gBAAgBh1B,KAAKg1B;oBACzDh1B,KAAKi1B,gBAAgBnC,YAAY9yB,KAAKi1B,kBAAkBj1B,KAAKi1B,iBAAiBj1B,KAAKg1B;oBACnFh1B,KAAKk1B,eAAepC,YAAY9yB,KAAKk1B,iBAAiBl1B,KAAKk1B,gBAAgBl1B,KAAKg1B;oBAChFh1B,KAAKmE,cAAmC,OAArBnE,KAAKmE,cAAqBnE,KAAKmE,cAAcnE,KAAKg1B,YAAYn0B,QAAQ,SAAS;oBAClGb,KAAKV,QAAQoE,MAAM1D,KAAKg1B,kBAAalzB,GAAW9B,OAEzC;;gBAERmE,aAAa;gBACb6wB,aAAa;gBACbC,oBAAenzB;gBACfozB,mBAAcpzB;gBACdoQ,KAAK;gBACLC,KAAK;gBAEL2iB,MAAM;oBACLK,UAAU,EACT,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAC1C,UAAU,WAAW,aAAa,YAAY,UAAU,YAAY;oBAErEC,YAAY,EACX,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAC7E,WAAW,YAAY,SAAS,SAAS,OAAO,QAAQ,QAAQ,UAAU,aAAa,WAAW,YAAY;oBAE/GL,eAAe,EAAC,MAAM,MAAM,MAAM;;gBAEnC3uB,eAAe,SAAAA,cAAUnG,QAAQH,KAAKqe,GAAGqB,aAAaxf,MAAMH;oBAC3D,IAAIw1B,UAAU,GAAGpa,aAAahK;oBAC9B,IAAIoD,MAAM8J,MAAMle,OAAOH,SAASqe,GAAG;wBAClC,MAAQlN,QAAQkiB,aAAanzB,MAAMgU,KAAKhU,KAAKg1B,gBAE5C,IADAK,WAAWpkB,MAAM,GAAG/M;wBACLpE,OAAXu1B,SAAgB;4BACnBpa,cAAchK,OACdA,QAAQkiB,aAAanzB,MAAMgU,KAAKhU,KAAKg1B;4BACrC;;wBAGF,IAAI/jB,SAASA,MAAM,OAAOkN,KAA6B,IAAxBlD,YAAY,GAAG/W,QAG7C,OAFAjE,OAAOH,OAAOG,OAAOH,MAAM;wBAC3BG,OAAOH,MAAM,KAAK,KACX;4BACNw1B,QAAO;4BACPr1B,QAAQA;4BACRgd,mBAAmB;gCAAC3C,OAAOxa,MAAM;gCAAGya,KAAKza,MAAM;;4BAC/CA,KAAKA,MAAM;;;oBAId,QAAO;;gBAERuG,gBAAgB,SAAAA,eAAUpG,QAAQH,KAAKyzB,eAAevzB;oBACrDA,KAAKkS,MAAM3Q,YAAYvB,KAAKkS,KAAKlS,KAAKg1B,aAAah1B,OACnDA,KAAKmS,MAAM5Q,YAAYvB,KAAKmS,KAAKnS,KAAKg1B,aAAah1B;oBAE/CuzB,cAAc+B,UACjBr1B,SAASszB,cAActzB,QACvBH,MAAMyzB,cAAczzB;oBAGrB,IAAIwgB,SAASiT,eAAeD,YAAY/xB,YAAYtB,OAAOoJ,KAAK,KAAKrJ,KAAKg1B,aAAah1B;oBAMvF,OALIsgB,UAAUgT,UAAUK,KAAKO,aAAcZ,UAAUK,KAAKO,cACzD5T,SAAS+S,YAAYC,WAAWhT;oBAChCA,SAASA,UAAUwT,cAAcR,WAAWtzB,QAGzCF,OAAOwgB,UAAUiT,cAAczzB,QAAQA,MACnC;wBACNG,QAAQyD,MAAM1D,KAAKg1B,aAAa1B,WAAWtzB;wBAC3Cid,mBAAmB;4BAAC3C,OAAOxa;4BAAKya,KAAKgZ,cAAczzB;;wBAI9CwgB;;gBAERrb,WAAW,SAAAA,UAAUwI,GAAGxN,QAAQmiB,UAAUpiB;oBACzC,IAAI2I,QAAQ/G;oBACZ,IAAI6L,EAAEwW,WAAWxW,EAAEnE,YAAYzK,UAAUyK,QAAQa,OAAO;wBAGvD,KAFA,IAAIorB,QAAQ,IAAIjF,QAAQrf,OAAO0iB,OAAO,IAE9B1iB,QAAQkiB,aAAanzB,MAAMgU,KAAKhU,KAAKg1B,gBACjB,QAAvB/jB,MAAM,GAAGT,OAAO,KACnBmjB,QAAQjD,IAAI6E,MAAM/E,WAAWvf,MAAM,GAAG/M,UACL,QAAvB+M,MAAM,GAAGT,OAAO,KAC1BmjB,QAAQjD,IAAK6E,MAAMzE,aAAa,GAAI7f,MAAM,GAAG/M,UACtB,WAAb+M,MAAM,KAChB0iB,QAAQ4B,MAAMnE,cAActZ,aACK,QAAvB7G,MAAM,GAAGT,OAAO,OAC1BmjB,QAAQjD,IAAI6E,MAAMC,WAAWvkB,MAAM,GAAG/M;wBAZ7BtC,KAgBL8F,UAAU4a,UAAUqR,OAC1BvyB,EAjBWQ,MAiBF6G,QAAQ;;;gBAGnBrI,UAAU,SAAAA,SAAUC,aAAaC,eAAeN;oBAC/C,OAAOM,gBAAgBoD,MAAM1D,KAAKk1B,cAAc3zB,YAAYlB,aAAaL,KAAKg1B,aAAah1B,OAAOA,OAAM,KAAQM;;gBAEjHrB,QAAQ,SAAAA,OAAU0L,MAAMxK,MAAML,KAAKoQ;oBAClC,OAAsC,KAAlC/P,KAAK2S,UAAU1P,QAAQ,UAAqBuH,KAAK/J,gBACf,KAAlCT,KAAK2S,UAAU1P,QAAQ,UAAqBuH,KAAK2S,gBAC9C3S;;gBAER3F,aAAY;gBACZ8B,iBAAgB;;YAIlBxI,OAAOD,UAAUQ;;QC5TjB,IAAIA,YAAYD,oBAAQ,IAAiBwC,IAAIvC,UAAU4L;QAEvD,SAASgrB,WAAWC,KAAK11B;YAExB,KADA,IAAI21B,aAAa,IACRj3B,IAAI,GAAGA,IAAIg3B,IAAIxxB,QAAQxF,KAC3BG,UAAU8D,UAAUhD,YAAY+1B,IAAIllB,OAAO9R,OAC9CsB,KAAKL,YAAY+1B,IAAIllB,OAAO9R,OAC5BsB,KAAKoE,eAAekW,UAAUob,IAAIllB,OAAO9R,MACzCsB,KAAKoE,eAAemW,QAAQmb,IAAIllB,OAAO9R,MACvCsB,KAAKqE,iBAAiBiW,UAAUob,IAAIllB,OAAO9R,MAC3CsB,KAAKqE,iBAAiBkW,QAAQmb,IAAIllB,OAAO9R,MACzCsB,KAAKsE,YAAYgW,UAAUob,IAAIllB,OAAO9R,MACtCsB,KAAKsE,YAAYiW,QAAQmb,IAAIllB,OAAO9R,MACpCsB,KAAKuE,qBAAqBmxB,IAAIllB,OAAO9R,KACrCi3B,cAAc,OAAOD,IAAIllB,OAAO9R,KAEhCi3B,cAAcD,IAAIllB,OAAO9R;YAG3B,OAAOi3B;;QAGR,SAASC,YAAY31B,QAAQ41B,QAAQ71B;YACpC,IAAa,IAAT61B,WAAe71B,KAAK81B,kBAAkC,IAAhB71B,OAAOiE,QAAY;gBAC5D,IAAI6xB,gBAAgB30B,EAAEgN,QAAQpO,KAAK2F,YAAY1F;iBACxB,MAAnB81B,kBACH91B,OAAO6L,KAAK9L,KAAK2F,aACjBowB,gBAAgB91B,OAAOiE,SAAS;gBAEjC,KAAK,IAAIxF,IAAI,GAAGA,KAAKm3B,QAAQn3B,KAC5BuB,OAAO81B,gBAAgBr3B,KAAKuB,OAAO81B,gBAAgBr3B,MAAM;;YAG3D,OAAOuB;;QAGR,SAAS+1B,cAAcC,QAAQp2B;YAC9B,IAAI2X,SAAS;YACb,KAAKA,UAAU3X,QAAQqQ;YAEvB,KAAK,IAAIgmB,UADT1e,SAAS9D,SAAS8D,SACC3X,QAAQuQ,OAE1B,IADA8lB,SAASxiB,SAASwiB;YACJ1e,UAAV0e,QACH,KAAK,IAAI1uB,MAAM,GAAG2uB,OAAOt2B,QAAQuQ,MAAM8lB,QAAQhyB,QAAQsD,MAAM2uB,MAAM3uB,OAClE,SAAuC1F,MAAnCjC,QAAQqQ,eAAegmB,WAAyBr2B,QAAQuQ,MAAM8lB,QAAQ1uB,KAAKyJ,MAAM4B,QAAQojB,QAC5F,OAAOC,eAA6Cp0B,MAAnCjC,QAAQqQ,eAAegmB,UAAwB,IAAI;YAKxE,OAAO1e;;QAGR,SAAS4e,UAAUH,QAAQp2B;YAC1B,IAAIw2B,OAAO;YAOX,OANAj1B,EAAEmG,KAAK1H,QAAQqQ,gBAAgB,SAAU1I,KAAKmQ;gBAC7C,IAAIA,IAAI1G,MAAM4B,QAAQojB,QAErB,OADAI,MAAM3iB,SAASlM,OACR;gBAGF6uB;;QAGR,SAASC,mBAAmBt2B;iBACK8B,MAA5B9B,KAAKs2B,uBAES,SAAbt2B,KAAKkS,QACRlS,KAAKkS,MAAMlS,KAAKkS,IAAI4F,WAAWjX,QAAQ,IAAIX,OAAOrB,UAAUqK,YAAYlJ,KAAK6F,iBAAiB,MAAM;YAC5E,QAApB7F,KAAK2F,eAAoB3F,KAAKkS,MAAMlS,KAAKkS,IAAIrR,QAAQb,KAAK2F,YAAY;YAC1E3F,KAAKkS,MAAM8E,SAAShX,KAAKkS,OAAOqkB,WAAWv2B,KAAKkS,OAAOskB,KACnDniB,MAAMrU,KAAKkS,SAAMlS,KAAKkS,MAAMukB,OAAOC;YAEvB,SAAb12B,KAAKmS,QACRnS,KAAKmS,MAAMnS,KAAKmS,IAAI2F,WAAWjX,QAAQ,IAAIX,OAAOrB,UAAUqK,YAAYlJ,KAAK6F,iBAAiB,MAAM;YAC5E,QAApB7F,KAAK2F,eAAoB3F,KAAKmS,MAAMnS,KAAKmS,IAAItR,QAAQb,KAAK2F,YAAY;YAC1E3F,KAAKmS,MAAM6E,SAAShX,KAAKmS,OAAOokB,WAAWv2B,KAAKmS,OAAOqkB,KACnDniB,MAAMrU,KAAKmS,SAAMnS,KAAKmS,MAAMskB,OAAOE;YAExC32B,KAAKs2B,qBAAqB;;QAI5B,SAASM,QAAQ52B;YAChBA,KAAK6E,SAAS,GAEV7E,KAAK6F,mBAAmB7F,KAAK2F,cAAc3F,KAAK61B,UAA0B,QAAhB71B,KAAK61B,WAC1C,QAApB71B,KAAK2F,aACR3F,KAAK6F,iBAAiB,MACQ,QAApB7F,KAAK2F,aACf3F,KAAK6F,iBAAiB,MAEtB7F,KAAK6F,iBAAiB;YAII,QAAxB7F,KAAK6F,mBACR7F,KAAKyF,iCAA4B3D,IAIJ,IAA1B9B,KAAKmE,YAAYD,WACpBlE,KAAKmE,cAAcnE,KAAKmE,YAAYqM,OAAO;YAGV,iBAA9BxQ,KAAK2G,wBAA8D,OAArB3G,KAAKmE,gBACtDnE,KAAK2G,uBAAuB;YAG7B,IAAIkwB,aAAa;aACS,MAAtB72B,KAAKwC,qBAAiDV,MAAxB9B,KAAK82B,kBACtCD,aAAa;YACb72B,KAAK2G,uBAAqD,iBAA9B3G,KAAK2G,uBAAwC,QAAQ3G,KAAK2G;YAElF0N,MAAMrU,KAAK61B,YAAS71B,KAAK61B,SAAS,IACtC71B,KAAK4F,eAAc,MAEnB5F,KAAK82B,kBAAiB;YACtB92B,KAAKwC,gBAAe;YAGrB,IAAI9C,OAAO,OAAO+Q;YAOlB,IANA/Q,QAAQ+1B,WAAWz1B,KAAK+2B,QAAQ/2B,OACJ,OAAxBA,KAAK6F,iBACRnG,QAAQM,KAAKg3B,MAAMh3B,QAEnBN,QAAQ;iBAEWoC,MAAhB9B,KAAK61B,QAAsB;gBAC9B,IAAIoB,KAAKj3B,KAAK61B,OAAO/d,WAAW9L,MAAM;gBAClCgL,SAASigB,GAAG,OAAOA,GAAG,MAAMjgB,SAASigB,GAAG,MAC3Cv3B,QAAQM,KAAK2F,aAAakxB,aAAa,MAAM72B,KAAK61B,SAAS,OACjDxhB,MAAMrU,KAAK61B,WAAmC,IAAxBniB,SAAS1T,KAAK61B,aAC1C71B,KAAK81B,kBACRrlB,UAAU/Q,OAAOM,KAAK2F,aAAakxB,aAAa,QAAQ72B,KAAK61B,SAAS;gBAEtE71B,KAAK8F,cAAa,KAElBpG,QAAQM,KAAK2F,aAAakxB,aAAa,MAAM72B,KAAK61B,SAAS;;YAe9D,OAXAn2B,QAAQ+1B,WAAWz1B,KAAKk3B,QAAQl3B,OAChCN,QAAQ,OAEJ+Q,YACH/Q,OAAO,EAAE+Q,UAAUglB,WAAWz1B,KAAKk3B,QAAQl3B,QAAQ,OAAQN;YAI5DM,KAAKS,UAAS,GAEd61B,mBAAmBt2B,OACZN;;QAGR,SAASy3B,kBAAkBr3B,KAAKqe,GAAGoF,UAAUvjB;YAM5C,OALIA,KAAK4F,eAAe5F,KAAKwC,gBACxB1C,OAAOyjB,aAAwB,IAAXA,YAAgBpF,KAAKne,KAAK2F,gBACjD7F,OAAO;YAGFA;;QAGR,SAASs3B,iBAAiBx3B,MAAMC,SAASC,KAAKC,QAAQC;YACrD,IAAIujB,WAAW1jB,QAAQI,OAAOmD,QAAQpD,KAAK2F,aAC1C2a,UAAuB,MAAdiD,YAAmB,IAAIrjB,OAAO,sBAAsBC,KAAKP;YACnE,OAAII,KAAK4F,eAAe0a,UAA8Cxe,QAApCjC,QAAQqQ,eAAeqT,YACjD;gBACNvE,QAAQ;oBACPlf,KAAKyjB,aAAazjB,MAAMyjB,WAAW,IAAIA;oBACvCpF,GAAGne,KAAK2F;;gBAET7F,KAAKA;gBAIAwgB;;QAIRzhB,UAAUO,cAAc;YACvBi4B,SAAW;gBACV33B,MAAMk3B;gBACNI,OAAO,SAAAA,MAAUh3B;oBAChB,OAAO,MAAMA,KAAK6F,iBAAiB;;gBAEpC1B,aAAa;gBACb1D,SAAQ;gBACRo1B,QAAQ;gBACRC,iBAAgB;gBAChBwB,sBAAqB;gBACrB3xB,YAAY;gBACZgB,sBAAsB;gBACtBf,cAAa;gBACbC,gBAAgB;gBAChB0xB,aAAY;gBACZpa,gBAAgB;oBACfC,OAAO;oBACPoa,MAAM;;gBAEPT,QAAQ;gBACRG,QAAQ;gBACRtzB,aAAY;gBACZsO,KAAK;gBACLC,KAAK;gBACLslB,MAAM;gBACNzyB,aAAY;gBACZxF,aAAY;gBACZk4B,iBAAgB;gBAChBn3B,WAAW;gBACXZ,aAAa;oBACZg4B,GAAK;wBACJ34B,WAAWo4B;;oBAEZQ,GAAK;wBACJ54B,WAAWo4B;wBACXpwB,kBAAkB;;oBAEnB6wB,KAAK;wBACJ74B,WAAW,SAAAA,UAAUY,MAAMC,SAASC,KAAKC,QAAQC;4BAChD,OAAQA,KAAKu3B,eAAwB,QAAT33B,QAAgBA,SAASI,KAAKmd,eAAeC;;;oBAI3Erc,KAAK;wBACJ/B,WAAW,SAAAA,UAAUY,MAAMC,SAASC,KAAKC,QAAQC;4BAChD,OAAQA,KAAKu3B,cAAc33B,SAASI,KAAKmd,eAAeqa;;;;gBAI3DpxB,eAAe,SAAAA,cAAUnG,QAAQH,KAAKqe,GAAGqB,aAAaxf,MAAMH;oBAC3D,IAAI0jB,WAAWniB,EAAEgN,QAAQpO,KAAK2F,YAAY1F;oBAE1C,IADAH,MAAMq3B,kBAAkBr3B,KAAKqe,GAAGoF,UAAUvjB,OAChC,QAANme,KAAaA,MAAMne,KAAKmd,eAAeC,OAkB3C,QAAkB,MAAdmG,aAAyC,MAArBvjB,KAAK4F,gBAAwC,MAAhB4Z,eAAyBrB,MAAMne,KAAK2F,mBAA+B7D,MAAhB9B,KAAK61B,WAAyBxhB,MAAMrU,KAAK61B,WAAmC,IAAxBniB,SAAS1T,KAAK61B,YAAiBtS,aAAazjB,MAChM;wBACNud,OAASrd,KAAK4F,eAAe9F,QAAQyjB,WAAW,IAAIA,WAAW,IAAIA;wBAI9D;wBAACrD,iBAAiBpgB;;oBAvBxB,KAAwB,MAApBE,KAAKu3B,YAAqB,QAAO;oBACrC,IAAIO,cAAa,GAChB1a,QAAQgZ,UAAU,KAAKv2B,UAAU23B,OAAOpB,UAAU,KAAKv2B;oBAKxD,QAJe,MAAXud,UACH0a,aAAa,EAAC1a,OAAOoa,UAGA,MAAfM,aAAuB;wBAC7BnwB,QAAQmwB;wBACRza,OAAkBvd,MAAXyjB,WAAiBzjB,MAAM,IAAIA;wBAC/B;wBACHkf,QAAQ,EACP;4BAAClf,KAAKk2B,cAAc,KAAKn2B;4BAAUse,GAAGne,KAAKmd,eAAeC;4BAAOgB,cAAa;2BAC9E;4BAACte,KAAKk2B,cAAc,KAAKn2B;4BAAUse,GAAGne,KAAKmd,eAAeqa;4BAAMpZ,cAAa;;wBAC9Ef,OAAkBvd,MAAXyjB,WAAiBzjB,MAAM,IAAIA;;;gBAWrCuG,gBAAgB,SAAAA,eAAUpG,QAAQH,KAAKyzB,eAAevzB;oBACrD,IAAiB,SAAbA,KAAKkS,OAA6B,SAAblS,KAAKmS,KAAc;wBAC3C,IAAI4lB,WAAW/3B,KAAKI,SAASH,OAAO+N,QAAQgC,UAAU3G,KAAK,UAAKvH,GAAWV,EAAEc,OAAO,IAAIlC,MAAM;4BAC7F03B,iBAAgB;;wBAEjB,IAAiB,SAAb13B,KAAKkS,OAAgB6lB,WAAW/3B,KAAKkS,OAAO6lB,SAASjgB,WAAW5T,UAAUlE,KAAKkS,IAAI4F,WAAW5T,QACjG,QAAO;wBAER,IAAiB,SAAblE,KAAKmS,OAAgB4lB,WAAW/3B,KAAKmS,KACxC,QAAO;;oBAIT,OAAOohB;;gBAERnzB,UAAU,SAAAA,SAAUC,aAAaC,eAAeN;oBAC/C,IAAsB,OAAlBM,kBAA0C,MAAlBN,KAAKwG,UAChC,OAAOlG;oBAER,IAAI03B,eAAe33B,YAAYQ,QAAQb,KAAK+2B,QAAQ;oBAMpD,OALAiB,eAAeA,aAAan3B,QAAQb,KAAKk3B,QAAQ,KACjDc,eAAeA,aAAan3B,QAAQ,IAAIX,OAAOrB,UAAUqK,YAAYlJ,KAAK6F,iBAAiB,MAAM;oBAC9D,OAA/B7F,KAAKmE,YAAYqM,OAAO,OAC3BwnB,eAAeA,aAAan3B,QAAQ,IAAIX,OAAOF,KAAKmE,YAAYqM,OAAO,IAAI,MAAM;oBAE9ExQ,KAAK03B,kBACgB,OAApB13B,KAAK2F,eAAgE,MAA3CqyB,aAAa50B,QAAQpD,KAAK2F,gBAAoBqyB,eAAeA,aAAan3B,QAAQhC,UAAUqK,YAAY9D,KAAKxD,MAAM5B,KAAK2F,aAAa;oBACnKqyB,eAAeA,aAAan3B,QAAQ,IAAIX,OAAO,MAAMrB,UAAUqK,YAAYlJ,KAAKmd,eAAeC,SAAS;oBACxG4a,eAAeA,aAAan3B,QAAQ,IAAIX,OAAOrB,UAAUqK,YAAYlJ,KAAKmd,eAAeqa,QAAQ,MAAM;oBAChGf,OAAOuB,iBAERA;;gBAER7xB,YAAY,SAAAA,WAAUlG,QAAQD;oBAC7B,IAAIK,eAAeL,KAAKwC,eAAevC,OAAO+N,QAAQgC,YAAY/P,QAAQoJ,KAAK;oBAO/E,OANAhJ,cAAcA,YAAYQ,QAAQ,IAAIX,OAAO,MAAMrB,UAAUqK,YAAYlJ,KAAKmd,eAAeC,SAAS;oBACtG/c,cAAcA,YAAYQ,QAAQ,IAAIX,OAAOrB,UAAUqK,YAAYlJ,KAAKmd,eAAeqa,QAAQ,MAAM;oBACrGn3B,cAAcA,YAAYQ,QAAQb,KAAK+2B,QAAQ,KAC/C12B,cAAcA,YAAYQ,QAAQb,KAAKk3B,QAAQ;oBAC/C72B,cAAcA,YAAYQ,QAAQ,IAAIX,OAAOrB,UAAUqK,YAAYlJ,KAAK6F,kBAAkB,cAAc,MAAM;oBACtF,QAApB7F,KAAK2F,eAAoBtF,cAAcA,YAAYQ,QAAQhC,UAAUqK,YAAYlJ,KAAK2F,aAAa;oBAChGqR,SAAS3W;;gBAEjB6E,cAAc,SAAAA,aAAU4qB,cAAc9vB;oBACrC,IAAI2F,aAAa3F,KAAK2F,cAAc;oBAER,mBAAhBmqB,gBAA+C,aAAnB9vB,KAAKknB,aAA0C,OAAfvhB,eACvEmqB,eAAeA,aAAahY,WAAWjX,QAAQ,KAAK8E;oBAGrD,IAAIsyB,aAAanI,aAAa9jB,MAAMrG,aACnCuyB,cAAcD,WAAW,GAAGp3B,QAAQ,aAAa,KACjDs3B,cAAkC,IAApBF,WAAW/zB,SAAa+zB,WAAW,GAAGp3B,QAAQ,WAAW,MAAM;oBAE9EivB,eAAeoI,eAA+B,OAAhBC,cAAqBxyB,aAAawyB,cAAcA;oBAE9E,IAAItC,SAAS;oBACb,IAAmB,OAAflwB,eACHkwB,SAASsC,YAAYj0B,QACD,OAAhBi0B,cAAoB;wBACvB,IAAIC,eAAe3f,KAAK4f,IAAI,IAAIxC,UAAU;wBACtC7e,SAAShX,KAAK61B,YACjBA,SAASniB,SAAS1T,KAAK61B,SACvBuC,eAAe3f,KAAK4f,IAAI,IAAIxC;wBAI7B/F,eAAeA,aAAajvB,QAAQhC,UAAUqK,YAAYvD,aAAa,MACnEqR,SAAS8Y,kBACZA,eAAerX,KAAK6f,MAAM/B,WAAWzG,gBAAgBsI,gBAAgBA;wBAEtEtI,eAAeA,aAAahY,WAAWjX,QAAQ,KAAK8E;;oBAOtD,OAHoB,MAAhB3F,KAAK61B,WAA6E,MAA7D/F,aAAa1sB,QAAQvE,UAAUqK,YAAYvD,iBACnEmqB,eAAeA,aAAayI,UAAU,GAAGzI,aAAa1sB,QAAQvE,UAAUqK,YAAYvD;oBAE9EiwB,YAAY9F,aAAahY,WAAW9L,MAAM,KAAK6pB,QAAQ71B,MAAMqJ,KAAK;;gBAE1EhE,eAAe,SAAAA,cAAUoI,GAAGxN,QAAQmiB,UAAUpiB;oBAC7C,IAAIsgB,QAEAkY,gBAAgB,IAAIt4B,OAAO,OAAoC,MAA7BF,KAAKmd,eAAeC,QAAcve,UAAUqK,YAAYlJ,KAAKmd,eAAeC,SAAS,MAAM,MAAMve,UAAUqK,YAAYlJ,KAAK+2B,UAAU,kBAAkBl4B,UAAUqK,YAAYlJ,KAAKk3B,WAAuC,MAA5Bl3B,KAAKmd,eAAeqa,OAAa34B,UAAUqK,YAAYlJ,KAAKmd,eAAeqa,QAAQ,MAAM,MAAM,KAAKxjB,KAAK/T,OAAO+N,QAAQgC,UAAU3G,KAAK,MAC1WovB,SAASD,gBAAgBA,cAAcE,OAAOD,SAAS;oBACxD,IAAIA,QAAQ;wBACXA,SAASA,OAAOzsB,MAAMhM,KAAK2F,WAAW6K,OAAO,IAAI;wBAEjD,IAAImoB,gBAAgB,IAAIz4B,OAAO,QAAQF,KAAK6F,iBAAiB,MAAMmO,KAAKykB;wBAExE,IAA8B,IAA1BE,cAAc,GAAGz0B,UAAwC,IAA1By0B,cAAc,GAAGz0B,UAAcy0B,cAAc,GAAGz0B,SAASu0B,OAAOv0B,QAAQ;4BAC1G,IAAI00B,MAAM34B,OAAO+N,QAAQgC,WAAW6oB,WAAWD,IAAIvvB,KAAK,IAAIjG,QAAQu1B,cAAc;4BAClFC,IAAIpsB,OAAOqsB,UAAUF,cAAc,GAAGz0B;4BACtC,IAAI40B,cAAcF,IAAI10B,SAAS20B;4BAC/BvY,SAAS;gCACRrD,oBAAmB;gCACnBhd,QAAQ24B,IAAI5oB;gCACZqN,OAAO+E,WAAW0W,cAAc1W,WAAW0W;;;;oBAM9C,IAAIrrB,GACH,QAAQA,EAAET;sBACT,KAAK;sBACL,KAAK;wBACoB,OAApBhN,KAAK2F,cAAqB1F,OAAO,OAAOD,KAAK2F,eAC5C2a,UAAUA,OAAOrgB,SACpBqgB,OAAOrgB,OAAO6b,WAEd7b,OAAO6b;wBACPwE,SACC;4BAACrD,oBAAmB;4BAAMhd,QAAQA;;;oBAMxC,OAAOqgB;;gBAERrb,WAAW,SAAAA,UAAUwI,GAAGxN,QAAQmiB,UAAUpiB;oBACzC,IAAIwiB,SAASphB,EAAEQ;oBACf,IAAI6L,EAAEwW,SACL,QAAQxW,EAAEnE;sBACT,KAAKzK,UAAUyK,QAAQgB;wBAGtB,OAFA1I,KAAK8F,UAAU+nB,WAAWrqB,KAAKxD,MAAM20B,WAAW30B,KAAK8F,UAAUM,mBAAmB0L,SAAS1T,KAAKy3B;wBAChGjV,OAAO/Z,QAAQ,cACR;;sBACR,KAAK5J,UAAUyK,QAAQI;wBAGtB,OAFA9H,KAAK8F,UAAU+nB,WAAWrqB,KAAKxD,MAAM20B,WAAW30B,KAAK8F,UAAUM,mBAAmB0L,SAAS1T,KAAKy3B;wBAChGjV,OAAO/Z,QAAQ,cACR;;oBAGV,KAAIgF,EAAEnE,YAAYzK,UAAUyK,QAAQG,UAAUgE,EAAEnE,YAAYzK,UAAUyK,QAAQC,aAAakE,EAAEnE,YAAYzK,UAAUyK,QAAQE,sBACjG,MAArBxJ,KAAK4F,gBAAyB5F,KAAK81B,gBAAgB;wBACtD,IAAIvS,WAAWniB,EAAEgN,QAAQpO,KAAK2F,YAAY1F;wBAC1C,KAAkB,MAAdsjB,aAAoBnB,WAAWmB,YAAa9V,EAAEnE,YAAYzK,UAAUyK,QAAQG,UAAU2Y,aAAamB,WAAY;4BAC9G9V,EAAEnE,YAAYzK,UAAUyK,QAAQC,aAAakE,EAAEnE,YAAYzK,UAAUyK,QAAQE,oBAChF4Y;4BAED,IAAI2W,OAAO94B,OAAO+N,QAAQgC;4BAG1B,OAFA+oB,KAAKvsB,OAAOusB,KAAK70B,SAASke,UAAU,IACpCI,OAAO/Z,QAAQ,YAAY,EAACmtB,YAAYmD,MAAM/4B,KAAK61B,QAAQ71B,MAAMqJ,KAAK,KAAK+Y;6BACpE;;;;;YAMZ4W,UAAY;gBACXjC,QAAQ;gBACRlxB,gBAAgB;gBAChBpE,OAAO;gBACP0C,aAAa;gBACb0xB,QAAQ;gBACRC,iBAAgB;;YAEjBmD,SAAW;gBACVx3B,OAAO;;YAERy3B,SAAW;gBACVz3B,OAAO;gBACPo0B,QAAQ;;YAETsD,YAAc;gBACb13B,OAAO;gBACPyQ,KAAK;gBACLC,KAAK;gBACL+kB,QAAQ;gBACRK,aAAY;;YAEb6B,UAAY;gBACX33B,OAAO;gBACPu1B,OAAO,SAAAA,MAAUh3B;oBAChB,OAAO,MAAMA,KAAK6F,iBAAiB,cAAc7F,KAAK6F,iBAAiB;;gBAExEA,gBAAgB;gBAChBF,YAAY;gBACZxB,aAAa;gBACb0xB,QAAQ;gBACRC,iBAAgB;;YAGlBx3B,OAAOD,UAAUQ;SCncjBw6B,mBAAA,IA4BA9pB,oBAAA2B,IAAAooB,SAGA/pB,oBAAA4O,IAAAkb;IAGA9pB,oBAAA8gB,IAAA,SAAAhyB,SAAAoQ,MAAA+f;QACAjf,oBAAAqjB,EAAAv0B,SAAAoQ,SACAzK,OAAAirB,eAAA5wB,SAAAoQ,MAAA;YAA0C8qB,aAAA;YAAAlL,KAAAG;;OAK1Cjf,oBAAAiqB,IAAA,SAAAn7B;QACA,sBAAAo7B,iBAAAC,eACA11B,OAAAirB,eAAA5wB,SAAAo7B,OAAAC,aAAA;YAAwDzxB,OAAA;YAExDjE,OAAAirB,eAAA5wB,SAAA;YAAiD4J,QAAA;;OAQjDsH,oBAAAyS,IAAA,SAAA/Z,OAAA0xB;QAEA,IADA,IAAAA,SAAA1xB,QAAAsH,oBAAAtH,SACA,IAAA0xB,MAAA,OAAA1xB;QACA,QAAA0xB,QAAA,mBAAA1xB,wBAAA2xB,YAAA,OAAA3xB;QACA,IAAA4xB,KAAA71B,OAAA81B,OAAA;QAGA,IAFAvqB,oBAAAiqB,EAAAK,KACA71B,OAAAirB,eAAA4K,IAAA;YAAyCN,aAAA;YAAAtxB;YACzC,IAAA0xB,QAAA,mBAAA1xB,OAAA,SAAAiH,OAAAjH,OAAAsH,oBAAA8gB,EAAAwJ,IAAA3qB,KAAA,SAAAA;YAAgH,OAAAjH,MAAAiH;UAAqB6qB,KAAA,MAAA7qB;QACrI,OAAA2qB;OAIAtqB,oBAAAyqB,IAAA,SAAA17B;QACA,IAAAkwB,SAAAlwB,iBAAAs7B,aACA,SAAAK;YAA2B,OAAA37B,OAAA;YAC3B,SAAA47B;YAAiC,OAAA57B;;QAEjC,OADAiR,oBAAA8gB,EAAA7B,QAAA,KAAAA,SACAA;OAIAjf,oBAAAqjB,IAAA,SAAA7D,QAAAoL;QAAsD,OAAAn2B,OAAArB,UAAA6L,eAAApJ,KAAA2pB,QAAAoL;OAGtD5qB,oBAAA/L,IAAA,IAIA+L,wCAAA2iB,IAAA;IA9EA,SAAA3iB,oBAAA6qB;QAGA,IAAAf,iBAAAe,WACA,OAAAf,iBAAAe,UAAA/7B;QAGA,IAAAC,SAAA+6B,iBAAAe,YAAA;YACA17B,GAAA07B;YACA5f,IAAA;YACAnc,SAAA;;QAUA,OANAi7B,QAAAc,UAAAh1B,KAAA9G,OAAAD,SAAAC,eAAAD,SAAAkR;QAGAjR,OAAAkc,KAAA,GAGAlc,OAAAD;;iBAvBAg7B","file":"dist/inputmask.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function() {\nreturn ","// import \"./css/inputmask.css\";\r\n\r\nrequire(\"./lib/extensions/inputmask.extensions\");\r\nrequire(\"./lib/extensions/inputmask.date.extensions\");\r\nrequire(\"./lib/extensions/inputmask.numeric.extensions\");\r\nmodule.exports = require(\"./lib/inputmask.js\");\r\n","/*\r\n Input Mask plugin extensions\r\n http://github.com/RobinHerbots/jquery.inputmask\r\n Copyright (c) Robin Herbots\r\n Licensed under the MIT license\r\n */\r\nvar Inputmask = require(\"../inputmask\");\r\n//extra definitions\r\nInputmask.extendDefinitions({\r\n\t\"A\": {\r\n\t\tvalidator: \"[A-Za-z\\u0410-\\u044F\\u0401\\u0451\\u00C0-\\u00FF\\u00B5]\",\r\n\t\tcasing: \"upper\" //auto uppercasing\r\n\t},\r\n\t\"&\": { //alfanumeric uppercasing\r\n\t\tvalidator: \"[0-9A-Za-z\\u0410-\\u044F\\u0401\\u0451\\u00C0-\\u00FF\\u00B5]\",\r\n\t\tcasing: \"upper\"\r\n\t},\r\n\t\"#\": { //hexadecimal\r\n\t\tvalidator: \"[0-9A-Fa-f]\",\r\n\t\tcasing: \"upper\"\r\n\t}\r\n});\r\nInputmask.extendAliases({\r\n\t\"cssunit\": {\r\n\t\tregex: \"[+-]?[0-9]+\\\\.?([0-9]+)?(px|em|rem|ex|%|in|cm|mm|pt|pc)\"\r\n\t},\r\n\t\"url\": { //needs update => https://en.wikipedia.org/wiki/URL\r\n\t\tregex: \"(https?|ftp)//.*\",\r\n\t\tautoUnmask: false\r\n\t},\r\n\t\"ip\": { //ip-address mask\r\n\t\tmask: \"i[i[i]].i[i[i]].i[i[i]].i[i[i]]\",\r\n\t\tdefinitions: {\r\n\t\t\t\"i\": {\r\n\t\t\t\tvalidator: function (chrs, maskset, pos, strict, opts) {\r\n\t\t\t\t\tif (pos - 1 > -1 && maskset.buffer[pos - 1] !== \".\") {\r\n\t\t\t\t\t\tchrs = maskset.buffer[pos - 1] + chrs;\r\n\t\t\t\t\t\tif (pos - 2 > -1 && maskset.buffer[pos - 2] !== \".\") {\r\n\t\t\t\t\t\t\tchrs = maskset.buffer[pos - 2] + chrs;\r\n\t\t\t\t\t\t} else chrs = \"0\" + chrs;\r\n\t\t\t\t\t} else chrs = \"00\" + chrs;\r\n\t\t\t\t\treturn new RegExp(\"25[0-5]|2[0-4][0-9]|[01][0-9][0-9]\").test(chrs);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tonUnMask: function (maskedValue, unmaskedValue, opts) {\r\n\t\t\treturn maskedValue;\r\n\t\t},\r\n\t\tinputmode: \"numeric\",\r\n\t},\r\n\t\"email\": {\r\n\t\t//https://en.wikipedia.org/wiki/Domain_name#Domain_name_space\r\n\t\t//https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_host_names\r\n\t\t//should be extended with the toplevel domains at the end\r\n\t\tmask: \"*{1,64}[.*{1,64}][.*{1,64}][.*{1,63}]@-{1,63}.-{1,63}[.-{1,63}][.-{1,63}]\",\r\n\t\tgreedy: false,\r\n\t\tcasing: \"lower\",\r\n\t\tonBeforePaste: function (pastedValue, opts) {\r\n\t\t\tpastedValue = pastedValue.toLowerCase();\r\n\t\t\treturn pastedValue.replace(\"mailto:\", \"\");\r\n\t\t},\r\n\t\tdefinitions: {\r\n\t\t\t\"*\": {\r\n\t\t\t\tvalidator: \"[0-9\\uFF11-\\uFF19A-Za-z\\u0410-\\u044F\\u0401\\u0451\\u00C0-\\u00FF\\u00B5!#$%&'*+/=?^_`{|}~-]\"\r\n\t\t\t},\r\n\t\t\t\"-\": {\r\n\t\t\t\tvalidator: \"[0-9A-Za-z-]\"\r\n\t\t\t}\r\n\t\t},\r\n\t\tonUnMask: function (maskedValue, unmaskedValue, opts) {\r\n\t\t\treturn maskedValue;\r\n\t\t},\r\n\t\tinputmode: \"email\"\r\n\t},\r\n\t\"mac\": {\r\n\t\tmask: \"##:##:##:##:##:##\"\r\n\t},\r\n\t//https://en.wikipedia.org/wiki/Vehicle_identification_number\r\n\t// see issue #1199\r\n\t\"vin\": {\r\n\t\tmask: \"V{13}9{4}\",\r\n\t\tdefinitions: {\r\n\t\t\t\"V\": {\r\n\t\t\t\tvalidator: \"[A-HJ-NPR-Za-hj-npr-z\\\\d]\",\r\n\t\t\t\tcasing: \"upper\"\r\n\t\t\t}\r\n\t\t},\r\n\t\tclearIncomplete: true,\r\n\t\tautoUnmask: true\r\n\t}\r\n});\r\nmodule.exports = Inputmask;\r\n","/*\r\n * Input Mask Core\r\n * http://github.com/RobinHerbots/jquery.inputmask\r\n * Copyright (c) Robin Herbots\r\n * Licensed under the MIT license\r\n */\r\nvar $ = require(\"./dependencyLibs/inputmask.dependencyLib\"), window = require(\"./global/window\"),\r\n\tdocument = window.document,\r\n\tgenerateMaskSet = require(\"./maskset\").generateMaskSet,\r\n\tanalyseMask = require(\"./maskset\").analyseMask,\r\n\tmaskScope = require(\"./maskScope\");\r\n\r\n\r\nfunction Inputmask(alias, options, internal) {\r\n\t//allow instanciating without new\r\n\tif (!(this instanceof Inputmask)) {\r\n\t\treturn new Inputmask(alias, options, internal);\r\n\t}\r\n\r\n\tthis.el = undefined;\r\n\tthis.events = {};\r\n\tthis.maskset = undefined;\r\n\tthis.refreshValue = false; //indicate a refresh from the inputvalue is needed (form.reset)\r\n\r\n\tif (internal !== true) {\r\n\t\t//init options\r\n\t\tif ($.isPlainObject(alias)) {\r\n\t\t\toptions = alias;\r\n\t\t} else {\r\n\t\t\toptions = options || {};\r\n\t\t\tif (alias) options.alias = alias;\r\n\t\t}\r\n\t\tthis.opts = $.extend(true, {}, this.defaults, options);\r\n\t\tthis.noMasksCache = options && options.definitions !== undefined;\r\n\t\tthis.userOptions = options || {}; //user passed options\r\n\t\tresolveAlias(this.opts.alias, options, this.opts);\r\n\t\tthis.isRTL = this.opts.numericInput;\r\n\t}\r\n}\r\n\r\nInputmask.prototype = {\r\n\tdataAttribute: \"data-inputmask\", //data attribute prefix used for attribute binding\r\n\t//options default\r\n\tdefaults: {\r\n\t\tplaceholder: \"_\",\r\n\t\toptionalmarker: [\"[\", \"]\"],\r\n\t\tquantifiermarker: [\"{\", \"}\"],\r\n\t\tgroupmarker: [\"(\", \")\"],\r\n\t\talternatormarker: \"|\",\r\n\t\tescapeChar: \"\\\\\",\r\n\t\tmask: null, //needs tobe null instead of undefined as the extend method does not consider props with the undefined value\r\n\t\tregex: null, //regular expression as a mask\r\n\t\toncomplete: $.noop, //executes when the mask is complete\r\n\t\tonincomplete: $.noop, //executes when the mask is incomplete and focus is lost\r\n\t\toncleared: $.noop, //executes when the mask is cleared\r\n\t\trepeat: 0, //repetitions of the mask: * ~ forever, otherwise specify an integer\r\n\t\tgreedy: false, //true: allocated buffer for the mask and repetitions - false: allocate only if needed\r\n\t\tautoUnmask: false, //automatically unmask when retrieving the value with $.fn.val or value if the browser supports __lookupGetter__ or getOwnPropertyDescriptor\r\n\t\tremoveMaskOnSubmit: false, //remove the mask before submitting the form.\r\n\t\tclearMaskOnLostFocus: true,\r\n\t\tinsertMode: true, //insert the input or overwrite the input\r\n\t\tclearIncomplete: false, //clear the incomplete input on blur\r\n\t\talias: null,\r\n\t\tonKeyDown: $.noop, //callback to implement autocomplete on certain keys for example. args => event, buffer, caretPos, opts\r\n\t\tonBeforeMask: null, //executes before masking the initial value to allow preprocessing of the initial value.\targs => initialValue, opts => return processedValue\r\n\t\tonBeforePaste: function (pastedValue, opts) {\r\n\t\t\treturn $.isFunction(opts.onBeforeMask) ? opts.onBeforeMask.call(this, pastedValue, opts) : pastedValue;\r\n\t\t}, //executes before masking the pasted value to allow preprocessing of the pasted value.\targs => pastedValue, opts => return processedValue\r\n\t\tonBeforeWrite: null, //executes before writing to the masked element. args => event, opts\r\n\t\tonUnMask: null, //executes after unmasking to allow postprocessing of the unmaskedvalue.\targs => maskedValue, unmaskedValue, opts\r\n\t\tshowMaskOnFocus: true, //show the mask-placeholder when the input has focus\r\n\t\tshowMaskOnHover: true, //show the mask-placeholder when hovering the empty input\r\n\t\tonKeyValidation: $.noop, //executes on every key-press with the result of isValid. Params: key, result, opts\r\n\t\tskipOptionalPartCharacter: \" \", //a character which can be used to skip an optional part of a mask\r\n\t\tnumericInput: false, //numericInput input direction style (input shifts to the left while holding the caret position)\r\n\t\trightAlign: false, //align to the right\r\n\t\tundoOnEscape: true, //pressing escape reverts the value to the value before focus\r\n\t\t//numeric basic properties\r\n\t\tradixPoint: \"\", //\".\", // | \",\"\r\n\t\t_radixDance: false, //dance around the radixPoint\r\n\t\tgroupSeparator: \"\", //\",\", // | \".\"\r\n\t\t//numeric basic properties\r\n\t\tkeepStatic: null, //try to keep the mask static while typing. Decisions to alter the mask will be posponed if possible - null see auto selection for multi masks\r\n\t\tpositionCaretOnTab: true, //when enabled the caret position is set after the latest valid position on TAB\r\n\t\ttabThrough: false, //allows for tabbing through the different parts of the masked field\r\n\t\tsupportsInputType: [\"text\", \"tel\", \"url\", \"password\", \"search\"], //list with the supported input types\r\n\t\t//specify keyCodes which should not be considered in the keypress event, otherwise the preventDefault will stop their default behavior especially in FF\r\n\t\tignorables: [8, 9, 13, 19, 27, 33, 34, 35, 36, 37, 38, 39, 40, 45, 46, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 0, 229],\r\n\t\tisComplete: null, //override for isComplete - args => buffer, opts - return true || false\r\n\t\tpreValidation: null, //hook to preValidate the input.  Usefull for validating regardless the definition.\targs => buffer, pos, char, isSelection, opts => return true/false/command object\r\n\t\tpostValidation: null, //hook to postValidate the result from isValid.\tUsefull for validating the entry as a whole.\targs => buffer, pos, currentResult, opts => return true/false/json\r\n\t\tstaticDefinitionSymbol: undefined, //specify a definitionSymbol for static content, used to make matches for alternators\r\n\t\tjitMasking: false, //just in time masking ~ only mask while typing, can n (number), true or false\r\n\t\tnullable: true, //return nothing instead of the buffertemplate when the user hasn't entered anything.\r\n\t\tinputEventOnly: false, //dev option - testing inputfallback behavior\r\n\t\tnoValuePatching: false, //disable value property patching\r\n\t\tpositionCaretOnClick: \"lvp\", //none, lvp (based on the last valid position (default), radixFocus (position caret to radixpoint on initial click), select (select the whole input), ignore (ignore the click and continue the mask)\r\n\t\tcasing: null, //mask-level casing. Options: null, \"upper\", \"lower\" or \"title\" or callback args => elem, test, pos, validPositions return charValue\r\n\t\tinputmode: \"verbatim\", //specify the inputmode  - already in place for when browsers will support it\r\n\t\tcolorMask: false, //enable css styleable mask\r\n\t\tdisablePredictiveText: false, //disable Predictive Text on mobile devices\r\n\t\timportDataAttributes: true, //import data-inputmask attributes\r\n\t\tshiftPositions: true //shift position of the mask entries on entry and deletion.\r\n\t},\r\n\tdefinitions: {\r\n\t\t\"9\": { //\\uFF11-\\uFF19 #1606\r\n\t\t\tvalidator: \"[0-9\\uFF11-\\uFF19]\",\r\n\t\t\tdefinitionSymbol: \"*\"\r\n\t\t},\r\n\t\t\"a\": { //\\u0410-\\u044F\\u0401\\u0451\\u00C0-\\u00FF\\u00B5 #76\r\n\t\t\tvalidator: \"[A-Za-z\\u0410-\\u044F\\u0401\\u0451\\u00C0-\\u00FF\\u00B5]\",\r\n\t\t\tdefinitionSymbol: \"*\"\r\n\t\t},\r\n\t\t\"*\": {\r\n\t\t\tvalidator: \"[0-9\\uFF11-\\uFF19A-Za-z\\u0410-\\u044F\\u0401\\u0451\\u00C0-\\u00FF\\u00B5]\"\r\n\t\t}\r\n\t},\r\n\taliases: {}, //aliases definitions\r\n\tmasksCache: {},\r\n\tmask: function (elems) {\r\n\t\tvar that = this;\r\n\t\tif (typeof elems === \"string\") {\r\n\t\t\telems = document.getElementById(elems) || document.querySelectorAll(elems);\r\n\t\t}\r\n\t\telems = elems.nodeName ? [elems] : elems;\r\n\t\t$.each(elems, function (ndx, el) {\r\n\t\t\tvar scopedOpts = $.extend(true, {}, that.opts);\r\n\t\t\tif (importAttributeOptions(el, scopedOpts, $.extend(true, {}, that.userOptions), that.dataAttribute)) {\r\n\t\t\t\tvar maskset = generateMaskSet(scopedOpts, that.noMasksCache);\r\n\t\t\t\tif (maskset !== undefined) {\r\n\t\t\t\t\tif (el.inputmask !== undefined) {\r\n\t\t\t\t\t\tel.inputmask.opts.autoUnmask = true; //force autounmasking when remasking\r\n\t\t\t\t\t\tel.inputmask.remove();\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//store inputmask instance on the input with element reference\r\n\t\t\t\t\tel.inputmask = new Inputmask(undefined, undefined, true);\r\n\t\t\t\t\tel.inputmask.opts = scopedOpts;\r\n\t\t\t\t\tel.inputmask.noMasksCache = that.noMasksCache;\r\n\t\t\t\t\tel.inputmask.userOptions = $.extend(true, {}, that.userOptions);\r\n\t\t\t\t\tel.inputmask.isRTL = scopedOpts.isRTL || scopedOpts.numericInput;\r\n\t\t\t\t\tel.inputmask.el = el;\r\n\t\t\t\t\tel.inputmask.maskset = maskset;\r\n\r\n\t\t\t\t\t$.data(el, \"_inputmask_opts\", scopedOpts);\r\n\r\n\t\t\t\t\tmaskScope.call(el.inputmask, {\r\n\t\t\t\t\t\t\"action\": \"mask\"\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn elems && elems[0] ? (elems[0].inputmask || this) : this;\r\n\t},\r\n\toption: function (options, noremask) { //set extra options || retrieve value of a current option\r\n\t\tif (typeof options === \"string\") {\r\n\t\t\treturn this.opts[options];\r\n\t\t} else if (typeof options === \"object\") {\r\n\t\t\t$.extend(this.userOptions, options); //user passed options\r\n\t\t\t//remask\r\n\t\t\tif (this.el && noremask !== true) {\r\n\t\t\t\tthis.mask(this.el);\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t}\r\n\t},\r\n\tunmaskedvalue: function (value) {\r\n\t\tthis.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);\r\n\t\treturn maskScope.call(this, {\r\n\t\t\t\"action\": \"unmaskedvalue\",\r\n\t\t\t\"value\": value\r\n\t\t});\r\n\t},\r\n\tremove: function () {\r\n\t\treturn maskScope.call(this, {\r\n\t\t\t\"action\": \"remove\"\r\n\t\t});\r\n\t},\r\n\tgetemptymask: function () { //return the default (empty) mask value, usefull for setting the default value in validation\r\n\t\tthis.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);\r\n\t\treturn maskScope.call(this, {\r\n\t\t\t\"action\": \"getemptymask\"\r\n\t\t});\r\n\t},\r\n\thasMaskedValue: function () { //check wheter the returned value is masked or not; currently only works reliable when using jquery.val fn to retrieve the value\r\n\t\treturn !this.opts.autoUnmask;\r\n\t},\r\n\tisComplete: function () {\r\n\t\tthis.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);\r\n\t\treturn maskScope.call(this, {\r\n\t\t\t\"action\": \"isComplete\"\r\n\t\t});\r\n\t},\r\n\tgetmetadata: function () { //return mask metadata if exists\r\n\t\tthis.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);\r\n\t\treturn maskScope.call(this, {\r\n\t\t\t\"action\": \"getmetadata\"\r\n\t\t});\r\n\t},\r\n\tisValid: function (value) {\r\n\t\tthis.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);\r\n\t\treturn maskScope.call(this, {\r\n\t\t\t\"action\": \"isValid\",\r\n\t\t\t\"value\": value\r\n\t\t});\r\n\t},\r\n\tformat: function (value, metadata) {\r\n\t\tthis.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);\r\n\t\treturn maskScope.call(this, {\r\n\t\t\t\"action\": \"format\",\r\n\t\t\t\"value\": value,\r\n\t\t\t\"metadata\": metadata //true/false getmetadata\r\n\t\t});\r\n\t},\r\n\tsetValue: function (value) {\r\n\t\tif (this.el) {\r\n\t\t\t$(this.el).trigger(\"setvalue\", [value]);\r\n\t\t}\r\n\t},\r\n\tanalyseMask: analyseMask,\r\n\tpositionColorMask: function (input, template) {\r\n\t\tinput.style.left = template.offsetLeft + \"px\";\r\n\t}\r\n};\r\n\r\nfunction resolveAlias(aliasStr, options, opts) {\r\n\tvar aliasDefinition = Inputmask.prototype.aliases[aliasStr];\r\n\tif (aliasDefinition) {\r\n\t\tif (aliasDefinition.alias) resolveAlias(aliasDefinition.alias, undefined, opts); //alias is another alias\r\n\t\t$.extend(true, opts, aliasDefinition); //merge alias definition in the options\r\n\t\t$.extend(true, opts, options); //reapply extra given options\r\n\t\treturn true;\r\n\t} else //alias not found - try as mask\r\n\tif (opts.mask === null) {\r\n\t\topts.mask = aliasStr;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nfunction importAttributeOptions(npt, opts, userOptions, dataAttribute) {\r\n\tfunction importOption(option, optionData) {\r\n\t\toptionData = optionData !== undefined ? optionData : npt.getAttribute(dataAttribute + \"-\" + option);\r\n\t\tif (optionData !== null) {\r\n\t\t\tif (typeof optionData === \"string\") {\r\n\t\t\t\tif (option.indexOf(\"on\") === 0) {\r\n\t\t\t\t\toptionData = window[optionData];\r\n\t\t\t\t}//get function definition\r\n\t\t\t\telse if (optionData === \"false\") {\r\n\t\t\t\t\toptionData = false;\r\n\t\t\t\t} else if (optionData === \"true\") optionData = true;\r\n\t\t\t}\r\n\t\t\tuserOptions[option] = optionData;\r\n\t\t}\r\n\t}\r\n\r\n\tif (opts.importDataAttributes === true) {\r\n\t\tvar attrOptions = npt.getAttribute(dataAttribute), option, dataoptions, optionData, p;\r\n\r\n\t\tif (attrOptions && attrOptions !== \"\") {\r\n\t\t\tattrOptions = attrOptions.replace(/'/g, \"\\\"\");\r\n\t\t\tdataoptions = JSON.parse(\"{\" + attrOptions + \"}\");\r\n\t\t}\r\n\r\n\t\t//resolve aliases\r\n\t\tif (dataoptions) { //pickup alias from dataAttribute\r\n\t\t\toptionData = undefined;\r\n\t\t\tfor (p in dataoptions) {\r\n\t\t\t\tif (p.toLowerCase() === \"alias\") {\r\n\t\t\t\t\toptionData = dataoptions[p];\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\timportOption(\"alias\", optionData); //pickup alias from dataAttribute-alias\r\n\t\tif (userOptions.alias) {\r\n\t\t\tresolveAlias(userOptions.alias, userOptions, opts);\r\n\t\t}\r\n\r\n\t\tfor (option in opts) {\r\n\t\t\tif (dataoptions) {\r\n\t\t\t\toptionData = undefined;\r\n\t\t\t\tfor (p in dataoptions) {\r\n\t\t\t\t\tif (p.toLowerCase() === option.toLowerCase()) {\r\n\t\t\t\t\t\toptionData = dataoptions[p];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\timportOption(option, optionData);\r\n\t\t}\r\n\t}\r\n\t$.extend(true, opts, userOptions);\r\n\r\n\t//handle dir=rtl\r\n\tif (npt.dir === \"rtl\" || opts.rightAlign) {\r\n\t\tnpt.style.textAlign = \"right\";\r\n\t}\r\n\r\n\tif (npt.dir === \"rtl\" || opts.numericInput) {\r\n\t\tnpt.dir = \"ltr\";\r\n\t\tnpt.removeAttribute(\"dir\");\r\n\t\topts.isRTL = true;\r\n\t}\r\n\r\n\treturn Object.keys(userOptions).length;\r\n}\r\n\r\n//apply defaults, definitions, aliases\r\nInputmask.extendDefaults = function (options) {\r\n\t$.extend(true, Inputmask.prototype.defaults, options);\r\n};\r\nInputmask.extendDefinitions = function (definition) {\r\n\t$.extend(true, Inputmask.prototype.definitions, definition);\r\n};\r\nInputmask.extendAliases = function (alias) {\r\n\t$.extend(true, Inputmask.prototype.aliases, alias);\r\n};\r\n//static fn on inputmask\r\nInputmask.format = function (value, options, metadata) {\r\n\treturn Inputmask(options).format(value, metadata);\r\n};\r\nInputmask.unmask = function (value, options) {\r\n\treturn Inputmask(options).unmaskedvalue(value);\r\n};\r\nInputmask.isValid = function (value, options) {\r\n\treturn Inputmask(options).isValid(value);\r\n};\r\nInputmask.remove = function (elems) {\r\n\tif (typeof elems === \"string\") {\r\n\t\telems = document.getElementById(elems) || document.querySelectorAll(elems);\r\n\t}\r\n\telems = elems.nodeName ? [elems] : elems;\r\n\t$.each(elems, function (ndx, el) {\r\n\t\tif (el.inputmask) el.inputmask.remove();\r\n\t});\r\n};\r\nInputmask.setValue = function (elems, value) {\r\n\tif (typeof elems === \"string\") {\r\n\t\telems = document.getElementById(elems) || document.querySelectorAll(elems);\r\n\t}\r\n\telems = elems.nodeName ? [elems] : elems;\r\n\t$.each(elems, function (ndx, el) {\r\n\t\tif (el.inputmask) el.inputmask.setValue(value); else $(el).trigger(\"setvalue\", [value]);\r\n\t});\r\n};\r\nInputmask.escapeRegex = function (str) {\r\n\tvar specials = [\"/\", \".\", \"*\", \"+\", \"?\", \"|\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", \"\\\\\", \"$\", \"^\"];\r\n\treturn str.replace(new RegExp(\"(\\\\\" + specials.join(\"|\\\\\") + \")\", \"gim\"), \"\\\\$1\");\r\n};\r\nInputmask.keyCode = {\r\n\tBACKSPACE: 8,\r\n\tBACKSPACE_SAFARI: 127,\r\n\tDELETE: 46,\r\n\tDOWN: 40,\r\n\tEND: 35,\r\n\tENTER: 13,\r\n\tESCAPE: 27,\r\n\tHOME: 36,\r\n\tINSERT: 45,\r\n\tLEFT: 37,\r\n\tPAGE_DOWN: 34,\r\n\tPAGE_UP: 33,\r\n\tRIGHT: 39,\r\n\tSPACE: 32,\r\n\tTAB: 9,\r\n\tUP: 38,\r\n\tX: 88,\r\n\tCONTROL: 17\r\n};\r\nInputmask.dependencyLib = $;\r\n\r\n//make inputmask available\r\nwindow.Inputmask = Inputmask;\r\nmodule.exports = Inputmask;\r\n","/*\r\n Input Mask plugin dependencyLib\r\n http://github.com/RobinHerbots/jquery.inputmask\r\n Copyright (c) Robin Herbots\r\n Licensed under the MIT license\r\n */\r\n\r\nvar window = require(\"../global/window\"), document = window.document;\r\n//helper functions\r\n\r\n// Use a stripped-down indexOf as it's faster than native\r\n// http://jsperf.com/thor-indexof-vs-for/5\r\nfunction indexOf(list, elem) {\r\n\tvar i = 0,\r\n\t\tlen = list.length;\r\n\tfor (; i < len; i++) {\r\n\t\tif (list[i] === elem) {\r\n\t\t\treturn i;\r\n\t\t}\r\n\t}\r\n\treturn -1;\r\n}\r\n\r\nfunction isWindow(obj) {\r\n\treturn obj != null && obj === obj[\"window\"];\r\n}\r\n\r\nfunction isArraylike(obj) {\r\n\t// Support: iOS 8.2 (not reproducible in simulator)\r\n\t// `in` check used to prevent JIT error (gh-2145)\r\n\t// hasOwn isn't used here due to false negatives\r\n\t// regarding Nodelist length in IE\r\n\tvar length = \"length\" in obj && obj.length,\r\n\t\tltype = typeof obj;\r\n\r\n\tif (ltype === \"function\" || isWindow(obj)) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tif (obj.nodeType === 1 && length) {\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn ltype === \"array\" || length === 0 ||\r\n\t\ttypeof length === \"number\" && length > 0 && (length - 1) in obj;\r\n}\r\n\r\nfunction isValidElement(elem) {\r\n\treturn elem instanceof Element;\r\n}\r\n\r\nfunction DependencyLib(elem) {\r\n\tif (elem instanceof DependencyLib) {\r\n\t\treturn elem;\r\n\t}\r\n\tif (!(this instanceof DependencyLib)) {\r\n\t\treturn new DependencyLib(elem);\r\n\t}\r\n\tif (elem !== undefined && elem !== null && elem !== window) {\r\n\t\tthis[0] = elem.nodeName ? elem : (elem[0] !== undefined && elem[0].nodeName ? elem[0] : document.querySelector(elem));\r\n\t\tif (this[0] !== undefined && this[0] !== null) {\r\n\t\t\tthis[0].eventRegistry = this[0].eventRegistry || {};\r\n\t\t}\r\n\t}\r\n}\r\n\r\nDependencyLib.prototype = {\r\n\ton: function (events, handler) {\r\n\t\tfunction addEvent(ev, namespace) {\r\n\t\t\t//register domevent\r\n\t\t\tif (elem.addEventListener) { // all browsers except IE before version 9\r\n\t\t\t\telem.addEventListener(ev, handler, false);\r\n\t\t\t} else if (elem.attachEvent) { // IE before version 9\r\n\t\t\t\telem.attachEvent(\"on\" + ev, handler);\r\n\t\t\t}\r\n\t\t\teventRegistry[ev] = eventRegistry[ev] || {};\r\n\t\t\teventRegistry[ev][namespace] = eventRegistry[ev][namespace] || [];\r\n\t\t\teventRegistry[ev][namespace].push(handler);\r\n\t\t}\r\n\r\n\t\tif (isValidElement(this[0])) {\r\n\t\t\tvar eventRegistry = this[0].eventRegistry,\r\n\t\t\t\telem = this[0];\r\n\r\n\r\n\t\t\tvar _events = events.split(\" \");\r\n\t\t\tfor (var endx = 0; endx < _events.length; endx++) {\r\n\t\t\t\tvar nsEvent = _events[endx].split(\".\"),\r\n\t\t\t\t\tev = nsEvent[0],\r\n\t\t\t\t\tnamespace = nsEvent[1] || \"global\";\r\n\t\t\t\taddEvent(ev, namespace);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\toff: function (events, handler) {\r\n\t\tvar eventRegistry, elem;\r\n\r\n\t\tfunction removeEvent(ev, namespace, handler) {\r\n\t\t\tif (ev in eventRegistry === true) {\r\n\t\t\t\t//unbind to dom events\r\n\t\t\t\tif (elem.removeEventListener) { // all browsers except IE before version 9\r\n\t\t\t\t\telem.removeEventListener(ev, handler, false);\r\n\t\t\t\t} else if (elem.detachEvent) { // IE before version 9\r\n\t\t\t\t\telem.detachEvent(\"on\" + ev, handler);\r\n\t\t\t\t}\r\n\t\t\t\tif (namespace === \"global\") {\r\n\t\t\t\t\tfor (var nmsp in eventRegistry[ev]) {\r\n\t\t\t\t\t\teventRegistry[ev][nmsp].splice(eventRegistry[ev][nmsp].indexOf(handler), 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\teventRegistry[ev][namespace].splice(eventRegistry[ev][namespace].indexOf(handler), 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction resolveNamespace(ev, namespace) {\r\n\t\t\tvar evts = [],\r\n\t\t\t\thndx, hndL;\r\n\t\t\tif (ev.length > 0) {\r\n\t\t\t\tif (handler === undefined) {\r\n\t\t\t\t\tfor (hndx = 0, hndL = eventRegistry[ev][namespace].length; hndx < hndL; hndx++) {\r\n\t\t\t\t\t\tevts.push({\r\n\t\t\t\t\t\t\tev: ev,\r\n\t\t\t\t\t\t\tnamespace: namespace && namespace.length > 0 ? namespace : \"global\",\r\n\t\t\t\t\t\t\thandler: eventRegistry[ev][namespace][hndx]\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tevts.push({\r\n\t\t\t\t\t\tev: ev,\r\n\t\t\t\t\t\tnamespace: namespace && namespace.length > 0 ? namespace : \"global\",\r\n\t\t\t\t\t\thandler: handler\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t} else if (namespace.length > 0) {\r\n\t\t\t\tfor (var evNdx in eventRegistry) {\r\n\t\t\t\t\tfor (var nmsp in eventRegistry[evNdx]) {\r\n\t\t\t\t\t\tif (nmsp === namespace) {\r\n\t\t\t\t\t\t\tif (handler === undefined) {\r\n\t\t\t\t\t\t\t\tfor (hndx = 0, hndL = eventRegistry[evNdx][nmsp].length; hndx < hndL; hndx++) {\r\n\t\t\t\t\t\t\t\t\tevts.push({\r\n\t\t\t\t\t\t\t\t\t\tev: evNdx,\r\n\t\t\t\t\t\t\t\t\t\tnamespace: nmsp,\r\n\t\t\t\t\t\t\t\t\t\thandler: eventRegistry[evNdx][nmsp][hndx]\r\n\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tevts.push({\r\n\t\t\t\t\t\t\t\t\tev: evNdx,\r\n\t\t\t\t\t\t\t\t\tnamespace: nmsp,\r\n\t\t\t\t\t\t\t\t\thandler: handler\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn evts;\r\n\t\t}\r\n\r\n\t\tif (isValidElement(this[0])) {\r\n\t\t\teventRegistry = this[0].eventRegistry;\r\n\t\t\telem = this[0];\r\n\r\n\r\n\t\t\tvar _events = events.split(\" \");\r\n\t\t\tfor (var endx = 0; endx < _events.length; endx++) {\r\n\t\t\t\tvar nsEvent = _events[endx].split(\".\"),\r\n\t\t\t\t\toffEvents = resolveNamespace(nsEvent[0], nsEvent[1]);\r\n\t\t\t\tfor (var i = 0, offEventsL = offEvents.length; i < offEventsL; i++) {\r\n\t\t\t\t\tremoveEvent(offEvents[i].ev, offEvents[i].namespace, offEvents[i].handler);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\ttrigger: function (events /* , args... */) {\r\n\t\tif (isValidElement(this[0])) {\r\n\t\t\tvar eventRegistry = this[0].eventRegistry,\r\n\t\t\t\telem = this[0];\r\n\t\t\tvar _events = typeof events === \"string\" ? events.split(\" \") : [events.type];\r\n\t\t\tfor (var endx = 0; endx < _events.length; endx++) {\r\n\t\t\t\tvar nsEvent = _events[endx].split(\".\"),\r\n\t\t\t\t\tev = nsEvent[0],\r\n\t\t\t\t\tnamespace = nsEvent[1] || \"global\";\r\n\t\t\t\tif (document !== undefined && namespace === \"global\") {\r\n\t\t\t\t\t//trigger domevent\r\n\t\t\t\t\tvar evnt, i, params = {\r\n\t\t\t\t\t\tbubbles: true,\r\n\t\t\t\t\t\tcancelable: true,\r\n\t\t\t\t\t\tdetail: arguments[1]\r\n\t\t\t\t\t};\r\n\t\t\t\t\t// The custom event that will be created\r\n\t\t\t\t\tif (document.createEvent) {\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tevnt = new CustomEvent(ev, params);\r\n\t\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\t\tevnt = document.createEvent(\"CustomEvent\");\r\n\t\t\t\t\t\t\tevnt.initCustomEvent(ev, params.bubbles, params.cancelable, params.detail);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (events.type) DependencyLib.extend(evnt, events);\r\n\t\t\t\t\t\telem.dispatchEvent(evnt);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tevnt = document.createEventObject();\r\n\t\t\t\t\t\tevnt.eventType = ev;\r\n\t\t\t\t\t\tevnt.detail = arguments[1];\r\n\t\t\t\t\t\tif (events.type) DependencyLib.extend(evnt, events);\r\n\t\t\t\t\t\telem.fireEvent(\"on\" + evnt.eventType, evnt);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (eventRegistry[ev] !== undefined) {\r\n\t\t\t\t\targuments[0] = arguments[0].type ? arguments[0] : DependencyLib.Event(arguments[0]);\r\n\t\t\t\t\targuments[0].detail = arguments.slice(1);\r\n\t\t\t\t\tif (namespace === \"global\") {\r\n\t\t\t\t\t\tfor (var nmsp in eventRegistry[ev]) {\r\n\t\t\t\t\t\t\tfor (i = 0; i < eventRegistry[ev][nmsp].length; i++) {\r\n\t\t\t\t\t\t\t\teventRegistry[ev][nmsp][i].apply(elem, arguments);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tfor (i = 0; i < eventRegistry[ev][namespace].length; i++) {\r\n\t\t\t\t\t\t\teventRegistry[ev][namespace][i].apply(elem, arguments);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n};\r\n\r\n//static\r\nDependencyLib.isFunction = function (obj) {\r\n\treturn typeof obj === \"function\";\r\n};\r\nDependencyLib.noop = function () {\r\n};\r\nDependencyLib.isArray = Array.isArray;\r\nDependencyLib.inArray = function (elem, arr, i) {\r\n\treturn arr == null ? -1 : indexOf(arr, elem, i);\r\n};\r\nDependencyLib.valHooks = undefined;\r\n\r\n\r\nDependencyLib.isPlainObject = function (obj) {\r\n\t// Not plain objects:\r\n\t// - Any object or value whose internal [[Class]] property is not \"[object Object]\"\r\n\t// - DOM nodes\r\n\t// - window\r\n\tif (typeof obj !== \"object\" || obj.nodeType || isWindow(obj)) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tif (obj.constructor && !Object.hasOwnProperty.call(obj.constructor.prototype, \"isPrototypeOf\")) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// If the function hasn't returned already, we're confident that\r\n\t// |obj| is a plain object, created by {} or constructed with new Object\r\n\treturn true;\r\n};\r\n\r\nDependencyLib.extend = function () {\r\n\tvar options, name, src, copy, copyIsArray, clone,\r\n\t\ttarget = arguments[0] || {},\r\n\t\ti = 1,\r\n\t\tlength = arguments.length,\r\n\t\tdeep = false;\r\n\r\n\t// Handle a deep copy situation\r\n\tif (typeof target === \"boolean\") {\r\n\t\tdeep = target;\r\n\r\n\t\t// Skip the boolean and the target\r\n\t\ttarget = arguments[i] || {};\r\n\t\ti++;\r\n\t}\r\n\r\n\t// Handle case when target is a string or something (possible in deep copy)\r\n\tif (typeof target !== \"object\" && !DependencyLib.isFunction(target)) {\r\n\t\ttarget = {};\r\n\t}\r\n\r\n\t// Extend jQuery itself if only one argument is passed\r\n\tif (i === length) {\r\n\t\ttarget = this;\r\n\t\ti--;\r\n\t}\r\n\r\n\tfor (; i < length; i++) {\r\n\t\t// Only deal with non-null/undefined values\r\n\t\tif ((options = arguments[i]) != null) {\r\n\t\t\t// Extend the base object\r\n\t\t\tfor (name in options) {\r\n\t\t\t\tsrc = target[name];\r\n\t\t\t\tcopy = options[name];\r\n\r\n\t\t\t\t// Prevent never-ending loop\r\n\t\t\t\tif (target === copy) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Recurse if we're merging plain objects or arrays\r\n\t\t\t\tif (deep && copy && (DependencyLib.isPlainObject(copy) || (copyIsArray = DependencyLib.isArray(copy)))) {\r\n\t\t\t\t\tif (copyIsArray) {\r\n\t\t\t\t\t\tcopyIsArray = false;\r\n\t\t\t\t\t\tclone = src && DependencyLib.isArray(src) ? src : [];\r\n\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tclone = src && DependencyLib.isPlainObject(src) ? src : {};\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Never move original objects, clone them\r\n\t\t\t\t\ttarget[name] = DependencyLib.extend(deep, clone, copy);\r\n\r\n\t\t\t\t\t// Don't bring in undefined values\r\n\t\t\t\t} else if (copy !== undefined) {\r\n\t\t\t\t\ttarget[name] = copy;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Return the modified object\r\n\treturn target;\r\n};\r\n\r\nDependencyLib.each = function (obj, callback) {\r\n\tvar value, i = 0;\r\n\r\n\tif (isArraylike(obj)) {\r\n\t\tfor (var length = obj.length; i < length; i++) {\r\n\t\t\tvalue = callback.call(obj[i], i, obj[i]);\r\n\t\t\tif (value === false) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t} else {\r\n\t\tfor (i in obj) {\r\n\t\t\tvalue = callback.call(obj[i], i, obj[i]);\r\n\t\t\tif (value === false) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn obj;\r\n};\r\n\r\nDependencyLib.data = function (owner, key, value) {\r\n\tif (value === undefined) {\r\n\t\treturn owner.__data ? owner.__data[key] : null;\r\n\t} else {\r\n\t\towner.__data = owner.__data || {};\r\n\t\towner.__data[key] = value;\r\n\t}\r\n};\r\n\r\nif (typeof window.CustomEvent === \"function\") {\r\n\tDependencyLib.Event = window.CustomEvent;\r\n} else {\r\n\tDependencyLib.Event = function (event, params) {\r\n\t\tparams = params || {bubbles: false, cancelable: false, detail: undefined};\r\n\t\tvar evt = document.createEvent(\"CustomEvent\");\r\n\t\tevt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\r\n\t\treturn evt;\r\n\t};\r\n\tDependencyLib.Event.prototype = window.Event.prototype;\r\n}\r\n\r\nmodule.exports = DependencyLib;\r\n","if (typeof define === \"function\" && define.amd)\r\n\tdefine(function () {\r\n\t\treturn typeof window !== \"undefined\" ? window : new (eval(\"require('jsdom').JSDOM\"))(\"\").window;\r\n\t});\r\nelse if (typeof exports === \"object\")\r\n\tmodule.exports = typeof window !== \"undefined\" ? window : new (eval(\"require('jsdom').JSDOM\"))(\"\").window;\r\n\r\n","var $ = require(\"./dependencyLibs/inputmask.dependencyLib\");\r\n\r\nfunction generateMaskSet(opts, nocache) {\r\n\tvar ms;\r\n\r\n\tfunction generateMask(mask, metadata, opts) {\r\n\t\tvar regexMask = false;\r\n\t\tif (mask === null || mask === \"\") {\r\n\t\t\tregexMask = opts.regex !== null;\r\n\t\t\tif (regexMask) {\r\n\t\t\t\tmask = opts.regex;\r\n\t\t\t\tmask = mask.replace(/^(\\^)(.*)(\\$)$/, \"$2\");\r\n\t\t\t} else {\r\n\t\t\t\tregexMask = true;\r\n\t\t\t\tmask = \".*\";\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (mask.length === 1 && opts.greedy === false && opts.repeat !== 0) {\r\n\t\t\topts.placeholder = \"\";\r\n\t\t} //hide placeholder with single non-greedy mask\r\n\t\tif (opts.repeat > 0 || opts.repeat === \"*\" || opts.repeat === \"+\") {\r\n\t\t\tvar repeatStart = opts.repeat === \"*\" ? 0 : (opts.repeat === \"+\" ? 1 : opts.repeat);\r\n\t\t\tmask = opts.groupmarker[0] + mask + opts.groupmarker[1] + opts.quantifiermarker[0] + repeatStart + \",\" + opts.repeat + opts.quantifiermarker[1];\r\n\t\t}\r\n\r\n\t\t// console.log(mask);\r\n\t\tvar masksetDefinition, maskdefKey;\r\n\t\tmaskdefKey = regexMask ? \"regex_\" + opts.regex : opts.numericInput ? mask.split(\"\").reverse().join(\"\") : mask;\r\n\t\tif (opts.keepStatic !== false) { //keepstatic modifies the output from the testdefinitions ~ so differentiate in the maskcache\r\n\t\t\tmaskdefKey = \"ks_\" + maskdefKey;\r\n\t\t}\r\n\r\n\t\tif (Inputmask.prototype.masksCache[maskdefKey] === undefined || nocache === true) {\r\n\t\t\tmasksetDefinition = {\r\n\t\t\t\t\"mask\": mask,\r\n\t\t\t\t\"maskToken\": Inputmask.prototype.analyseMask(mask, regexMask, opts),\r\n\t\t\t\t\"validPositions\": {},\r\n\t\t\t\t\"_buffer\": undefined,\r\n\t\t\t\t\"buffer\": undefined,\r\n\t\t\t\t\"tests\": {},\r\n\t\t\t\t\"excludes\": {}, //excluded alternations\r\n\t\t\t\t\"metadata\": metadata,\r\n\t\t\t\t\"maskLength\": undefined,\r\n\t\t\t\t\"jitOffset\": {}\r\n\t\t\t};\r\n\t\t\tif (nocache !== true) {\r\n\t\t\t\tInputmask.prototype.masksCache[maskdefKey] = masksetDefinition;\r\n\t\t\t\tmasksetDefinition = $.extend(true, {}, Inputmask.prototype.masksCache[maskdefKey]);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tmasksetDefinition = $.extend(true, {}, Inputmask.prototype.masksCache[maskdefKey]);\r\n\t\t}\r\n\r\n\t\treturn masksetDefinition;\r\n\t}\r\n\r\n\tif ($.isFunction(opts.mask)) { //allow mask to be a preprocessing fn - should return a valid mask\r\n\t\topts.mask = opts.mask(opts);\r\n\t}\r\n\tif ($.isArray(opts.mask)) {\r\n\t\tif (opts.mask.length > 1) {\r\n\t\t\tif (opts.keepStatic === null) { //enable by default when passing multiple masks when the option is not explicitly specified\r\n\t\t\t\topts.keepStatic = \"auto\";\r\n\t\t\t\tfor (var i = 0; i < opts.mask.length; i++) {\r\n\t\t\t\t\tif (opts.mask[i].charAt(0) !== opts.mask[0].charAt(0)) {\r\n\t\t\t\t\t\topts.keepStatic = true;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar altMask = opts.groupmarker[0];\r\n\t\t\t$.each(opts.isRTL ? opts.mask.reverse() : opts.mask, function (ndx, msk) {\r\n\t\t\t\tif (altMask.length > 1) {\r\n\t\t\t\t\taltMask += opts.groupmarker[1] + opts.alternatormarker + opts.groupmarker[0];\r\n\t\t\t\t}\r\n\t\t\t\tif (msk.mask !== undefined && !$.isFunction(msk.mask)) {\r\n\t\t\t\t\taltMask += msk.mask;\r\n\t\t\t\t} else {\r\n\t\t\t\t\taltMask += msk;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\taltMask += opts.groupmarker[1];\r\n\t\t\t// console.log(altMask);\r\n\t\t\treturn generateMask(altMask, opts.mask, opts);\r\n\t\t} else {\r\n\t\t\topts.mask = opts.mask.pop();\r\n\t\t}\r\n\t}\r\n\r\n\tif (opts.mask && opts.mask.mask !== undefined && !$.isFunction(opts.mask.mask)) {\r\n\t\tms = generateMask(opts.mask.mask, opts.mask, opts);\r\n\t} else {\r\n\t\tms = generateMask(opts.mask, opts.mask, opts);\r\n\t}\r\n\r\n\treturn ms;\r\n}\r\n\r\nfunction analyseMask(mask, regexMask, opts) {\r\n\tvar tokenizer = /(?:[?*+]|\\{[0-9+*]+(?:,[0-9+*]*)?(?:\\|[0-9+*]*)?\\})|[^.?*+^${[]()|\\\\]+|./g,\r\n\t\t//Thx to https://github.com/slevithan/regex-colorizer for the regexTokenizer regex\r\n\t\tregexTokenizer = /\\[\\^?]?(?:[^\\\\\\]]+|\\\\[\\S\\s]?)*]?|\\\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\\S\\s]?)|\\((?:\\?[:=!]?)?|(?:[?*+]|\\{[0-9]+(?:,[0-9]*)?\\})\\??|[^.?*+^${[()|\\\\]+|./g,\r\n\t\tescaped = false,\r\n\t\tcurrentToken = new MaskToken(),\r\n\t\tmatch,\r\n\t\tm,\r\n\t\topenenings = [],\r\n\t\tmaskTokens = [],\r\n\t\topeningToken,\r\n\t\tcurrentOpeningToken,\r\n\t\talternator,\r\n\t\tlastMatch,\r\n\t\tcloseRegexGroup = false;\r\n\r\n\tfunction MaskToken(isGroup, isOptional, isQuantifier, isAlternator) {\r\n\t\tthis.matches = [];\r\n\t\tthis.openGroup = isGroup || false;\r\n\t\tthis.alternatorGroup = false;\r\n\t\tthis.isGroup = isGroup || false;\r\n\t\tthis.isOptional = isOptional || false;\r\n\t\tthis.isQuantifier = isQuantifier || false;\r\n\t\tthis.isAlternator = isAlternator || false;\r\n\t\tthis.quantifier = {\r\n\t\t\tmin: 1,\r\n\t\t\tmax: 1\r\n\t\t};\r\n\t}\r\n\r\n\t//test definition => {fn: RegExp/function, static: true/false optionality: bool, newBlockMarker: bool, casing: null/upper/lower, def: definitionSymbol, placeholder: placeholder, mask: real maskDefinition}\r\n\tfunction insertTestDefinition(mtoken, element, position) {\r\n\t\tposition = position !== undefined ? position : mtoken.matches.length;\r\n\t\tvar prevMatch = mtoken.matches[position - 1];\r\n\t\tif (regexMask) {\r\n\t\t\tif (element.indexOf(\"[\") === 0 || (escaped && /\\\\d|\\\\s|\\\\w]/i.test(element)) || element === \".\") {\r\n\t\t\t\tmtoken.matches.splice(position++, 0, {\r\n\t\t\t\t\tfn: new RegExp(element, opts.casing ? \"i\" : \"\"),\r\n\t\t\t\t\tstatic: false,\r\n\t\t\t\t\toptionality: false,\r\n\t\t\t\t\tnewBlockMarker: prevMatch === undefined ? \"master\" : prevMatch.def !== element,\r\n\t\t\t\t\tcasing: null,\r\n\t\t\t\t\tdef: element,\r\n\t\t\t\t\tplaceholder: undefined,\r\n\t\t\t\t\tnativeDef: element\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\tif (escaped) element = element[element.length - 1];\r\n\t\t\t\t$.each(element.split(\"\"), function (ndx, lmnt) {\r\n\t\t\t\t\tprevMatch = mtoken.matches[position - 1];\r\n\t\t\t\t\tmtoken.matches.splice(position++, 0, {\r\n\t\t\t\t\t\tfn: /[a-z]/i.test((opts.staticDefinitionSymbol || lmnt)) ? new RegExp(\"[\" + (opts.staticDefinitionSymbol || lmnt) + \"]\", opts.casing ? \"i\" : \"\") : null,\r\n\t\t\t\t\t\tstatic: true,\r\n\t\t\t\t\t\toptionality: false,\r\n\t\t\t\t\t\tnewBlockMarker: prevMatch === undefined ? \"master\" : (prevMatch.def !== lmnt && prevMatch.static !== true),\r\n\t\t\t\t\t\tcasing: null,\r\n\t\t\t\t\t\tdef: opts.staticDefinitionSymbol || lmnt,\r\n\t\t\t\t\t\tplaceholder: opts.staticDefinitionSymbol !== undefined ? lmnt : undefined,\r\n\t\t\t\t\t\tnativeDef: (escaped ? \"'\" : \"\") + lmnt\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tescaped = false;\r\n\t\t} else {\r\n\t\t\tvar maskdef = (opts.definitions ? opts.definitions[element] : undefined) || Inputmask.prototype.definitions[element];\r\n\t\t\tif (maskdef && !escaped) {\r\n\t\t\t\tmtoken.matches.splice(position++, 0, {\r\n\t\t\t\t\tfn: maskdef.validator ? typeof maskdef.validator == \"string\" ? new RegExp(maskdef.validator, opts.casing ? \"i\" : \"\") : new function () {\r\n\t\t\t\t\t\tthis.test = maskdef.validator;\r\n\t\t\t\t\t} : new RegExp(\".\"),\r\n\t\t\t\t\tstatic: false,\r\n\t\t\t\t\toptionality: false,\r\n\t\t\t\t\tnewBlockMarker: prevMatch === undefined ? \"master\" : prevMatch.def !== (maskdef.definitionSymbol || element),\r\n\t\t\t\t\tcasing: maskdef.casing,\r\n\t\t\t\t\tdef: maskdef.definitionSymbol || element,\r\n\t\t\t\t\tplaceholder: maskdef.placeholder,\r\n\t\t\t\t\tnativeDef: element\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\tmtoken.matches.splice(position++, 0, {\r\n\t\t\t\t\tfn: /[a-z]/i.test((opts.staticDefinitionSymbol || element)) ? new RegExp(\"[\" + (opts.staticDefinitionSymbol || element) + \"]\", opts.casing ? \"i\" : \"\") : null,\r\n\t\t\t\t\tstatic: true,\r\n\t\t\t\t\toptionality: false,\r\n\t\t\t\t\tnewBlockMarker: prevMatch === undefined ? \"master\" : (prevMatch.def !== element && prevMatch.static !== true),\r\n\t\t\t\t\tcasing: null,\r\n\t\t\t\t\tdef: opts.staticDefinitionSymbol || element,\r\n\t\t\t\t\tplaceholder: opts.staticDefinitionSymbol !== undefined ? element : undefined,\r\n\t\t\t\t\tnativeDef: (escaped ? \"'\" : \"\") + element\r\n\t\t\t\t});\r\n\t\t\t\tescaped = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction verifyGroupMarker(maskToken) {\r\n\t\tif (maskToken && maskToken.matches) {\r\n\t\t\t$.each(maskToken.matches, function (ndx, token) {\r\n\t\t\t\tvar nextToken = maskToken.matches[ndx + 1];\r\n\t\t\t\tif ((nextToken === undefined || (nextToken.matches === undefined || nextToken.isQuantifier === false)) && token && token.isGroup) { //this is not a group but a normal mask => convert\r\n\t\t\t\t\ttoken.isGroup = false;\r\n\t\t\t\t\tif (!regexMask) {\r\n\t\t\t\t\t\tinsertTestDefinition(token, opts.groupmarker[0], 0);\r\n\t\t\t\t\t\tif (token.openGroup !== true) {\r\n\t\t\t\t\t\t\tinsertTestDefinition(token, opts.groupmarker[1]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tverifyGroupMarker(token);\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\tfunction defaultCase() {\r\n\t\tif (openenings.length > 0) {\r\n\t\t\tcurrentOpeningToken = openenings[openenings.length - 1];\r\n\t\t\tinsertTestDefinition(currentOpeningToken, m);\r\n\t\t\tif (currentOpeningToken.isAlternator) { //handle alternator a | b case\r\n\t\t\t\talternator = openenings.pop();\r\n\t\t\t\tfor (var mndx = 0; mndx < alternator.matches.length; mndx++) {\r\n\t\t\t\t\tif (alternator.matches[mndx].isGroup) alternator.matches[mndx].isGroup = false; //don't mark alternate groups as group\r\n\t\t\t\t}\r\n\t\t\t\tif (openenings.length > 0) {\r\n\t\t\t\t\tcurrentOpeningToken = openenings[openenings.length - 1];\r\n\t\t\t\t\tcurrentOpeningToken.matches.push(alternator);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcurrentToken.matches.push(alternator);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tinsertTestDefinition(currentToken, m);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction reverseTokens(maskToken) {\r\n\t\tfunction reverseStatic(st) {\r\n\t\t\tif (st === opts.optionalmarker[0]) {\r\n\t\t\t\tst = opts.optionalmarker[1];\r\n\t\t\t} else if (st === opts.optionalmarker[1]) {\r\n\t\t\t\tst = opts.optionalmarker[0];\r\n\t\t\t} else if (st === opts.groupmarker[0]) {\r\n\t\t\t\tst = opts.groupmarker[1];\r\n\t\t\t} else if (st === opts.groupmarker[1]) st = opts.groupmarker[0];\r\n\r\n\t\t\treturn st;\r\n\t\t}\r\n\r\n\t\tmaskToken.matches = maskToken.matches.reverse();\r\n\t\tfor (var match in maskToken.matches) {\r\n\t\t\tif (maskToken.matches.hasOwnProperty(match)) {\r\n\t\t\t\tvar intMatch = parseInt(match);\r\n\t\t\t\tif (maskToken.matches[match].isQuantifier && maskToken.matches[intMatch + 1] && maskToken.matches[intMatch + 1].isGroup) { //reposition quantifier\r\n\t\t\t\t\tvar qt = maskToken.matches[match];\r\n\t\t\t\t\tmaskToken.matches.splice(match, 1);\r\n\t\t\t\t\tmaskToken.matches.splice(intMatch + 1, 0, qt);\r\n\t\t\t\t}\r\n\t\t\t\tif (maskToken.matches[match].matches !== undefined) {\r\n\t\t\t\t\tmaskToken.matches[match] = reverseTokens(maskToken.matches[match]);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tmaskToken.matches[match] = reverseStatic(maskToken.matches[match]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn maskToken;\r\n\t}\r\n\r\n\tfunction groupify(matches) {\r\n\t\tvar groupToken = new MaskToken(true);\r\n\t\tgroupToken.openGroup = false;\r\n\t\tgroupToken.matches = matches;\r\n\t\treturn groupToken;\r\n\t}\r\n\r\n\tfunction closeGroup() {\r\n\t\t// Group closing\r\n\t\topeningToken = openenings.pop();\r\n\t\topeningToken.openGroup = false; //mark group as complete\r\n\t\tif (openingToken !== undefined) {\r\n\t\t\tif (openenings.length > 0) {\r\n\t\t\t\tcurrentOpeningToken = openenings[openenings.length - 1];\r\n\t\t\t\tcurrentOpeningToken.matches.push(openingToken);\r\n\t\t\t\tif (currentOpeningToken.isAlternator) { //handle alternator (a) | (b) case\r\n\t\t\t\t\talternator = openenings.pop();\r\n\t\t\t\t\tfor (var mndx = 0; mndx < alternator.matches.length; mndx++) {\r\n\t\t\t\t\t\talternator.matches[mndx].isGroup = false; //don't mark alternate groups as group\r\n\t\t\t\t\t\talternator.matches[mndx].alternatorGroup = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (openenings.length > 0) {\r\n\t\t\t\t\t\tcurrentOpeningToken = openenings[openenings.length - 1];\r\n\t\t\t\t\t\tcurrentOpeningToken.matches.push(alternator);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tcurrentToken.matches.push(alternator);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tcurrentToken.matches.push(openingToken);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tdefaultCase();\r\n\t\t}\r\n\t}\r\n\r\n\tfunction groupQuantifier(matches) {\r\n\t\tvar lastMatch = matches.pop();\r\n\t\tif (lastMatch.isQuantifier) {\r\n\t\t\tlastMatch = groupify([matches.pop(), lastMatch]);\r\n\t\t}\r\n\t\treturn lastMatch;\r\n\t}\r\n\r\n\tif (regexMask) {\r\n\t\topts.optionalmarker[0] = undefined;\r\n\t\topts.optionalmarker[1] = undefined;\r\n\t}\r\n\twhile ((match = regexMask ? regexTokenizer.exec(mask) : tokenizer.exec(mask))) {\r\n\t\tm = match[0];\r\n\r\n\t\tif (regexMask) {\r\n\t\t\tswitch (m.charAt(0)) {\r\n\t\t\t\t//Quantifier\r\n\t\t\t\tcase \"?\":\r\n\t\t\t\t\tm = \"{0,1}\";\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"+\":\r\n\t\t\t\tcase \"*\":\r\n\t\t\t\t\tm = \"{\" + m + \"}\";\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"|\":\r\n\t\t\t\t\t//regex mask alternator  ex: [01][0-9]|2[0-3] => ([01][0-9]|2[0-3])\r\n\t\t\t\t\tif (openenings.length === 0) { //wrap the mask in a group to form a regex alternator  ([01][0-9]|2[0-3])\r\n\t\t\t\t\t\tvar altRegexGroup = groupify(currentToken.matches);\r\n\t\t\t\t\t\taltRegexGroup.openGroup = true;\r\n\t\t\t\t\t\topenenings.push(altRegexGroup);\r\n\t\t\t\t\t\tcurrentToken.matches = [];\r\n\t\t\t\t\t\tcloseRegexGroup = true;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (escaped) {\r\n\t\t\tdefaultCase();\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tswitch (m.charAt(0)) {\r\n\t\t\tcase \"(?=\": //lookahead\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"(?!\": //negative lookahead\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"(?<=\": //lookbehind\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"(?<!\": //negative lookbehind\r\n\t\t\t\tbreak;\r\n\t\t\tcase opts.escapeChar:\r\n\t\t\t\tescaped = true;\r\n\t\t\t\tif (regexMask) {\r\n\t\t\t\t\tdefaultCase();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t// optional closing\r\n\t\t\tcase opts.optionalmarker[1]:\r\n\t\t\tcase opts.groupmarker[1]:\r\n\t\t\t\tcloseGroup();\r\n\t\t\t\tbreak;\r\n\t\t\tcase opts.optionalmarker[0]:\r\n\t\t\t\t// optional opening\r\n\t\t\t\topenenings.push(new MaskToken(false, true));\r\n\t\t\t\tbreak;\r\n\t\t\tcase opts.groupmarker[0]:\r\n\t\t\t\t// Group opening\r\n\t\t\t\topenenings.push(new MaskToken(true));\r\n\t\t\t\tbreak;\r\n\t\t\tcase opts.quantifiermarker[0]:\r\n\t\t\t\t//Quantifier\r\n\t\t\t\tvar quantifier = new MaskToken(false, false, true);\r\n\r\n\t\t\t\tm = m.replace(/[{}]/g, \"\");\r\n\t\t\t\tvar mqj = m.split(\"|\"),\r\n\t\t\t\t\tmq = mqj[0].split(\",\"),\r\n\t\t\t\t\tmq0 = isNaN(mq[0]) ? mq[0] : parseInt(mq[0]),\r\n\t\t\t\t\tmq1 = mq.length === 1 ? mq0 : (isNaN(mq[1]) ? mq[1] : parseInt(mq[1]));\r\n\t\t\t\tif (mq0 === \"*\" || mq0 === \"+\") {\r\n\t\t\t\t\tmq0 = mq1 === \"*\" ? 0 : 1;\r\n\t\t\t\t}\r\n\t\t\t\tquantifier.quantifier = {\r\n\t\t\t\t\tmin: mq0,\r\n\t\t\t\t\tmax: mq1,\r\n\t\t\t\t\tjit: mqj[1]\r\n\t\t\t\t};\r\n\t\t\t\tvar matches = openenings.length > 0 ? openenings[openenings.length - 1].matches : currentToken.matches;\r\n\t\t\t\tmatch = matches.pop();\r\n\t\t\t\tif (match.isAlternator) { //handle quantifier in an alternation [0-9]{2}|[0-9]{3}\r\n\t\t\t\t\tmatches.push(match); //push back alternator\r\n\t\t\t\t\tmatches = match.matches; //remap target matches\r\n\t\t\t\t\tvar groupToken = new MaskToken(true);\r\n\t\t\t\t\tvar tmpMatch = matches.pop();\r\n\t\t\t\t\tmatches.push(groupToken); //push the group\r\n\t\t\t\t\tmatches = groupToken.matches;\r\n\t\t\t\t\tmatch = tmpMatch;\r\n\t\t\t\t}\r\n\t\t\t\tif (!match.isGroup) {\r\n\t\t\t\t\t// if (regexMask && match.fn === null) { //why is this needed???\r\n\t\t\t\t\t//     if (match.def === \".\") match.fn = new RegExp(match.def, opts.casing ? \"i\" : \"\");\r\n\t\t\t\t\t// }\r\n\r\n\t\t\t\t\tmatch = groupify([match]);\r\n\t\t\t\t}\r\n\t\t\t\tmatches.push(match);\r\n\t\t\t\tmatches.push(quantifier);\r\n\r\n\t\t\t\tbreak;\r\n\t\t\tcase opts.alternatormarker:\r\n\r\n\r\n\t\t\t\tif (openenings.length > 0) {\r\n\t\t\t\t\tcurrentOpeningToken = openenings[openenings.length - 1];\r\n\t\t\t\t\tvar subToken = currentOpeningToken.matches[currentOpeningToken.matches.length - 1];\r\n\t\t\t\t\tif (currentOpeningToken.openGroup && //regexp alt syntax\r\n\t\t\t\t\t\t(subToken.matches === undefined || (subToken.isGroup === false && subToken.isAlternator === false))) { //alternations within group\r\n\t\t\t\t\t\tlastMatch = openenings.pop();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tlastMatch = groupQuantifier(currentOpeningToken.matches);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlastMatch = groupQuantifier(currentToken.matches);\r\n\t\t\t\t}\r\n\t\t\t\tif (lastMatch.isAlternator) {\r\n\t\t\t\t\topenenings.push(lastMatch);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (lastMatch.alternatorGroup) {\r\n\t\t\t\t\t\talternator = openenings.pop();\r\n\t\t\t\t\t\tlastMatch.alternatorGroup = false;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\talternator = new MaskToken(false, false, false, true);\r\n\t\t\t\t\t}\r\n\t\t\t\t\talternator.matches.push(lastMatch);\r\n\t\t\t\t\topenenings.push(alternator);\r\n\t\t\t\t\tif (lastMatch.openGroup) { //regexp alt syntax\r\n\t\t\t\t\t\tlastMatch.openGroup = false;\r\n\t\t\t\t\t\tvar alternatorGroup = new MaskToken(true);\r\n\t\t\t\t\t\talternatorGroup.alternatorGroup = true;\r\n\t\t\t\t\t\topenenings.push(alternatorGroup);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tdefaultCase();\r\n\t\t}\r\n\t}\r\n\r\n\tif (closeRegexGroup) closeGroup();\r\n\r\n\twhile (openenings.length > 0) {\r\n\t\topeningToken = openenings.pop();\r\n\t\tcurrentToken.matches.push(openingToken);\r\n\t}\r\n\tif (currentToken.matches.length > 0) {\r\n\t\tverifyGroupMarker(currentToken);\r\n\t\tmaskTokens.push(currentToken);\r\n\t}\r\n\r\n\tif (opts.numericInput || opts.isRTL) {\r\n\t\treverseTokens(maskTokens[0]);\r\n\t}\r\n\t// console.log(JSON.stringify(maskTokens));\r\n\treturn maskTokens;\r\n}\r\n\r\nmodule.exports = {\r\n\tgenerateMaskSet: generateMaskSet,\r\n\tanalyseMask: analyseMask\r\n};","var $ = require(\"./dependencyLibs/inputmask.dependencyLib\"), window = require(\"./global/window\"),\r\n\tdocument = window.document,\r\n\tua = window.navigator.userAgent,\r\n\tie = (ua.indexOf(\"MSIE \") > 0) || (ua.indexOf(\"Trident/\") > 0),\r\n\tmobile = isInputEventSupported(\"touchstart\"), //not entirely correct but will currently do\r\n\tiemobile = /iemobile/i.test(ua),\r\n\tiphone = /iphone/i.test(ua) && !iemobile;\r\n\r\nfunction isInputEventSupported(eventName) {\r\n\tvar el = document.createElement(\"input\"),\r\n\t\tevName = \"on\" + eventName,\r\n\t\tisSupported = (evName in el);\r\n\tif (!isSupported) {\r\n\t\tel.setAttribute(evName, \"return;\");\r\n\t\tisSupported = typeof el[evName] === \"function\";\r\n\t}\r\n\tel = null;\r\n\treturn isSupported;\r\n}\r\n\r\n//masking scope\r\n//actionObj definition see below\r\nmodule.exports = function maskScope(actionObj, maskset, opts) {\r\n\tmaskset = maskset || this.maskset;\r\n\topts = opts || this.opts;\r\n\r\n\tvar inputmask = this,\r\n\t\tel = this.el,\r\n\t\tisRTL = this.isRTL || (this.isRTL = opts.numericInput),\r\n\t\tundoValue,\r\n\t\t$el,\r\n\t\tskipKeyPressEvent = false, //Safari 5.1.x - modal dialog fires keypress twice workaround\r\n\t\tskipInputEvent = false, //skip when triggered from within inputmask\r\n\t\tignorable = false,\r\n\t\tmaxLength,\r\n\t\tmouseEnter = false,\r\n\t\tcolorMask,\r\n\t\toriginalPlaceholder,\r\n\t\tfocusDelay = 0;\r\n\r\n\t//maskset helperfunctions\r\n\tfunction getMaskTemplate(baseOnInput, minimalPos, includeMode, noJit, clearOptionalTail) {\r\n\t\t//includeMode true => input, undefined => placeholder, false => mask\r\n\r\n\t\tvar greedy = opts.greedy;\r\n\t\tif (clearOptionalTail) opts.greedy = false;\r\n\t\tminimalPos = minimalPos || 0;\r\n\t\tvar maskTemplate = [],\r\n\t\t\tndxIntlzr, pos = 0,\r\n\t\t\ttest, testPos;\r\n\t\tdo {\r\n\t\t\tif (baseOnInput === true && maskset.validPositions[pos]) {\r\n\t\t\t\ttestPos = (clearOptionalTail && maskset.validPositions[pos].match.optionality === true\r\n\t\t\t\t\t&& maskset.validPositions[pos + 1] === undefined\r\n\t\t\t\t\t&& (maskset.validPositions[pos].generatedInput === true || (maskset.validPositions[pos].input == opts.skipOptionalPartCharacter && pos > 0)))\r\n\t\t\t\t\t? determineTestTemplate(pos, getTests(pos, ndxIntlzr, pos - 1))\r\n\t\t\t\t\t: maskset.validPositions[pos];\r\n\t\t\t\ttest = testPos.match;\r\n\t\t\t\tndxIntlzr = testPos.locator.slice();\r\n\t\t\t\tmaskTemplate.push(includeMode === true ? testPos.input : includeMode === false ? test.nativeDef : getPlaceholder(pos, test));\r\n\t\t\t} else {\r\n\t\t\t\ttestPos = getTestTemplate(pos, ndxIntlzr, pos - 1);\r\n\t\t\t\ttest = testPos.match;\r\n\t\t\t\tndxIntlzr = testPos.locator.slice();\r\n\t\t\t\tvar jitMasking = noJit === true ? false : (opts.jitMasking !== false ? opts.jitMasking : test.jit);\r\n\t\t\t\tif (jitMasking === false || jitMasking === undefined /*|| pos < lvp*/ || (typeof jitMasking === \"number\" && isFinite(jitMasking) && jitMasking > pos)) {\r\n\t\t\t\t\tmaskTemplate.push(includeMode === false ? test.nativeDef : getPlaceholder(pos, test));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (opts.keepStatic === \"auto\") {\r\n\t\t\t\tif (test.newBlockMarker && test.static !== true) {\r\n\t\t\t\t\topts.keepStatic = pos - 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tpos++;\r\n\t\t} while ((maxLength === undefined || pos < maxLength) && (test.static !== true || test.def !== \"\") || minimalPos > pos);\r\n\t\tif (maskTemplate[maskTemplate.length - 1] === \"\") {\r\n\t\t\tmaskTemplate.pop(); //drop the last one which is empty\r\n\t\t}\r\n\t\tif (includeMode !== false || //do not alter the masklength when just retrieving the maskdefinition\r\n\t\t\tmaskset.maskLength === undefined) //just make sure the maskLength gets initialized in all cases (needed for isValid)\r\n\t\t{\r\n\t\t\tmaskset.maskLength = pos - 1;\r\n\t\t}\r\n\r\n\t\topts.greedy = greedy;\r\n\t\treturn maskTemplate;\r\n\t}\r\n\r\n\tfunction resetMaskSet(soft) {\r\n\t\tmaskset.buffer = undefined;\r\n\t\tif (soft !== true) {\r\n\t\t\tmaskset.validPositions = {};\r\n\t\t\tmaskset.p = 0;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getLastValidPosition(closestTo, strict, validPositions) {\r\n\t\tvar before = -1,\r\n\t\t\tafter = -1,\r\n\t\t\tvalids = validPositions || maskset.validPositions; //for use in valhook ~ context switch\r\n\t\tif (closestTo === undefined) closestTo = -1;\r\n\t\tfor (var posNdx in valids) {\r\n\t\t\tvar psNdx = parseInt(posNdx);\r\n\t\t\tif (valids[psNdx] && (strict || valids[psNdx].generatedInput !== true)) {\r\n\t\t\t\tif (psNdx <= closestTo) before = psNdx;\r\n\t\t\t\tif (psNdx >= closestTo) after = psNdx;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn (before === -1 || before == closestTo) ? after : after == -1 ? before : (closestTo - before) < (after - closestTo) ? before : after;\r\n\t}\r\n\r\n\tfunction getDecisionTaker(tst) {\r\n\t\tvar decisionTaker = tst.locator[tst.alternation];\r\n\t\tif (typeof decisionTaker == \"string\" && decisionTaker.length > 0) { //no decision taken ~ take first one as decider\r\n\t\t\tdecisionTaker = decisionTaker.split(\",\")[0];\r\n\t\t}\r\n\t\treturn decisionTaker !== undefined ? decisionTaker.toString() : \"\";\r\n\t}\r\n\r\n\tfunction getLocator(tst, align) { //need to align the locators to be correct\r\n\t\tvar locator = (tst.alternation != undefined ? tst.mloc[getDecisionTaker(tst)] : tst.locator).join(\"\");\r\n\t\tif (locator !== \"\") while (locator.length < align) locator += \"0\";\r\n\t\treturn locator;\r\n\t}\r\n\r\n\tfunction determineTestTemplate(pos, tests) {\r\n\t\tpos = pos > 0 ? pos - 1 : 0;\r\n\t\tvar altTest = getTest(pos), targetLocator = getLocator(altTest), tstLocator, closest, bestMatch;\r\n\t\tfor (var ndx = 0; ndx < tests.length; ndx++) { //find best matching\r\n\t\t\tvar tst = tests[ndx];\r\n\t\t\ttstLocator = getLocator(tst, targetLocator.length);\r\n\t\t\tvar distance = Math.abs(tstLocator - targetLocator);\r\n\t\t\tif (closest === undefined\r\n\t\t\t\t|| (tstLocator !== \"\" && distance < closest)\r\n\t\t\t\t|| (bestMatch && !opts.greedy && bestMatch.match.optionality && bestMatch.match.newBlockMarker === \"master\" && (!tst.match.optionality || !tst.match.newBlockMarker))\r\n\t\t\t\t|| (bestMatch && bestMatch.match.optionalQuantifier && !tst.match.optionalQuantifier)) {\r\n\t\t\t\tclosest = distance;\r\n\t\t\t\tbestMatch = tst;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn bestMatch;\r\n\t}\r\n\r\n\r\n\tfunction getTestTemplate(pos, ndxIntlzr, tstPs) {\r\n\t\treturn maskset.validPositions[pos] || determineTestTemplate(pos, getTests(pos, ndxIntlzr ? ndxIntlzr.slice() : ndxIntlzr, tstPs));\r\n\t}\r\n\r\n\tfunction getTest(pos, tests) {\r\n\t\tif (maskset.validPositions[pos]) {\r\n\t\t\treturn maskset.validPositions[pos];\r\n\t\t}\r\n\t\treturn (tests || getTests(pos))[0];\r\n\t}\r\n\r\n\tfunction positionCanMatchDefinition(pos, def) {\r\n\t\tvar valid = false,\r\n\t\t\ttests = getTests(pos);\r\n\t\tfor (var tndx = 0; tndx < tests.length; tndx++) {\r\n\t\t\tif (tests[tndx].match && tests[tndx].match.def === def) {\r\n\t\t\t\tvalid = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (valid === false) {\r\n\t\t\tif (maskset.jitOffset[pos] !== undefined) {\r\n\t\t\t\tvalid = positionCanMatchDefinition(pos + maskset.jitOffset[pos], def);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn valid;\r\n\t}\r\n\r\n\r\n\tfunction getTests(pos, ndxIntlzr, tstPs) {\r\n\t\tvar maskTokens = maskset.maskToken,\r\n\t\t\ttestPos = ndxIntlzr ? tstPs : 0,\r\n\t\t\tndxInitializer = ndxIntlzr ? ndxIntlzr.slice() : [0],\r\n\t\t\tmatches = [],\r\n\t\t\tinsertStop = false,\r\n\t\t\tlatestMatch,\r\n\t\t\tcacheDependency = ndxIntlzr ? ndxIntlzr.join(\"\") : \"\";\r\n\r\n\t\tfunction resolveTestFromToken(maskToken, ndxInitializer, loopNdx, quantifierRecurse) { //ndxInitializer contains a set of indexes to speedup searches in the mtokens\r\n\t\t\tfunction handleMatch(match, loopNdx, quantifierRecurse) {\r\n\t\t\t\tfunction isFirstMatch(latestMatch, tokenGroup) {\r\n\t\t\t\t\tvar firstMatch = $.inArray(latestMatch, tokenGroup.matches) === 0;\r\n\t\t\t\t\tif (!firstMatch) {\r\n\t\t\t\t\t\t$.each(tokenGroup.matches, function (ndx, match) {\r\n\t\t\t\t\t\t\tif (match.isQuantifier === true) {\r\n\t\t\t\t\t\t\t\tfirstMatch = isFirstMatch(latestMatch, tokenGroup.matches[ndx - 1]);\r\n\t\t\t\t\t\t\t} else if (match.hasOwnProperty(\"matches\")) firstMatch = isFirstMatch(latestMatch, match);\r\n\t\t\t\t\t\t\tif (firstMatch) return false;\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn firstMatch;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfunction resolveNdxInitializer(pos, alternateNdx, targetAlternation) {\r\n\t\t\t\t\tvar bestMatch, indexPos;\r\n\r\n\t\t\t\t\tif (maskset.tests[pos] || maskset.validPositions[pos]) {\r\n\t\t\t\t\t\t$.each(maskset.tests[pos] || [maskset.validPositions[pos]], function (ndx, lmnt) {\r\n\t\t\t\t\t\t\tif (lmnt.mloc[alternateNdx]) {\r\n\t\t\t\t\t\t\t\tbestMatch = lmnt;\r\n\t\t\t\t\t\t\t\treturn false; //break\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvar alternation = targetAlternation !== undefined ? targetAlternation : lmnt.alternation,\r\n\t\t\t\t\t\t\t\tndxPos = lmnt.locator[alternation] !== undefined ? lmnt.locator[alternation].toString().indexOf(alternateNdx) : -1;\r\n\t\t\t\t\t\t\tif ((indexPos === undefined || ndxPos < indexPos) && ndxPos !== -1) {\r\n\t\t\t\t\t\t\t\tbestMatch = lmnt;\r\n\t\t\t\t\t\t\t\tindexPos = ndxPos;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (bestMatch) {\r\n\t\t\t\t\t\tvar bestMatchAltIndex = bestMatch.locator[bestMatch.alternation];\r\n\t\t\t\t\t\tvar locator = bestMatch.mloc[alternateNdx] || bestMatch.mloc[bestMatchAltIndex] || bestMatch.locator;\r\n\t\t\t\t\t\treturn locator.slice((targetAlternation !== undefined ? targetAlternation : bestMatch.alternation) + 1);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn targetAlternation !== undefined ? resolveNdxInitializer(pos, alternateNdx) : undefined;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfunction isSubsetOf(source, target) {\r\n\t\t\t\t\tfunction expand(pattern) {\r\n\t\t\t\t\t\tvar expanded = [], start = -1, end;\r\n\t\t\t\t\t\tfor (var i = 0, l = pattern.length; i < l; i++) {\r\n\t\t\t\t\t\t\tif (pattern.charAt(i) === \"-\") {\r\n\t\t\t\t\t\t\t\tend = pattern.charCodeAt(i + 1);\r\n\t\t\t\t\t\t\t\twhile (++start < end) expanded.push(String.fromCharCode(start));\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tstart = pattern.charCodeAt(i);\r\n\t\t\t\t\t\t\t\texpanded.push(pattern.charAt(i));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn expanded.join(\"\");\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (opts.regex && source.match.static !== true && target.match.static !== true) { //is regex a subset\r\n\t\t\t\t\t\treturn expand(target.match.def.replace(/[[\\]]/g, \"\")).indexOf(expand(source.match.def.replace(/[[\\]]/g, \"\"))) !== -1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn source.match.def === target.match.nativeDef;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfunction staticCanMatchDefinition(source, target) {\r\n\t\t\t\t\tvar sloc = source.locator.slice(source.alternation).join(\"\"),\r\n\t\t\t\t\t\ttloc = target.locator.slice(target.alternation).join(\"\"), canMatch = sloc == tloc;\r\n\t\t\t\t\tcanMatch = canMatch && source.match.static === true && target.match.static !== true ? target.match.fn.test(source.match.def, maskset, pos, false, opts, false) : false;\r\n\r\n\t\t\t\t\treturn canMatch;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//mergelocators for retrieving the correct locator match when merging\r\n\t\t\t\tfunction setMergeLocators(targetMatch, altMatch) {\r\n\t\t\t\t\tif (altMatch === undefined || (targetMatch.alternation === altMatch.alternation &&\r\n\t\t\t\t\t\ttargetMatch.locator[targetMatch.alternation].toString().indexOf(altMatch.locator[altMatch.alternation]) === -1)) {\r\n\t\t\t\t\t\ttargetMatch.mloc = targetMatch.mloc || {};\r\n\t\t\t\t\t\tvar locNdx = targetMatch.locator[targetMatch.alternation];\r\n\t\t\t\t\t\tif (locNdx === undefined) {\r\n\t\t\t\t\t\t\ttargetMatch.alternation = undefined;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tif (typeof locNdx === \"string\") locNdx = locNdx.split(\",\")[0];\r\n\t\t\t\t\t\t\tif (targetMatch.mloc[locNdx] === undefined) targetMatch.mloc[locNdx] = targetMatch.locator.slice();\r\n\t\t\t\t\t\t\tif (altMatch !== undefined) {\r\n\t\t\t\t\t\t\t\tfor (var ndx in altMatch.mloc) {\r\n\t\t\t\t\t\t\t\t\tif (typeof ndx === \"string\") ndx = ndx.split(\",\")[0];\r\n\t\t\t\t\t\t\t\t\tif (targetMatch.mloc[ndx] === undefined) targetMatch.mloc[ndx] = altMatch.mloc[ndx];\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\ttargetMatch.locator[targetMatch.alternation] = Object.keys(targetMatch.mloc).join(\",\");\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (testPos > 500 && quantifierRecurse !== undefined) {\r\n\t\t\t\t\tthrow \"Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. \" + maskset.mask;\r\n\t\t\t\t}\r\n\t\t\t\tif (testPos === pos && match.matches === undefined) {\r\n\t\t\t\t\tmatches.push({\r\n\t\t\t\t\t\t\"match\": match,\r\n\t\t\t\t\t\t\"locator\": loopNdx.reverse(),\r\n\t\t\t\t\t\t\"cd\": cacheDependency,\r\n\t\t\t\t\t\t\"mloc\": {}\r\n\t\t\t\t\t});\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t} else if (match.matches !== undefined) {\r\n\t\t\t\t\tif (match.isGroup && quantifierRecurse !== match) { //when a group pass along to the quantifier\r\n\t\t\t\t\t\tmatch = handleMatch(maskToken.matches[$.inArray(match, maskToken.matches) + 1], loopNdx, quantifierRecurse);\r\n\t\t\t\t\t\tif (match) return true;\r\n\t\t\t\t\t} else if (match.isOptional) {\r\n\t\t\t\t\t\tvar optionalToken = match, mtchsNdx = matches.length;\r\n\t\t\t\t\t\tmatch = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse);\r\n\t\t\t\t\t\tif (match) {\r\n\t\t\t\t\t\t\t//mark optionality in matches\r\n\t\t\t\t\t\t\t$.each(matches, function (ndx, mtch) {\r\n\t\t\t\t\t\t\t\tif (ndx >= mtchsNdx) {\r\n\t\t\t\t\t\t\t\t\tmtch.match.optionality = true;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\tlatestMatch = matches[matches.length - 1].match;\r\n\t\t\t\t\t\t\tif (quantifierRecurse === undefined && isFirstMatch(latestMatch, optionalToken)) { //prevent loop see #698\r\n\t\t\t\t\t\t\t\tinsertStop = true; //insert a stop\r\n\t\t\t\t\t\t\t\ttestPos = pos; //match the position after the group\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (match.isAlternator) {\r\n\t\t\t\t\t\tvar alternateToken = match,\r\n\t\t\t\t\t\t\tmalternateMatches = [],\r\n\t\t\t\t\t\t\tmaltMatches,\r\n\t\t\t\t\t\t\tcurrentMatches = matches.slice(),\r\n\t\t\t\t\t\t\tloopNdxCnt = loopNdx.length;\r\n\t\t\t\t\t\tvar altIndex = ndxInitializer.length > 0 ? ndxInitializer.shift() : -1;\r\n\t\t\t\t\t\tif (altIndex === -1 || typeof altIndex === \"string\") {\r\n\t\t\t\t\t\t\tvar currentPos = testPos,\r\n\t\t\t\t\t\t\t\tndxInitializerClone = ndxInitializer.slice(),\r\n\t\t\t\t\t\t\t\taltIndexArr = [],\r\n\t\t\t\t\t\t\t\tamndx;\r\n\t\t\t\t\t\t\tif (typeof altIndex == \"string\") {\r\n\t\t\t\t\t\t\t\taltIndexArr = altIndex.split(\",\");\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tfor (amndx = 0; amndx < alternateToken.matches.length; amndx++) {\r\n\t\t\t\t\t\t\t\t\taltIndexArr.push(amndx.toString());\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (maskset.excludes[pos]) {\r\n\t\t\t\t\t\t\t\tvar altIndexArrClone = altIndexArr.slice();\r\n\t\t\t\t\t\t\t\tfor (var i = 0, el = maskset.excludes[pos].length; i < el; i++) {\r\n\t\t\t\t\t\t\t\t\taltIndexArr.splice(altIndexArr.indexOf(maskset.excludes[pos][i].toString()), 1);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif (altIndexArr.length === 0) { //fully alternated => reset\r\n\t\t\t\t\t\t\t\t\tmaskset.excludes[pos] = undefined;\r\n\t\t\t\t\t\t\t\t\taltIndexArr = altIndexArrClone;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (opts.keepStatic === true || (isFinite(parseInt(opts.keepStatic)) && currentPos >= opts.keepStatic)) altIndexArr = altIndexArr.slice(0, 1);\r\n\t\t\t\t\t\t\tvar unMatchedAlternation = false;\r\n\t\t\t\t\t\t\tfor (var ndx = 0; ndx < altIndexArr.length; ndx++) {\r\n\t\t\t\t\t\t\t\tamndx = parseInt(altIndexArr[ndx]);\r\n\t\t\t\t\t\t\t\tmatches = [];\r\n\t\t\t\t\t\t\t\t//set the correct ndxInitializer\r\n\t\t\t\t\t\t\t\tndxInitializer = typeof altIndex === \"string\" ? resolveNdxInitializer(testPos, amndx, loopNdxCnt) || ndxInitializerClone.slice() : ndxInitializerClone.slice();\r\n\t\t\t\t\t\t\t\tif (alternateToken.matches[amndx] && handleMatch(alternateToken.matches[amndx], [amndx].concat(loopNdx), quantifierRecurse)) {\r\n\t\t\t\t\t\t\t\t\tmatch = true;\r\n\t\t\t\t\t\t\t\t} else if (ndx === 0) {\r\n\t\t\t\t\t\t\t\t\tunMatchedAlternation = true;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tmaltMatches = matches.slice();\r\n\t\t\t\t\t\t\t\ttestPos = currentPos;\r\n\t\t\t\t\t\t\t\tmatches = [];\r\n\r\n\t\t\t\t\t\t\t\t//fuzzy merge matches\r\n\t\t\t\t\t\t\t\tfor (var ndx1 = 0; ndx1 < maltMatches.length; ndx1++) {\r\n\t\t\t\t\t\t\t\t\tvar altMatch = maltMatches[ndx1],\r\n\t\t\t\t\t\t\t\t\t\tdropMatch = false;\r\n\t\t\t\t\t\t\t\t\taltMatch.match.jit = altMatch.match.jit || unMatchedAlternation; //mark jit when there are unmatched alternations  ex: mask: \"(a|aa)\"\r\n\t\t\t\t\t\t\t\t\taltMatch.alternation = altMatch.alternation || loopNdxCnt;\r\n\t\t\t\t\t\t\t\t\tsetMergeLocators(altMatch);\r\n\t\t\t\t\t\t\t\t\tfor (var ndx2 = 0; ndx2 < malternateMatches.length; ndx2++) {\r\n\t\t\t\t\t\t\t\t\t\tvar altMatch2 = malternateMatches[ndx2];\r\n\t\t\t\t\t\t\t\t\t\tif (typeof altIndex !== \"string\" || (altMatch.alternation !== undefined && $.inArray(altMatch.locator[altMatch.alternation].toString(), altIndexArr) !== -1)) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (altMatch.match.nativeDef === altMatch2.match.nativeDef) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tdropMatch = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\tsetMergeLocators(altMatch2, altMatch);\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t} else if (isSubsetOf(altMatch, altMatch2)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (setMergeLocators(altMatch, altMatch2)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tdropMatch = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tmalternateMatches.splice(malternateMatches.indexOf(altMatch2), 0, altMatch);\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t} else if (isSubsetOf(altMatch2, altMatch)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tsetMergeLocators(altMatch2, altMatch);\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t} else if (staticCanMatchDefinition(altMatch, altMatch2)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (setMergeLocators(altMatch, altMatch2)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//insert match above general match\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tdropMatch = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tmalternateMatches.splice(malternateMatches.indexOf(altMatch2), 0, altMatch);\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif (!dropMatch) {\r\n\t\t\t\t\t\t\t\t\t\tmalternateMatches.push(altMatch);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tmatches = currentMatches.concat(malternateMatches);\r\n\t\t\t\t\t\t\ttestPos = pos;\r\n\t\t\t\t\t\t\tinsertStop = matches.length > 0; //insert a stopelemnt when there is an alternate - needed for non-greedy option\r\n\t\t\t\t\t\t\tmatch = malternateMatches.length > 0; //set correct match state\r\n\r\n\t\t\t\t\t\t\t//cloneback\r\n\t\t\t\t\t\t\tndxInitializer = ndxInitializerClone.slice();\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tmatch = handleMatch(alternateToken.matches[altIndex] || maskToken.matches[altIndex], [altIndex].concat(loopNdx), quantifierRecurse);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (match) return true;\r\n\t\t\t\t\t} else if (match.isQuantifier && quantifierRecurse !== maskToken.matches[$.inArray(match, maskToken.matches) - 1]) {\r\n\t\t\t\t\t\tvar qt = match;\r\n\t\t\t\t\t\tfor (var qndx = (ndxInitializer.length > 0) ? ndxInitializer.shift() : 0; (qndx < (isNaN(qt.quantifier.max) ? qndx + 1 : qt.quantifier.max)) && testPos <= pos; qndx++) {\r\n\t\t\t\t\t\t\tvar tokenGroup = maskToken.matches[$.inArray(qt, maskToken.matches) - 1];\r\n\t\t\t\t\t\t\tmatch = handleMatch(tokenGroup, [qndx].concat(loopNdx), tokenGroup); //set the tokenGroup as quantifierRecurse marker\r\n\t\t\t\t\t\t\tif (match) {\r\n\t\t\t\t\t\t\t\t//get latest match\r\n\t\t\t\t\t\t\t\tlatestMatch = matches[matches.length - 1].match;\r\n\t\t\t\t\t\t\t\t//mark optionality\r\n\t\t\t\t\t\t\t\t//TODO FIX RECURSIVE QUANTIFIERS\r\n\t\t\t\t\t\t\t\tlatestMatch.optionalQuantifier = qndx >= qt.quantifier.min;\r\n\t\t\t\t\t\t\t\t// console.log(pos + \" \" + qt.quantifier.min + \" \" + latestMatch.optionalQuantifier);\r\n\t\t\t\t\t\t\t\tlatestMatch.jit = (qndx || 1) * tokenGroup.matches.indexOf(latestMatch) >= qt.quantifier.jit;\r\n\t\t\t\t\t\t\t\tif (latestMatch.optionalQuantifier && isFirstMatch(latestMatch, tokenGroup)) {\r\n\t\t\t\t\t\t\t\t\tinsertStop = true;\r\n\t\t\t\t\t\t\t\t\ttestPos = pos; //match the position after the group\r\n\t\t\t\t\t\t\t\t\tbreak; //stop quantifierloop && search for next possible match\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif (latestMatch.jit /*&& !latestMatch.optionalQuantifier*/) {\r\n\t\t\t\t\t\t\t\t\t//always set jitOffset, isvalid checks when to apply\r\n\t\t\t\t\t\t\t\t\tmaskset.jitOffset[pos] = tokenGroup.matches.length - tokenGroup.matches.indexOf(latestMatch);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tmatch = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse);\r\n\t\t\t\t\t\tif (match) return true;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttestPos++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t//the offset is set in the quantifierloop when git masking is used\r\n\t\t\tfor (var tndx = (ndxInitializer.length > 0 ? ndxInitializer.shift() : 0); tndx < maskToken.matches.length; tndx++) {\r\n\t\t\t\tif (maskToken.matches[tndx].isQuantifier !== true) {\r\n\t\t\t\t\tvar match = handleMatch(maskToken.matches[tndx], [tndx].concat(loopNdx), quantifierRecurse);\r\n\t\t\t\t\tif (match && testPos === pos) {\r\n\t\t\t\t\t\treturn match;\r\n\t\t\t\t\t} else if (testPos > pos) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction mergeLocators(pos, tests) {\r\n\t\t\tvar locator = [];\r\n\t\t\tif (!$.isArray(tests)) tests = [tests];\r\n\t\t\tif (tests.length > 0) {\r\n\t\t\t\tif (tests[0].alternation === undefined || opts.keepStatic === true) {\r\n\t\t\t\t\tlocator = determineTestTemplate(pos, tests.slice()).locator.slice();\r\n\t\t\t\t\tif (locator.length === 0) locator = tests[0].locator.slice();\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$.each(tests, function (ndx, tst) {\r\n\t\t\t\t\t\tif (tst.def !== \"\") {\r\n\t\t\t\t\t\t\tif (locator.length === 0) {\r\n\t\t\t\t\t\t\t\tlocator = tst.locator.slice();\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tfor (var i = 0; i < locator.length; i++) {\r\n\t\t\t\t\t\t\t\t\tif (tst.locator[i] && locator[i].toString().indexOf(tst.locator[i]) === -1) {\r\n\t\t\t\t\t\t\t\t\t\tlocator[i] += \",\" + tst.locator[i];\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn locator;\r\n\t\t}\r\n\r\n\t\tif (pos > -1 && (maxLength === undefined || pos < maxLength)) {\r\n\t\t\tif (ndxIntlzr === undefined) { //determine index initializer\r\n\t\t\t\tvar previousPos = pos - 1,\r\n\t\t\t\t\ttest;\r\n\t\t\t\twhile ((test = maskset.validPositions[previousPos] || maskset.tests[previousPos]) === undefined && previousPos > -1) {\r\n\t\t\t\t\tpreviousPos--;\r\n\t\t\t\t}\r\n\t\t\t\tif (test !== undefined && previousPos > -1) {\r\n\t\t\t\t\tndxInitializer = mergeLocators(previousPos, test);\r\n\t\t\t\t\tcacheDependency = ndxInitializer.join(\"\");\r\n\t\t\t\t\ttestPos = previousPos;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (maskset.tests[pos] && maskset.tests[pos][0].cd === cacheDependency) { //cacheDependency is set on all tests, just check on the first\r\n\t\t\t\treturn maskset.tests[pos];\r\n\t\t\t}\r\n\t\t\tfor (var mtndx = ndxInitializer.shift(); mtndx < maskTokens.length; mtndx++) {\r\n\t\t\t\tvar match = resolveTestFromToken(maskTokens[mtndx], ndxInitializer, [mtndx]);\r\n\t\t\t\tif ((match && testPos === pos) || testPos > pos) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (matches.length === 0 || insertStop) {\r\n\t\t\tmatches.push({\r\n\t\t\t\tmatch: {\r\n\t\t\t\t\tfn: null,\r\n\t\t\t\t\tstatic: true,\r\n\t\t\t\t\toptionality: false,\r\n\t\t\t\t\tcasing: null,\r\n\t\t\t\t\tdef: \"\",\r\n\t\t\t\t\tplaceholder: \"\"\r\n\t\t\t\t},\r\n\t\t\t\tlocator: [],\r\n\t\t\t\tmloc: {},\r\n\t\t\t\tcd: cacheDependency\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif (ndxIntlzr !== undefined && maskset.tests[pos]) { //prioritize full tests for caching\r\n\t\t\treturn $.extend(true, [], matches);\r\n\t\t}\r\n\t\tmaskset.tests[pos] = $.extend(true, [], matches); //set a clone to prevent overwriting some props\r\n\t\t// console.log(pos + \" - \" + JSON.stringify(matches));\r\n\t\treturn maskset.tests[pos];\r\n\t}\r\n\r\n\tfunction getBufferTemplate() {\r\n\t\tif (maskset._buffer === undefined) {\r\n\t\t\t//generate template\r\n\t\t\tmaskset._buffer = getMaskTemplate(false, 1);\r\n\t\t\tif (maskset.buffer === undefined) maskset.buffer = maskset._buffer.slice();\r\n\t\t}\r\n\t\treturn maskset._buffer;\r\n\t}\r\n\r\n\tfunction getBuffer(noCache) {\r\n\t\tif (maskset.buffer === undefined || noCache === true) {\r\n\t\t\tmaskset.buffer = getMaskTemplate(true, getLastValidPosition(), true);\r\n\t\t\tif (maskset._buffer === undefined) maskset._buffer = maskset.buffer.slice();\r\n\t\t}\r\n\t\treturn maskset.buffer;\r\n\t}\r\n\r\n\tfunction refreshFromBuffer(start, end, buffer) {\r\n\t\tvar i, p;\r\n\t\tif (start === true) {\r\n\t\t\tresetMaskSet();\r\n\t\t\tmaskset.tests = {}; //refresh tests after possible alternating\r\n\t\t\tstart = 0;\r\n\t\t\tend = buffer.length;\r\n\t\t} else {\r\n\t\t\tfor (i = start; i < end; i++) {\r\n\t\t\t\tdelete maskset.validPositions[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\tp = start;\r\n\t\tfor (i = start; i < end; i++) {\r\n\t\t\t// resetMaskSet(true); //prevents clobber from the buffer\r\n\t\t\tif (buffer[i] !== opts.skipOptionalPartCharacter) {\r\n\t\t\t\tvar valResult = isValid(p, buffer[i], opts.negationSymbol ? [i] !== opts.negationSymbol.front : true, opts.negationSymbol ? [i] !== opts.negationSymbol.front : true);  //hackery for + validator (numeric alias)\r\n\t\t\t\tif (valResult !== false) {\r\n\t\t\t\t\t// resetMaskSet(true);\r\n\t\t\t\t\tp = valResult.caret !== undefined ? valResult.caret : valResult.pos + 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction casing(elem, test, pos) {\r\n\t\tswitch (opts.casing || test.casing) {\r\n\t\t\tcase \"upper\":\r\n\t\t\t\telem = elem.toUpperCase();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"lower\":\r\n\t\t\t\telem = elem.toLowerCase();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"title\":\r\n\t\t\t\tvar posBefore = maskset.validPositions[pos - 1];\r\n\t\t\t\tif (pos === 0 || posBefore && posBefore.input === String.fromCharCode(Inputmask.keyCode.SPACE)) {\r\n\t\t\t\t\telem = elem.toUpperCase();\r\n\t\t\t\t} else {\r\n\t\t\t\t\telem = elem.toLowerCase();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tif ($.isFunction(opts.casing)) {\r\n\t\t\t\t\tvar args = Array.prototype.slice.call(arguments);\r\n\t\t\t\t\targs.push(maskset.validPositions);\r\n\t\t\t\t\telem = opts.casing.apply(this, args);\r\n\t\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn elem;\r\n\t}\r\n\r\n\tfunction checkAlternationMatch(altArr1, altArr2, na) {\r\n\t\tvar altArrC = opts.greedy ? altArr2 : altArr2.slice(0, 1),\r\n\t\t\tisMatch = false,\r\n\t\t\tnaArr = na !== undefined ? na.split(\",\") : [],\r\n\t\t\tnaNdx;\r\n\r\n\t\t//remove no alternate indexes from alternation array\r\n\t\tfor (var i = 0; i < naArr.length; i++) {\r\n\t\t\tif ((naNdx = altArr1.indexOf(naArr[i])) !== -1) {\r\n\t\t\t\taltArr1.splice(naNdx, 1);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (var alndx = 0; alndx < altArr1.length; alndx++) {\r\n\t\t\tif ($.inArray(altArr1[alndx], altArrC) !== -1) {\r\n\t\t\t\tisMatch = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn isMatch;\r\n\t}\r\n\r\n\tfunction alternate(pos, c, strict, fromIsValid, rAltPos) { //pos == true => generalize\r\n\t\tvar validPsClone = $.extend(true, {}, maskset.validPositions),\r\n\t\t\tlastAlt,\r\n\t\t\talternation,\r\n\t\t\tisValidRslt = false, returnRslt = false,\r\n\t\t\taltPos, prevAltPos, i, validPos,\r\n\t\t\tdecisionPos,\r\n\t\t\tlAltPos = rAltPos !== undefined ? rAltPos : getLastValidPosition();\r\n\r\n\t\tfunction insertPosition(insert) {\r\n\t\t\tif (insert) {\r\n\t\t\t\tif (isValidRslt && c !== undefined) {\r\n\t\t\t\t\tvar targetLvp = getLastValidPosition(pos) + 1;\r\n\t\t\t\t\tfor (i = decisionPos; i < getLastValidPosition() + 1; i++) {\r\n\t\t\t\t\t\tvalidPos = maskset.validPositions[i];\r\n\t\t\t\t\t\tif ((validPos === undefined || validPos.match.static == true) && i < (pos + posOffset)) {\r\n\t\t\t\t\t\t\tposOffset++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpos = pos + posOffset;\r\n\t\t\t\t\tisValidRslt = returnRslt = isValid(pos > targetLvp ? targetLvp : pos, c, strict, fromIsValid, true);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (lAltPos === -1 && rAltPos === undefined) { //do not recurse when already paste the beginning\r\n\t\t\tlastAlt = 0;\r\n\t\t\tprevAltPos = getTest(lastAlt);\r\n\t\t\talternation = prevAltPos.alternation;\r\n\t\t} else {\r\n\t\t\t//find last modified alternation\r\n\t\t\tfor (; lAltPos >= 0; lAltPos--) {\r\n\t\t\t\taltPos = maskset.validPositions[lAltPos];\r\n\t\t\t\tif (altPos && altPos.alternation !== undefined) {\r\n\t\t\t\t\tif (prevAltPos && prevAltPos.locator[altPos.alternation] !== altPos.locator[altPos.alternation]) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlastAlt = lAltPos;\r\n\t\t\t\t\talternation = maskset.validPositions[lastAlt].alternation;\r\n\t\t\t\t\tprevAltPos = altPos;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (alternation !== undefined) {\r\n\t\t\tdecisionPos = parseInt(lastAlt);\r\n\t\t\tmaskset.excludes[decisionPos] = maskset.excludes[decisionPos] || [];\r\n\t\t\tif (pos !== true) { //generalize\r\n\t\t\t\tmaskset.excludes[decisionPos].push(getDecisionTaker(prevAltPos));\r\n\t\t\t}\r\n\r\n\t\t\tvar validInputsClone = [], staticInputsBeforePos = 0;\r\n\t\t\tfor (i = decisionPos; i < getLastValidPosition(undefined, true) + 1; i++) {\r\n\t\t\t\tvalidPos = maskset.validPositions[i];\r\n\t\t\t\tif (validPos && validPos.generatedInput !== true /*&& /[0-9a-bA-Z]/.test(validPos.input)*/) {\r\n\t\t\t\t\tvalidInputsClone.push(validPos.input);\r\n\t\t\t\t} else if (i < pos) staticInputsBeforePos++;\r\n\t\t\t\tdelete maskset.validPositions[i];\r\n\t\t\t}\r\n\r\n\t\t\twhile (maskset.excludes[decisionPos] && maskset.excludes[decisionPos].length < 10) {\r\n\t\t\t\tvar posOffset = staticInputsBeforePos * -1, //negate\r\n\t\t\t\t\tvalidInputs = validInputsClone.slice();\r\n\t\t\t\tmaskset.tests[decisionPos] = undefined; //clear decisionPos\r\n\t\t\t\tresetMaskSet(true); //clear getbuffer\r\n\t\t\t\tisValidRslt = true;\r\n\t\t\t\tinsertPosition(pos === 0);\r\n\t\t\t\twhile (validInputs.length > 0) {\r\n\t\t\t\t\tvar input = validInputs.shift();\r\n\t\t\t\t\tif (!(isValidRslt = isValid(isValidRslt.caret || (getLastValidPosition(undefined, true) + 1), input, false, fromIsValid, true))) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tinsertPosition(pos > 0);\r\n\t\t\t\tif (!isValidRslt) {\r\n\t\t\t\t\tresetMaskSet();\r\n\t\t\t\t\tprevAltPos = getTest(decisionPos);  //get the current decisionPos to exclude ~ needs to be before restoring the initial validation\r\n\t\t\t\t\t//reset & revert\r\n\t\t\t\t\tmaskset.validPositions = $.extend(true, {}, validPsClone);\r\n\t\t\t\t\tif (maskset.excludes[decisionPos]) {\r\n\t\t\t\t\t\tvar decisionTaker = getDecisionTaker(prevAltPos);\r\n\t\t\t\t\t\tif (maskset.excludes[decisionPos].indexOf(decisionTaker) !== -1) {\r\n\t\t\t\t\t\t\tisValidRslt = alternate(pos, c, strict, fromIsValid, decisionPos - 1);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tmaskset.excludes[decisionPos].push(decisionTaker);\r\n\t\t\t\t\t\tfor (i = decisionPos; i < getLastValidPosition(undefined, true) + 1; i++) delete maskset.validPositions[i];\r\n\t\t\t\t\t} else { //latest alternation\r\n\t\t\t\t\t\tisValidRslt = alternate(pos, c, strict, fromIsValid, decisionPos - 1);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t//reset alternation excludes\r\n\t\tmaskset.excludes[decisionPos] = undefined;\r\n\t\treturn returnRslt;\r\n\t}\r\n\r\n\tfunction isValid(pos, c, strict, fromIsValid, fromAlternate, validateOnly) { //strict true ~ no correction or autofill\r\n\t\tfunction isSelection(posObj) {\r\n\t\t\treturn isRTL ? (posObj.begin - posObj.end) > 1 || ((posObj.begin - posObj.end) === 1) :\r\n\t\t\t\t(posObj.end - posObj.begin) > 1 || ((posObj.end - posObj.begin) === 1);\r\n\t\t}\r\n\r\n\t\tstrict = strict === true; //always set a value to strict to prevent possible strange behavior in the extensions\r\n\r\n\t\tvar maskPos = pos;\r\n\t\tif (pos.begin !== undefined) { //position was a position object - used to handle a delete by typing over a selection\r\n\t\t\tmaskPos = isRTL ? pos.end : pos.begin;\r\n\t\t}\r\n\r\n\t\tfunction processCommandObject(commandObj) {\r\n\t\t\tif (commandObj !== undefined) {\r\n\t\t\t\tif (commandObj.remove !== undefined) { //remove position(s)\r\n\t\t\t\t\tif (!$.isArray(commandObj.remove)) commandObj.remove = [commandObj.remove];\r\n\t\t\t\t\t$.each(commandObj.remove.sort(function (a, b) {\r\n\t\t\t\t\t\treturn b.pos - a.pos;\r\n\t\t\t\t\t}), function (ndx, lmnt) {\r\n\t\t\t\t\t\trevalidateMask({begin: lmnt, end: lmnt + 1});\r\n\t\t\t\t\t});\r\n\t\t\t\t\tcommandObj.remove = undefined;\r\n\t\t\t\t}\r\n\t\t\t\tif (commandObj.insert !== undefined) { //insert position(s)\r\n\t\t\t\t\tif (!$.isArray(commandObj.insert)) commandObj.insert = [commandObj.insert];\r\n\t\t\t\t\t$.each(commandObj.insert.sort(function (a, b) {\r\n\t\t\t\t\t\treturn a.pos - b.pos;\r\n\t\t\t\t\t}), function (ndx, lmnt) {\r\n\t\t\t\t\t\tisValid(lmnt.pos, lmnt.c, lmnt.strict !== undefined ? lmnt.strict : true, lmnt.fromIsValid !== undefined ? lmnt.fromIsValid : fromIsValid);\r\n\t\t\t\t\t});\r\n\t\t\t\t\tcommandObj.insert = undefined;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (commandObj.refreshFromBuffer && commandObj.buffer) {\r\n\t\t\t\t\tvar refresh = commandObj.refreshFromBuffer;\r\n\t\t\t\t\trefreshFromBuffer(refresh === true ? refresh : refresh.start, refresh.end, commandObj.buffer);\r\n\t\t\t\t\tcommandObj.refreshFromBuffer = undefined;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (commandObj.rewritePosition !== undefined) {\r\n\t\t\t\t\tmaskPos = commandObj.rewritePosition;\r\n\t\t\t\t\tcommandObj = true;\r\n\t\t\t\t\tcommandObj.rewritePosition = undefined;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn commandObj;\r\n\t\t}\r\n\r\n\t\tfunction _isValid(position, c, strict) {\r\n\t\t\tvar rslt = false;\r\n\r\n\t\t\t$.each(getTests(position), function (ndx, tst) {\r\n\t\t\t\tvar test = tst.match;\r\n\t\t\t\t//make sure the buffer is set and correct\r\n\t\t\t\tgetBuffer(true);\r\n\t\t\t\t//return is false or a json object => { pos: ??, c: ??} or true\r\n\t\t\t\trslt = test.fn != null ?\r\n\t\t\t\t\ttest.fn.test(c, maskset, position, strict, opts, isSelection(pos)) : (c === test.def || c === opts.skipOptionalPartCharacter) && test.def !== \"\" ? //non mask\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tc: getPlaceholder(position, test, true) || test.def,\r\n\t\t\t\t\t\t\tpos: position\r\n\t\t\t\t\t\t} : false;\r\n\r\n\t\t\t\tif (rslt !== false) {\r\n\t\t\t\t\tvar elem = rslt.c !== undefined ? rslt.c : c, validatedPos = position;\r\n\t\t\t\t\telem = (elem === opts.skipOptionalPartCharacter && test.static === true) ?\r\n\t\t\t\t\t\t(getPlaceholder(position, test, true) || test.def) : elem;\r\n\r\n\t\t\t\t\trslt = processCommandObject(rslt);\r\n\r\n\t\t\t\t\tif (rslt !== true && rslt.pos !== undefined && rslt.pos !== position) { //their is a position offset\r\n\t\t\t\t\t\tvalidatedPos = rslt.pos;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (rslt !== true && rslt.pos === undefined && rslt.c === undefined) {\r\n\t\t\t\t\t\treturn false; //breakout if nothing to insert\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!revalidateMask(pos, $.extend({}, tst, {\r\n\t\t\t\t\t\t\"input\": casing(elem, test, validatedPos)\r\n\t\t\t\t\t}), fromIsValid, validatedPos)) {\r\n\t\t\t\t\t\trslt = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn false; //break from $.each\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\treturn rslt;\r\n\t\t}\r\n\r\n\t\tvar result = true,\r\n\t\t\tpositionsClone = $.extend(true, {}, maskset.validPositions); //clone the currentPositions\r\n\r\n\t\tif ($.isFunction(opts.preValidation) && !strict && fromIsValid !== true && validateOnly !== true && fromAlternate !== true) {\r\n\t\t\tresult = opts.preValidation(getBuffer(), maskPos, c, isSelection(pos), opts, maskset);\r\n\t\t\tresult = processCommandObject(result);\r\n\t\t}\r\n\t\tif (result === true) { //preValidation result\r\n\t\t\tif (maxLength === undefined || maskPos < maxLength) {\r\n\t\t\t\tresult = _isValid(maskPos, c, strict);\r\n\t\t\t\tif ((!strict || fromIsValid === true) && result === false && validateOnly !== true) {\r\n\t\t\t\t\tvar currentPosValid = maskset.validPositions[maskPos];\r\n\t\t\t\t\tif (currentPosValid && currentPosValid.match.static === true && (currentPosValid.match.def === c || c === opts.skipOptionalPartCharacter)) {\r\n\t\t\t\t\t\tresult = {\r\n\t\t\t\t\t\t\t\"caret\": seekNext(maskPos)\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (opts.insertMode || maskset.validPositions[seekNext(maskPos)] === undefined) { //does the input match on a further position?\r\n\t\t\t\t\t\t\tvar skip = false;\r\n\t\t\t\t\t\t\tif (maskset.jitOffset[maskPos] && maskset.validPositions[seekNext(maskPos)] === undefined) {\r\n\t\t\t\t\t\t\t\tresult = isValid(maskPos + maskset.jitOffset[maskPos], c, true);\r\n\t\t\t\t\t\t\t\tif (result !== false) {\r\n\t\t\t\t\t\t\t\t\tif (fromAlternate !== true) result.caret = maskPos;\r\n\t\t\t\t\t\t\t\t\tskip = true;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (!skip && !isMask(maskPos, true)) {\r\n\t\t\t\t\t\t\t\tfor (var nPos = maskPos + 1, snPos = seekNext(maskPos); nPos <= snPos; nPos++) {\r\n\t\t\t\t\t\t\t\t\t// if (!isMask(nPos, true)) {\r\n\t\t\t\t\t\t\t\t\t// \tcontinue;\r\n\t\t\t\t\t\t\t\t\t// }\r\n\t\t\t\t\t\t\t\t\tresult = _isValid(nPos, c, strict);\r\n\t\t\t\t\t\t\t\t\tif (result !== false) {\r\n\t\t\t\t\t\t\t\t\t\tresult = trackbackPositions(maskPos, result.pos !== undefined ? result.pos : nPos) || result;\r\n\t\t\t\t\t\t\t\t\t\tmaskPos = nPos;\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (result === false && opts.keepStatic !== false && (opts.regex == null || isComplete(getBuffer())) && !strict && fromAlternate !== true) { //try fuzzy alternator logic\r\n\t\t\t\tresult = alternate(maskPos, c, strict, fromIsValid);\r\n\t\t\t}\r\n\t\t\tif (result === true) {\r\n\t\t\t\tresult = {\r\n\t\t\t\t\t\"pos\": maskPos\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\t\tif ($.isFunction(opts.postValidation) && result !== false && !strict && fromIsValid !== true && validateOnly !== true) {\r\n\t\t\tvar postResult = opts.postValidation(getBuffer(true), pos.begin !== undefined ? (isRTL ? pos.end : pos.begin) : pos, result, opts);\r\n\t\t\tif (postResult !== undefined) {\r\n\t\t\t\tresult = postResult === true ? result : postResult;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (result && result.pos === undefined) {\r\n\t\t\tresult.pos = maskPos;\r\n\t\t}\r\n\r\n\t\tif (result === false || validateOnly === true) {\r\n\t\t\tresetMaskSet(true);\r\n\t\t\tmaskset.validPositions = $.extend(true, {}, positionsClone); //revert validation changes\r\n\t\t} else {\r\n\t\t\ttrackbackPositions(undefined, maskPos, true);\r\n\t\t}\r\n\r\n\t\tvar endResult = processCommandObject(result);\r\n\t\t// console.log(\"returned result \" + JSON.stringify(endResult));\r\n\t\treturn endResult;\r\n\t}\r\n\r\n\t//fill in best positions according the current input\r\n\tfunction trackbackPositions(originalPos, newPos, fillOnly) {\r\n\t\t// console.log(\"trackbackPositions \" + originalPos + \" \" + newPos);\r\n\t\tif (originalPos === undefined) {\r\n\t\t\t//find previous valid\r\n\t\t\tfor (originalPos = newPos - 1; originalPos > 0; originalPos--) {\r\n\t\t\t\tif (maskset.validPositions[originalPos]) break;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (var ps = originalPos; ps < newPos; ps++) {\r\n\t\t\tif (maskset.validPositions[ps] === undefined && !isMask(ps, true)) {\r\n\t\t\t\tvar vp = ps == 0 ? getTest(ps) : maskset.validPositions[ps - 1];\r\n\t\t\t\tif (vp) {\r\n\t\t\t\t\tvar tests = getTests(ps).slice();\r\n\t\t\t\t\tif (tests[tests.length - 1].match.def === \"\") tests.pop();\r\n\t\t\t\t\tvar bestMatch = determineTestTemplate(ps, tests), np;\r\n\t\t\t\t\tif (bestMatch && (bestMatch.match.jit !== true || (bestMatch.match.newBlockMarker === \"master\" && (np = maskset.validPositions[ps + 1]) && np.match.optionalQuantifier === true))) {\r\n\t\t\t\t\t\tbestMatch = $.extend({}, bestMatch, {\r\n\t\t\t\t\t\t\t\"input\": getPlaceholder(ps, bestMatch.match, true) || bestMatch.match.def\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tbestMatch.generatedInput = true;\r\n\t\t\t\t\t\trevalidateMask(ps, bestMatch, true);\r\n\r\n\t\t\t\t\t\tif (fillOnly !== true) {\r\n\t\t\t\t\t\t\t//revalidate the new position to update the locator value\r\n\t\t\t\t\t\t\tvar cvpInput = maskset.validPositions[newPos].input;\r\n\t\t\t\t\t\t\tmaskset.validPositions[newPos] = undefined;\r\n\t\t\t\t\t\t\treturn isValid(newPos, cvpInput, true, true);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction revalidateMask(pos, validTest, fromIsValid, validatedPos) {\r\n\t\tfunction IsEnclosedStatic(pos, valids, selection) {\r\n\t\t\tvar posMatch = valids[pos];\r\n\t\t\tif (posMatch !== undefined && ((posMatch.match.static === true && posMatch.match.optionality !== true) || posMatch.input === opts.radixPoint)) {\r\n\t\t\t\tvar prevMatch = selection.begin <= pos - 1 ? valids[pos - 1] && valids[pos - 1].match.static === true && valids[pos - 1] : valids[pos - 1],\r\n\t\t\t\t\tnextMatch = selection.end > pos + 1 ? valids[pos + 1] && valids[pos + 1].match.static === true && valids[pos + 1] : valids[pos + 1];\r\n\t\t\t\treturn prevMatch && nextMatch;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tvar begin = pos.begin !== undefined ? pos.begin : pos, end = pos.end !== undefined ? pos.end : pos;\r\n\t\tif (pos.begin > pos.end) {\r\n\t\t\tbegin = pos.end;\r\n\t\t\tend = pos.begin;\r\n\t\t}\r\n\t\tvalidatedPos = validatedPos !== undefined ? validatedPos : begin;\r\n\t\tif (begin !== end || (opts.insertMode && maskset.validPositions[validatedPos] !== undefined && fromIsValid === undefined)) {\r\n\t\t\t//reposition & revalidate others\r\n\t\t\tvar positionsClone = $.extend(true, {}, maskset.validPositions),\r\n\t\t\t\tlvp = getLastValidPosition(undefined, true),\r\n\t\t\t\ti;\r\n\t\t\tmaskset.p = begin; //needed for alternated position after overtype selection\r\n\r\n\t\t\tfor (i = lvp; i >= begin; i--) {\r\n\t\t\t\tdelete maskset.validPositions[i];\r\n\t\t\t\tif (validTest === undefined) delete maskset.tests[i + 1];\r\n\t\t\t}\r\n\r\n\t\t\tvar valid = true, j = validatedPos,\r\n\t\t\t\tneedsValidation = false, posMatch = j;\r\n\t\t\ti = j;\r\n\r\n\t\t\tif (validTest) {\r\n\t\t\t\tmaskset.validPositions[validatedPos] = $.extend(true, {}, validTest);\r\n\t\t\t\tposMatch++;\r\n\t\t\t\tj++;\r\n\t\t\t\tif (begin < end) i++; //if selection and entry move start by one\r\n\t\t\t}\r\n\t\t\tfor (; i <= lvp; i++) {\r\n\t\t\t\tvar t = positionsClone[i];\r\n\t\t\t\tif (t !== undefined &&\r\n\t\t\t\t\t(i >= end || (i >= begin && t.generatedInput !== true && IsEnclosedStatic(i, positionsClone, {\r\n\t\t\t\t\t\tbegin: begin,\r\n\t\t\t\t\t\tend: end\r\n\t\t\t\t\t})))) {\r\n\t\t\t\t\twhile (getTest(posMatch).match.def !== \"\") { //loop needed to match further positions\r\n\t\t\t\t\t\tif (needsValidation === false && positionsClone[posMatch] && positionsClone[posMatch].match.nativeDef === t.match.nativeDef) { //obvious match\r\n\t\t\t\t\t\t\tmaskset.validPositions[posMatch] = $.extend(true, {}, positionsClone[posMatch]);\r\n\t\t\t\t\t\t\tmaskset.validPositions[posMatch].input = t.input;\r\n\t\t\t\t\t\t\ttrackbackPositions(undefined, posMatch, true);\r\n\t\t\t\t\t\t\tj = posMatch + 1;\r\n\t\t\t\t\t\t\tvalid = true;\r\n\t\t\t\t\t\t\t//we still need some hackery for the + validator (numeric alias)\r\n\t\t\t\t\t\t} else if (opts.shiftPositions && (positionCanMatchDefinition(posMatch, t.match.def) || t.match.def === \"+\")) { //validated match\r\n\t\t\t\t\t\t\tif (t.match.def === \"+\") getBuffer(true);\r\n\t\t\t\t\t\t\tvar result = isValid(posMatch, t.input, t.match.def !== \"+\", t.match.def !== \"+\");\r\n\t\t\t\t\t\t\tvalid = result !== false;\r\n\t\t\t\t\t\t\t// console.log(\"match \" + posMatch + \" \" + t.input + \" \" + JSON.stringify(result));\r\n\t\t\t\t\t\t\t// j = (result.caret || result.insert) ? getLastValidPosition() : (result.pos || posMatch) + 1;\r\n\t\t\t\t\t\t\tj = (result.pos || posMatch) + 1;\r\n\t\t\t\t\t\t\tneedsValidation = true;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tvalid = t.generatedInput === true /*|| (t.input === opts.radixPoint && opts.numericInput === true)*/;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (valid) break;\r\n\t\t\t\t\t\tif (!valid && posMatch > end && isMask(posMatch, true) && (t.match.static !== true || posMatch > maskset.maskLength)) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tposMatch++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (getTest(posMatch).match.def == \"\") {\r\n\t\t\t\t\t\tvalid = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//restore position\r\n\t\t\t\t\tposMatch = j;\r\n\t\t\t\t}\r\n\t\t\t\tif (!valid) break;\r\n\t\t\t}\r\n\r\n\t\t\tif (!valid) {\r\n\t\t\t\tmaskset.validPositions = $.extend(true, {}, positionsClone);\r\n\t\t\t\tresetMaskSet(true);\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t} else if (validTest) {\r\n\t\t\tmaskset.validPositions[validatedPos] = $.extend(true, {}, validTest);\r\n\t\t}\r\n\r\n\t\tresetMaskSet(true);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction isMask(pos, strict) {\r\n\t\tvar test = getTestTemplate(pos).match;\r\n\t\tif (test.def === \"\") test = getTest(pos).match;\r\n\r\n\t\tif (test.static != true) {\r\n\t\t\treturn test.fn;\r\n\t\t}\r\n\t\tif (strict !== true && pos > -1) {\r\n\t\t\tvar tests = getTests(pos);\r\n\t\t\treturn tests.length > 1 + (tests[tests.length - 1].match.def === \"\" ? 1 : 0);\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tfunction seekNext(pos, newBlock) {\r\n\t\tvar position = pos + 1;\r\n\t\twhile (getTest(position).match.def !== \"\" &&\r\n\t\t((newBlock === true && (getTest(position).match.newBlockMarker !== true || !isMask(position))) ||\r\n\t\t\t(newBlock !== true && !isMask(position)))) {\r\n\t\t\tposition++;\r\n\t\t}\r\n\t\treturn position;\r\n\t}\r\n\r\n\tfunction seekPrevious(pos, newBlock) {\r\n\t\tvar position = pos,\r\n\t\t\ttests;\r\n\t\tif (position <= 0) return 0;\r\n\r\n\t\twhile (--position > 0 &&\r\n\t\t((newBlock === true && getTest(position).match.newBlockMarker !== true) ||\r\n\t\t\t(newBlock !== true && !isMask(position) &&\r\n\t\t\t\t// eslint-disable-next-line no-empty\r\n\t\t\t\t(tests = getTests(position), tests.length < 2 || (tests.length === 2 && tests[1].match.def === \"\"))))) {\r\n\t\t}\r\n\t\treturn position;\r\n\t}\r\n\r\n\tfunction writeBuffer(input, buffer, caretPos, event, triggerEvents) {\r\n\t\tif (event && $.isFunction(opts.onBeforeWrite)) {\r\n\t\t\t//    buffer = buffer.slice(); //prevent uncontrolled manipulation of the internal buffer\r\n\t\t\tvar result = opts.onBeforeWrite.call(inputmask, event, buffer, caretPos, opts);\r\n\t\t\tif (result) {\r\n\t\t\t\tif (result.refreshFromBuffer) {\r\n\t\t\t\t\tvar refresh = result.refreshFromBuffer;\r\n\t\t\t\t\trefreshFromBuffer(refresh === true ? refresh : refresh.start, refresh.end, result.buffer || buffer);\r\n\t\t\t\t\tbuffer = getBuffer(true);\r\n\t\t\t\t}\r\n\t\t\t\tif (caretPos !== undefined) caretPos = result.caret !== undefined ? result.caret : caretPos;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (input !== undefined) {\r\n\t\t\tinput.inputmask._valueSet(buffer.join(\"\"));\r\n\t\t\tif (caretPos !== undefined && (event === undefined || event.type !== \"blur\")) {\r\n\t\t\t\tcaret(input, caretPos);\r\n\t\t\t} else {\r\n\t\t\t\trenderColorMask(input, caretPos, buffer.length === 0);\r\n\t\t\t}\r\n\t\t\tif (triggerEvents === true) {\r\n\t\t\t\tvar $input = $(input), nptVal = input.inputmask._valueGet();\r\n\t\t\t\tskipInputEvent = true;\r\n\t\t\t\t$input.trigger(\"input\");\r\n\t\t\t\tsetTimeout(function () { //timeout needed for IE\r\n\t\t\t\t\tif (nptVal === getBufferTemplate().join(\"\")) {\r\n\t\t\t\t\t\t$input.trigger(\"cleared\");\r\n\t\t\t\t\t} else if (isComplete(buffer) === true) {\r\n\t\t\t\t\t\t$input.trigger(\"complete\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}, 0);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getPlaceholder(pos, test, returnPL) {\r\n\t\ttest = test || getTest(pos).match;\r\n\t\tif (test.placeholder !== undefined || returnPL === true) {\r\n\t\t\treturn $.isFunction(test.placeholder) ? test.placeholder(opts) : test.placeholder;\r\n\t\t} else if (test.static === true) {\r\n\t\t\tif (pos > -1 && maskset.validPositions[pos] === undefined) {\r\n\t\t\t\tvar tests = getTests(pos),\r\n\t\t\t\t\tstaticAlternations = [],\r\n\t\t\t\t\tprevTest;\r\n\t\t\t\tif (tests.length > 1 + (tests[tests.length - 1].match.def === \"\" ? 1 : 0)) {\r\n\t\t\t\t\tfor (var i = 0; i < tests.length; i++) {\r\n\t\t\t\t\t\tif (tests[i].match.optionality !== true && tests[i].match.optionalQuantifier !== true &&\r\n\t\t\t\t\t\t\t(tests[i].match.static === true || (prevTest === undefined || tests[i].match.fn.test(prevTest.match.def, maskset, pos, true, opts) !== false))) {\r\n\t\t\t\t\t\t\tstaticAlternations.push(tests[i]);\r\n\t\t\t\t\t\t\tif (tests[i].match.static === true) prevTest = tests[i];\r\n\t\t\t\t\t\t\tif (staticAlternations.length > 1) {\r\n\t\t\t\t\t\t\t\tif (/[0-9a-bA-Z]/.test(staticAlternations[0].match.def)) {\r\n\t\t\t\t\t\t\t\t\treturn opts.placeholder.charAt(pos % opts.placeholder.length);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn test.def;\r\n\t\t}\r\n\r\n\t\treturn opts.placeholder.charAt(pos % opts.placeholder.length);\r\n\t}\r\n\r\n\tfunction HandleNativePlaceholder(npt, value) {\r\n\t\tif (ie) {\r\n\t\t\tif (npt.inputmask._valueGet() !== value && (npt.placeholder !== value || npt.placeholder === \"\")) {\r\n\t\t\t\tvar buffer = getBuffer().slice(),\r\n\t\t\t\t\tnptValue = npt.inputmask._valueGet();\r\n\t\t\t\tif (nptValue !== value) {\r\n\t\t\t\t\tvar lvp = getLastValidPosition();\r\n\t\t\t\t\tif (lvp === -1 && nptValue === getBufferTemplate().join(\"\")) {\r\n\t\t\t\t\t\tbuffer = [];\r\n\t\t\t\t\t} else if (lvp !== -1) { //clearout optional tail of the mask\r\n\t\t\t\t\t\tclearOptionalTail(buffer);\r\n\t\t\t\t\t}\r\n\t\t\t\t\twriteBuffer(npt, buffer);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (npt.placeholder !== value) {\r\n\t\t\tnpt.placeholder = value;\r\n\t\t\tif (npt.placeholder === \"\") npt.removeAttribute(\"placeholder\");\r\n\t\t}\r\n\t}\r\n\r\n\tfunction determineNewCaretPosition(selectedCaret, tabbed) {\r\n\t\tfunction doRadixFocus(clickPos) {\r\n\t\t\tif (opts.radixPoint !== \"\") {\r\n\t\t\t\tvar vps = maskset.validPositions;\r\n\t\t\t\tif (vps[clickPos] === undefined || (vps[clickPos].input === getPlaceholder(clickPos))) {\r\n\t\t\t\t\tif (clickPos < seekNext(-1)) return true;\r\n\t\t\t\t\tvar radixPos = $.inArray(opts.radixPoint, getBuffer());\r\n\t\t\t\t\tif (radixPos !== -1) {\r\n\t\t\t\t\t\tfor (var vp in vps) {\r\n\t\t\t\t\t\t\tif (vps[vp] && radixPos < vp && vps[vp].input !== getPlaceholder(vp)) {\r\n\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tif (tabbed) {\r\n\t\t\tif (isRTL) {\r\n\t\t\t\tselectedCaret.end = selectedCaret.begin;\r\n\t\t\t} else {\r\n\t\t\t\tselectedCaret.begin = selectedCaret.end;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (selectedCaret.begin === selectedCaret.end) {\r\n\t\t\tswitch (opts.positionCaretOnClick) {\r\n\t\t\t\tcase \"none\":\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"select\":\r\n\t\t\t\t\treturn {begin: 0, end: getBuffer().length};\r\n\t\t\t\tcase \"ignore\":\r\n\t\t\t\t\treturn seekNext(getLastValidPosition());\r\n\t\t\t\tcase \"radixFocus\":\r\n\t\t\t\t\tif (doRadixFocus(selectedCaret.begin)) {\r\n\t\t\t\t\t\tvar radixPos = getBuffer().join(\"\").indexOf(opts.radixPoint);\r\n\t\t\t\t\t\treturn opts.numericInput ? seekNext(radixPos) : radixPos;\r\n\t\t\t\t\t} //fallback to lvp\r\n\t\t\t\t// eslint-disable-next-line no-fallthrough\r\n\t\t\t\tdefault: //lvp:\r\n\t\t\t\t\tvar clickPosition = selectedCaret.begin,\r\n\t\t\t\t\t\tlvclickPosition = getLastValidPosition(clickPosition, true),\r\n\t\t\t\t\t\tlastPosition = seekNext((lvclickPosition === -1 && !isMask(0)) ? 0 : lvclickPosition);\r\n\t\t\t\t\tif (clickPosition < lastPosition) {\r\n\t\t\t\t\t\treturn !isMask(clickPosition, true) && !isMask(clickPosition - 1, true) ? seekNext(clickPosition) : clickPosition;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tvar lvp = maskset.validPositions[lvclickPosition],\r\n\t\t\t\t\t\t\ttt = getTestTemplate(lastPosition, lvp ? lvp.match.locator : undefined, lvp),\r\n\t\t\t\t\t\t\tplaceholder = getPlaceholder(lastPosition, tt.match);\r\n\t\t\t\t\t\tif ((placeholder !== \"\" && getBuffer()[lastPosition] !== placeholder && tt.match.optionalQuantifier !== true && tt.match.newBlockMarker !== true) || (!isMask(lastPosition, opts.keepStatic) && tt.match.def === placeholder)) {\r\n\t\t\t\t\t\t\tvar newPos = seekNext(lastPosition);\r\n\t\t\t\t\t\t\tif (clickPosition >= newPos || clickPosition === lastPosition) {\r\n\t\t\t\t\t\t\t\tlastPosition = newPos;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn lastPosition;\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tvar EventRuler = {\r\n\t\ton: function (input, eventName, eventHandler) {\r\n\t\t\tvar ev = function (e) {\r\n\t\t\t\tvar that = this, args;\r\n\t\t\t\t// console.log(e.type);\r\n\t\t\t\tif (that.inputmask === undefined && this.nodeName !== \"FORM\") { //happens when cloning an object with jquery.clone\r\n\t\t\t\t\tvar imOpts = $.data(that, \"_inputmask_opts\");\r\n\t\t\t\t\tif (imOpts) {\r\n\t\t\t\t\t\t(new Inputmask(imOpts)).mask(that);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tEventRuler.off(that);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (e.type !== \"setvalue\" && this.nodeName !== \"FORM\" && (that.disabled || (that.readOnly && !(e.type === \"keydown\" && (e.ctrlKey && e.keyCode === 67) || (opts.tabThrough === false && e.keyCode === Inputmask.keyCode.TAB))))) {\r\n\t\t\t\t\te.preventDefault();\r\n\t\t\t\t} else {\r\n\t\t\t\t\tswitch (e.type) {\r\n\t\t\t\t\t\tcase \"input\":\r\n\t\t\t\t\t\t\tif (skipInputEvent === true) {\r\n\t\t\t\t\t\t\t\tskipInputEvent = false;\r\n\t\t\t\t\t\t\t\treturn e.preventDefault();\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (mobile) {\r\n\t\t\t\t\t\t\t\targs = arguments;\r\n\t\t\t\t\t\t\t\tsetTimeout(function () { //needed for caret selection when entering a char on Android 8 - #1818\r\n\t\t\t\t\t\t\t\t\teventHandler.apply(that, args);\r\n\t\t\t\t\t\t\t\t\tcaret(that, that.inputmask.caretPos, undefined, true);\r\n\t\t\t\t\t\t\t\t}, 0);\r\n\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase \"keydown\":\r\n\t\t\t\t\t\t\t//Safari 5.1.x - modal dialog fires keypress twice workaround\r\n\t\t\t\t\t\t\tskipKeyPressEvent = false;\r\n\t\t\t\t\t\t\tskipInputEvent = false;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase \"keypress\":\r\n\t\t\t\t\t\t\tif (skipKeyPressEvent === true) {\r\n\t\t\t\t\t\t\t\treturn e.preventDefault();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tskipKeyPressEvent = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase \"click\":\r\n\t\t\t\t\t\tcase \"focus\":\r\n\t\t\t\t\t\t\targs = arguments;\r\n\t\t\t\t\t\t\tsetTimeout(function () { //needed for Chrome ~ initial selection clears after the clickevent\r\n\t\t\t\t\t\t\t\teventHandler.apply(that, args);\r\n\t\t\t\t\t\t\t}, focusDelay);\r\n\t\t\t\t\t\t\tfocusDelay = 0;\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\tcase \"invalid\":\r\n\t\t\t\t\t\t\tfocusDelay = 1000;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar returnVal = eventHandler.apply(that, arguments);\r\n\t\t\t\t\tif (returnVal === false) {\r\n\t\t\t\t\t\te.preventDefault();\r\n\t\t\t\t\t\te.stopPropagation();\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn returnVal;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\t//keep instance of the event\r\n\t\t\tinput.inputmask.events[eventName] = input.inputmask.events[eventName] || [];\r\n\t\t\tinput.inputmask.events[eventName].push(ev);\r\n\r\n\t\t\tif ($.inArray(eventName, [\"submit\", \"reset\"]) !== -1) {\r\n\t\t\t\tif (input.form !== null) $(input.form).on(eventName, ev);\r\n\t\t\t} else {\r\n\t\t\t\t$(input).on(eventName, ev);\r\n\t\t\t}\r\n\t\t},\r\n\t\toff: function (input, event) {\r\n\t\t\tif (input.inputmask && input.inputmask.events) {\r\n\t\t\t\tvar events;\r\n\t\t\t\tif (event) {\r\n\t\t\t\t\tevents = [];\r\n\t\t\t\t\tevents[event] = input.inputmask.events[event];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tevents = input.inputmask.events;\r\n\t\t\t\t}\r\n\t\t\t\t$.each(events, function (eventName, evArr) {\r\n\t\t\t\t\twhile (evArr.length > 0) {\r\n\t\t\t\t\t\tvar ev = evArr.pop();\r\n\t\t\t\t\t\tif ($.inArray(eventName, [\"submit\", \"reset\", \"invalid\"]) !== -1) {\r\n\t\t\t\t\t\t\tif (input.form !== null) $(input.form).off(eventName, ev);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t$(input).off(eventName, ev);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdelete input.inputmask.events[eventName];\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\tvar EventHandlers = {\r\n\t\tkeydownEvent: function (e) {\r\n\t\t\tvar input = this,\r\n\t\t\t\t$input = $(input),\r\n\t\t\t\tk = e.keyCode,\r\n\t\t\t\tpos = caret(input);\r\n\r\n\t\t\tvar kdResult = opts.onKeyDown.call(this, e, getBuffer(), pos.begin, opts);\r\n\t\t\tif (kdResult !== undefined) return kdResult;\r\n\r\n\t\t\t//backspace, delete, and escape get special treatment\r\n\t\t\tif (k === Inputmask.keyCode.BACKSPACE || k === Inputmask.keyCode.DELETE || (iphone && k === Inputmask.keyCode.BACKSPACE_SAFARI) || (e.ctrlKey && k === Inputmask.keyCode.X && !isInputEventSupported(\"cut\"))) { //backspace/delete\r\n\t\t\t\te.preventDefault(); //stop default action but allow propagation\r\n\t\t\t\thandleRemove(input, k, pos);\r\n\t\t\t\twriteBuffer(input, getBuffer(true), maskset.p, e, input.inputmask._valueGet() !== getBuffer().join(\"\"));\r\n\t\t\t} else if (k === Inputmask.keyCode.END || k === Inputmask.keyCode.PAGE_DOWN) { //when END or PAGE_DOWN pressed set position at lastmatch\r\n\t\t\t\te.preventDefault();\r\n\t\t\t\tvar caretPos = seekNext(getLastValidPosition());\r\n\t\t\t\tcaret(input, e.shiftKey ? pos.begin : caretPos, caretPos, true);\r\n\t\t\t} else if ((k === Inputmask.keyCode.HOME && !e.shiftKey) || k === Inputmask.keyCode.PAGE_UP) { //Home or page_up\r\n\t\t\t\te.preventDefault();\r\n\t\t\t\tcaret(input, 0, e.shiftKey ? pos.begin : 0, true);\r\n\t\t\t} else if (((opts.undoOnEscape && k === Inputmask.keyCode.ESCAPE) || (k === 90 && e.ctrlKey)) && e.altKey !== true) { //escape && undo && #762\r\n\t\t\t\tcheckVal(input, true, false, undoValue.split(\"\"));\r\n\t\t\t\t$input.trigger(\"click\");\r\n\t\t\t} else if (k === Inputmask.keyCode.INSERT && !(e.shiftKey || e.ctrlKey)) { //insert\r\n\t\t\t\topts.insertMode = !opts.insertMode;\r\n\t\t\t\tinput.setAttribute(\"data-im-insert\", opts.insertMode);\r\n\t\t\t} else if (opts.tabThrough === true && k === Inputmask.keyCode.TAB) {\r\n\t\t\t\tif (e.shiftKey === true) {\r\n\t\t\t\t\tif (getTest(pos.begin).match.static === true) {\r\n\t\t\t\t\t\tpos.begin = seekNext(pos.begin);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpos.end = seekPrevious(pos.begin, true);\r\n\t\t\t\t\tpos.begin = seekPrevious(pos.end, true);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tpos.begin = seekNext(pos.begin, true);\r\n\t\t\t\t\tpos.end = seekNext(pos.begin, true);\r\n\t\t\t\t\tif (pos.end < maskset.maskLength) pos.end--;\r\n\t\t\t\t}\r\n\t\t\t\tif (pos.begin < maskset.maskLength) {\r\n\t\t\t\t\te.preventDefault();\r\n\t\t\t\t\tcaret(input, pos.begin, pos.end);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tignorable = $.inArray(k, opts.ignorables) !== -1;\r\n\t\t},\r\n\t\tkeypressEvent: function (e, checkval, writeOut, strict, ndx) {\r\n\t\t\tvar input = this,\r\n\t\t\t\t$input = $(input),\r\n\t\t\t\tk = e.which || e.charCode || e.keyCode;\r\n\r\n\t\t\tif (checkval !== true && (!(e.ctrlKey && e.altKey) && (e.ctrlKey || e.metaKey || ignorable))) {\r\n\t\t\t\tif (k === Inputmask.keyCode.ENTER && undoValue !== getBuffer().join(\"\")) {\r\n\t\t\t\t\tundoValue = getBuffer().join(\"\");\r\n\t\t\t\t\t// e.preventDefault();\r\n\t\t\t\t\tsetTimeout(function () {\r\n\t\t\t\t\t\t$input.trigger(\"change\");\r\n\t\t\t\t\t}, 0);\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t} else if (k) {\r\n\t\t\t\t//special treat the decimal separator\r\n\t\t\t\tif (k === 46 && e.shiftKey === false && opts.radixPoint !== \"\") k = opts.radixPoint.charCodeAt(0);\r\n\t\t\t\tvar pos = checkval ? {\r\n\t\t\t\t\t\tbegin: ndx,\r\n\t\t\t\t\t\tend: ndx\r\n\t\t\t\t\t} : caret(input),\r\n\t\t\t\t\tforwardPosition, c = String.fromCharCode(k);\r\n\r\n\t\t\t\tmaskset.writeOutBuffer = true;\r\n\t\t\t\tvar valResult = isValid(pos, c, strict);\r\n\t\t\t\tif (valResult !== false) {\r\n\t\t\t\t\tresetMaskSet(true);\r\n\t\t\t\t\tforwardPosition = valResult.caret !== undefined ? valResult.caret : seekNext(valResult.pos.begin ? valResult.pos.begin : valResult.pos);\r\n\t\t\t\t\tmaskset.p = forwardPosition; //needed for checkval\r\n\t\t\t\t}\r\n\r\n\t\t\t\tforwardPosition = ((opts.numericInput && valResult.caret === undefined) ? seekPrevious(forwardPosition) : forwardPosition);\r\n\t\t\t\tif (writeOut !== false) {\r\n\t\t\t\t\tsetTimeout(function () {\r\n\t\t\t\t\t\topts.onKeyValidation.call(input, k, valResult, opts);\r\n\t\t\t\t\t}, 0);\r\n\t\t\t\t\tif (maskset.writeOutBuffer && valResult !== false) {\r\n\t\t\t\t\t\tvar buffer = getBuffer();\r\n\t\t\t\t\t\twriteBuffer(input, buffer, forwardPosition, e, checkval !== true);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\te.preventDefault();\r\n\r\n\t\t\t\tif (checkval) {\r\n\t\t\t\t\tif (valResult !== false) valResult.forwardPosition = forwardPosition;\r\n\t\t\t\t\treturn valResult;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tpasteEvent: function (e) {\r\n\t\t\tvar input = this,\r\n\t\t\t\tev = e.originalEvent || e,\r\n\t\t\t\tinputValue = input.inputmask._valueGet(true),\r\n\t\t\t\tcaretPos = caret(input),\r\n\t\t\t\ttempValue;\r\n\r\n\t\t\tif (isRTL) {\r\n\t\t\t\ttempValue = caretPos.end;\r\n\t\t\t\tcaretPos.end = caretPos.begin;\r\n\t\t\t\tcaretPos.begin = tempValue;\r\n\t\t\t}\r\n\r\n\t\t\tvar valueBeforeCaret = inputValue.substr(0, caretPos.begin),\r\n\t\t\t\tvalueAfterCaret = inputValue.substr(caretPos.end, inputValue.length);\r\n\r\n\t\t\tif (valueBeforeCaret === (isRTL ? getBufferTemplate().reverse() : getBufferTemplate()).slice(0, caretPos.begin).join(\"\")) valueBeforeCaret = \"\";\r\n\t\t\tif (valueAfterCaret === (isRTL ? getBufferTemplate().reverse() : getBufferTemplate()).slice(caretPos.end).join(\"\")) valueAfterCaret = \"\";\r\n\r\n\t\t\tif (window.clipboardData && window.clipboardData.getData) { // IE\r\n\t\t\t\tinputValue = valueBeforeCaret + window.clipboardData.getData(\"Text\") + valueAfterCaret;\r\n\t\t\t} else if (ev.clipboardData && ev.clipboardData.getData) {\r\n\t\t\t\tinputValue = valueBeforeCaret + ev.clipboardData.getData(\"text/plain\") + valueAfterCaret;\r\n\t\t\t} else {\r\n\t\t\t\treturn true;\r\n\t\t\t} //allow native paste event as fallback ~ masking will continue by inputfallback\r\n\r\n\t\t\tvar pasteValue = inputValue;\r\n\t\t\tif ($.isFunction(opts.onBeforePaste)) {\r\n\t\t\t\tpasteValue = opts.onBeforePaste.call(inputmask, inputValue, opts);\r\n\t\t\t\tif (pasteValue === false) {\r\n\t\t\t\t\treturn e.preventDefault();\r\n\t\t\t\t}\r\n\t\t\t\tif (!pasteValue) {\r\n\t\t\t\t\tpasteValue = inputValue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcheckVal(input, false, false, pasteValue.toString().split(\"\"));\r\n\t\t\twriteBuffer(input, getBuffer(), seekNext(getLastValidPosition()), e, undoValue !== getBuffer().join(\"\"));\r\n\t\t\treturn e.preventDefault();\r\n\t\t},\r\n\t\tinputFallBackEvent: function (e) { //fallback when keypress is not triggered\r\n\t\t\tfunction radixPointHandler(input, inputValue, caretPos) {\r\n\t\t\t\t//radixpoint tweak\r\n\t\t\t\tif (inputValue.charAt(caretPos.begin - 1) === \".\" && opts.radixPoint !== \"\") {\r\n\t\t\t\t\tinputValue = inputValue.split(\"\");\r\n\t\t\t\t\tinputValue[caretPos.begin - 1] = opts.radixPoint.charAt(0);\r\n\t\t\t\t\tinputValue = inputValue.join(\"\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn inputValue;\r\n\t\t\t}\r\n\r\n\t\t\tfunction ieMobileHandler(input, inputValue, caretPos) {\r\n\t\t\t\tif (iemobile) { //iemobile just sets the character at the end althought the caret position is correctly set\r\n\t\t\t\t\tvar inputChar = inputValue.replace(getBuffer().join(\"\"), \"\");\r\n\t\t\t\t\tif (inputChar.length === 1) {\r\n\t\t\t\t\t\tvar iv = inputValue.split(\"\");\r\n\t\t\t\t\t\tiv.splice(caretPos.begin, 0, inputChar);\r\n\t\t\t\t\t\tinputValue = iv.join(\"\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn inputValue;\r\n\t\t\t}\r\n\r\n\t\t\tvar input = this,\r\n\t\t\t\tinputValue = input.inputmask._valueGet();\r\n\r\n\t\t\tif (getBuffer().join(\"\") !== inputValue) {\r\n\r\n\t\t\t\tvar caretPos = caret(input);\r\n\t\t\t\tinputValue = radixPointHandler(input, inputValue, caretPos);\r\n\t\t\t\tinputValue = ieMobileHandler(input, inputValue, caretPos);\r\n\r\n\t\t\t\tif (getBuffer().join(\"\") !== inputValue) {\r\n\t\t\t\t\tvar buffer = getBuffer().join(\"\"),\r\n\t\t\t\t\t\toffset = (!opts.numericInput && inputValue.length > buffer.length) ? -1 : 0,\r\n\t\t\t\t\t\tfrontPart = inputValue.substr(0, caretPos.begin),\r\n\t\t\t\t\t\tbackPart = inputValue.substr(caretPos.begin),\r\n\t\t\t\t\t\tfrontBufferPart = buffer.substr(0, caretPos.begin + offset),\r\n\t\t\t\t\t\tbackBufferPart = buffer.substr(caretPos.begin + offset);\r\n\r\n\t\t\t\t\t//check if thare was a selection\r\n\t\t\t\t\tvar selection = caretPos,\r\n\t\t\t\t\t\tentries = \"\",\r\n\t\t\t\t\t\tisEntry = false;\r\n\t\t\t\t\tif (frontPart !== frontBufferPart) {\r\n\t\t\t\t\t\tvar fpl = ((isEntry = frontPart.length >= frontBufferPart.length)) ? frontPart.length : frontBufferPart.length,\r\n\t\t\t\t\t\t\ti;\r\n\t\t\t\t\t\tfor (i = 0; frontPart.charAt(i) === frontBufferPart.charAt(i) && i < fpl; i++) ;\r\n\t\t\t\t\t\tif (isEntry) {\r\n\t\t\t\t\t\t\tselection.begin = i - offset;\r\n\t\t\t\t\t\t\tentries += frontPart.slice(i, selection.end);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (backPart !== backBufferPart) {\r\n\t\t\t\t\t\tif (backPart.length > backBufferPart.length) {\r\n\t\t\t\t\t\t\tentries += backPart.slice(0, 1);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tif (backPart.length < backBufferPart.length) {\r\n\t\t\t\t\t\t\t\tselection.end += backBufferPart.length - backPart.length;\r\n\t\t\t\t\t\t\t\t//hack around numeric alias & radixpoint\r\n\t\t\t\t\t\t\t\tif (!isEntry && opts.radixPoint !== \"\" && backPart === \"\" && frontPart.charAt(selection.begin + offset - 1) === opts.radixPoint) {\r\n\t\t\t\t\t\t\t\t\tselection.begin--;\r\n\t\t\t\t\t\t\t\t\tentries = opts.radixPoint;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\twriteBuffer(input, getBuffer(), {\r\n\t\t\t\t\t\t\"begin\": selection.begin + offset,\r\n\t\t\t\t\t\t\"end\": selection.end + offset\r\n\t\t\t\t\t});\r\n\t\t\t\t\tif (entries.length > 0) {\r\n\t\t\t\t\t\t$.each(entries.split(\"\"), function (ndx, entry) {\r\n\t\t\t\t\t\t\tvar keypress = new $.Event(\"keypress\");\r\n\t\t\t\t\t\t\tkeypress.which = entry.charCodeAt(0);\r\n\t\t\t\t\t\t\tignorable = false; //make sure ignorable is ignored ;-)\r\n\t\t\t\t\t\t\tEventHandlers.keypressEvent.call(input, keypress);\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (selection.begin === selection.end - 1) {\r\n\t\t\t\t\t\t\tselection.begin = seekPrevious(selection.begin + 1);\r\n\t\t\t\t\t\t\tif (selection.begin === selection.end - 1) {\r\n\t\t\t\t\t\t\t\tcaret(input, selection.begin);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tcaret(input, selection.begin, selection.end);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar keydown = new $.Event(\"keydown\");\r\n\t\t\t\t\t\tkeydown.keyCode = opts.numericInput ? Inputmask.keyCode.BACKSPACE : Inputmask.keyCode.DELETE;\r\n\t\t\t\t\t\tEventHandlers.keydownEvent.call(input, keydown);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\te.preventDefault();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tbeforeInputEvent: function (e) {\r\n\t\t\tif (e.cancelable) {\r\n\t\t\t\tvar input = this, keydown, keypress;\r\n\t\t\t\tswitch (e.inputType) {\r\n\t\t\t\t\tcase \"insertText\":\r\n\t\t\t\t\t\t$.each(e.data.split(\"\"), function (ndx, entry) {\r\n\t\t\t\t\t\t\tkeypress = new $.Event(\"keypress\");\r\n\t\t\t\t\t\t\tkeypress.which = entry.charCodeAt(0);\r\n\t\t\t\t\t\t\tignorable = false; //make sure ignorable is ignored ;-)\r\n\t\t\t\t\t\t\tEventHandlers.keypressEvent.call(input, keypress);\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\treturn e.preventDefault();\r\n\t\t\t\t\tcase \"deleteContentBackward\":\r\n\t\t\t\t\t\tkeydown = new $.Event(\"keydown\");\r\n\t\t\t\t\t\tkeydown.keyCode = Inputmask.keyCode.BACKSPACE;\r\n\t\t\t\t\t\tEventHandlers.keydownEvent.call(input, keydown);\r\n\t\t\t\t\t\treturn e.preventDefault();\r\n\t\t\t\t\tcase \"deleteContentForward\":\r\n\t\t\t\t\t\tkeydown = new $.Event(\"keydown\");\r\n\t\t\t\t\t\tkeydown.keyCode = Inputmask.keyCode.DELETE;\r\n\t\t\t\t\t\tEventHandlers.keydownEvent.call(input, keydown);\r\n\t\t\t\t\t\treturn e.preventDefault();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tsetValueEvent: function (e) {\r\n\t\t\tvar input = this,\r\n\t\t\t\tvalue = (e && e.detail) ? e.detail[0] : arguments[1];\r\n\t\t\tvalue = value || input.inputmask._valueGet(true);\r\n\r\n\t\t\tapplyInputValue(input, value);\r\n\r\n\t\t\tif ((e.detail && e.detail[1] !== undefined) || arguments[2] !== undefined) {\r\n\t\t\t\tcaret(input, e.detail ? e.detail[1] : arguments[2]);\r\n\t\t\t}\r\n\t\t},\r\n\t\tfocusEvent: function (e) {\r\n\t\t\tvar input = this,\r\n\t\t\t\tnptValue = input.inputmask._valueGet();\r\n\t\t\tif (opts.showMaskOnFocus) {\r\n\t\t\t\tif (nptValue !== getBuffer().join(\"\")) {\r\n\t\t\t\t\twriteBuffer(input, getBuffer(), seekNext(getLastValidPosition()));\r\n\t\t\t\t} else if (mouseEnter === false) { //only executed on focus without mouseenter\r\n\t\t\t\t\tcaret(input, seekNext(getLastValidPosition()));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (opts.positionCaretOnTab === true && mouseEnter === false) {\r\n\t\t\t\tEventHandlers.clickEvent.apply(input, [e, true]);\r\n\t\t\t}\r\n\t\t\tundoValue = getBuffer().join(\"\");\r\n\t\t},\r\n\t\tmouseleaveEvent: function () {\r\n\t\t\tvar input = this;\r\n\t\t\tmouseEnter = false;\r\n\t\t\tif (opts.clearMaskOnLostFocus && document.activeElement !== input) {\r\n\t\t\t\tHandleNativePlaceholder(input, originalPlaceholder);\r\n\t\t\t}\r\n\t\t},\r\n\t\tclickEvent: function (e, tabbed) {\r\n\t\t\tvar input = this;\r\n\t\t\tif (document.activeElement === input) {\r\n\t\t\t\tvar newCaretPosition = determineNewCaretPosition(caret(input), tabbed);\r\n\t\t\t\tif (newCaretPosition !== undefined) {\r\n\t\t\t\t\tcaret(input, newCaretPosition);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tcutEvent: function (e) {\r\n\t\t\tvar input = this,\r\n\t\t\t\tpos = caret(input),\r\n\t\t\t\tev = e.originalEvent || e;\r\n\r\n\t\t\t//correct clipboardData\r\n\t\t\tvar clipboardData = window.clipboardData || ev.clipboardData,\r\n\t\t\t\tclipData = isRTL ? getBuffer().slice(pos.end, pos.begin) : getBuffer().slice(pos.begin, pos.end);\r\n\t\t\tclipboardData.setData(\"text\", isRTL ? clipData.reverse().join(\"\") : clipData.join(\"\"));\r\n\t\t\tif (document.execCommand) document.execCommand(\"copy\"); // copy selected content to system clipbaord\r\n\r\n\t\t\thandleRemove(input, Inputmask.keyCode.DELETE, pos);\r\n\t\t\twriteBuffer(input, getBuffer(), maskset.p, e, undoValue !== getBuffer().join(\"\"));\r\n\t\t},\r\n\t\tblurEvent: function (e) {\r\n\t\t\tvar $input = $(this),\r\n\t\t\t\tinput = this;\r\n\t\t\tif (input.inputmask) {\r\n\t\t\t\tHandleNativePlaceholder(input, originalPlaceholder);\r\n\t\t\t\tvar nptValue = input.inputmask._valueGet(),\r\n\t\t\t\t\tbuffer = getBuffer().slice();\r\n\r\n\t\t\t\tif (nptValue !== \"\" || colorMask !== undefined) {\r\n\t\t\t\t\tif (opts.clearMaskOnLostFocus) {\r\n\t\t\t\t\t\tif (getLastValidPosition() === -1 && nptValue === getBufferTemplate().join(\"\")) {\r\n\t\t\t\t\t\t\tbuffer = [];\r\n\t\t\t\t\t\t} else { //clearout optional tail of the mask\r\n\t\t\t\t\t\t\tclearOptionalTail(buffer);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (isComplete(buffer) === false) {\r\n\t\t\t\t\t\tsetTimeout(function () {\r\n\t\t\t\t\t\t\t$input.trigger(\"incomplete\");\r\n\t\t\t\t\t\t}, 0);\r\n\t\t\t\t\t\tif (opts.clearIncomplete) {\r\n\t\t\t\t\t\t\tresetMaskSet();\r\n\t\t\t\t\t\t\tif (opts.clearMaskOnLostFocus) {\r\n\t\t\t\t\t\t\t\tbuffer = [];\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tbuffer = getBufferTemplate().slice();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\twriteBuffer(input, buffer, undefined, e);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (undoValue !== getBuffer().join(\"\")) {\r\n\t\t\t\t\tundoValue = getBuffer().join(\"\");\r\n\t\t\t\t\t$input.trigger(\"change\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tmouseenterEvent: function () {\r\n\t\t\tvar input = this;\r\n\t\t\tmouseEnter = true;\r\n\t\t\tif (document.activeElement !== input) {\r\n\t\t\t\tif (input.placeholder !== originalPlaceholder) {\r\n\t\t\t\t\toriginalPlaceholder = input.placeholder;\r\n\t\t\t\t}\r\n\t\t\t\tif (opts.showMaskOnHover) {\r\n\t\t\t\t\tHandleNativePlaceholder(input, (isRTL ? getBuffer().slice().reverse() : getBuffer()).join(\"\"));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tsubmitEvent: function () { //trigger change on submit if any\r\n\t\t\tif (undoValue !== getBuffer().join(\"\")) {\r\n\t\t\t\t$el.trigger(\"change\");\r\n\t\t\t}\r\n\t\t\tif (opts.clearMaskOnLostFocus && getLastValidPosition() === -1 && el.inputmask._valueGet && el.inputmask._valueGet() === getBufferTemplate().join(\"\")) {\r\n\t\t\t\tel.inputmask._valueSet(\"\"); //clear masktemplete on submit and still has focus\r\n\t\t\t}\r\n\t\t\tif (opts.clearIncomplete && isComplete(getBuffer()) === false) {\r\n\t\t\t\tel.inputmask._valueSet(\"\");\r\n\t\t\t}\r\n\t\t\tif (opts.removeMaskOnSubmit) {\r\n\t\t\t\tel.inputmask._valueSet(el.inputmask.unmaskedvalue(), true);\r\n\t\t\t\tsetTimeout(function () {\r\n\t\t\t\t\twriteBuffer(el, getBuffer());\r\n\t\t\t\t}, 0);\r\n\t\t\t}\r\n\t\t},\r\n\t\tresetEvent: function () {\r\n\t\t\tel.inputmask.refreshValue = true; //indicate a forced refresh when there is a call to the value before leaving the triggering event fn\r\n\t\t\tsetTimeout(function () {\r\n\t\t\t\tapplyInputValue(el, el.inputmask._valueGet(true));\r\n\t\t\t}, 0);\r\n\t\t},\r\n\t\tinvalidEvent: function (e) {\r\n\r\n\t\t},\r\n\t};\r\n\r\n\tfunction checkVal(input, writeOut, strict, nptvl, initiatingEvent) {\r\n\t\tvar inputmask = this || input.inputmask,\r\n\t\t\tinputValue = nptvl.slice(),\r\n\t\t\tcharCodes = \"\",\r\n\t\t\tinitialNdx = -1,\r\n\t\t\tresult = undefined;\r\n\r\n\t\t// console.log(nptvl);\r\n\r\n\t\tfunction isTemplateMatch(ndx, charCodes) {\r\n\t\t\tif (opts.regex) return false;\r\n\t\t\tvar targetTemplate = getMaskTemplate(true, 0, false).slice(ndx, seekNext(ndx)).join(\"\").replace(/'/g, \"\"),\r\n\t\t\t\tcharCodeNdx = targetTemplate.indexOf(charCodes);\r\n\t\t\t//strip spaces from targetTemplate\r\n\t\t\twhile (charCodeNdx > 0 && targetTemplate[charCodeNdx - 1] === \" \") charCodeNdx--;\r\n\r\n\t\t\tvar match = charCodeNdx === 0 && !isMask(ndx)\r\n\t\t\t\t&& (getTest(ndx).match.nativeDef === charCodes.charAt(0)\r\n\t\t\t\t\t|| (getTest(ndx).match.static === true && getTest(ndx).match.nativeDef === (\"'\" + charCodes.charAt(0)))\r\n\t\t\t\t\t|| (getTest(ndx).match.nativeDef === \" \" && (getTest(ndx + 1).match.nativeDef === charCodes.charAt(0)\r\n\t\t\t\t\t\t|| (getTest(ndx + 1).match.static === true && getTest(ndx + 1).match.nativeDef === (\"'\" + charCodes.charAt(0))))));\r\n\r\n\t\t\tif (!match && charCodeNdx > 0) inputmask.caretPos = {begin: seekNext(charCodeNdx)};\r\n\t\t\treturn match;\r\n\t\t}\r\n\r\n\t\tresetMaskSet();\r\n\t\tinitialNdx = opts.radixPoint ? determineNewCaretPosition(0) : 0;\r\n\t\tmaskset.p = initialNdx;\r\n\t\tinputmask.caretPos = {begin: initialNdx};\r\n\r\n\t\tvar staticMatches = [], prevCaretPos = inputmask.caretPos;\r\n\t\t$.each(inputValue, function (ndx, charCode) {\r\n\t\t\tif (charCode !== undefined) { //inputfallback strips some elements out of the inputarray.  $.each logically presents them as undefined\r\n\t\t\t\tif (maskset.validPositions[ndx] === undefined && inputValue[ndx] === getPlaceholder(ndx) && isMask(ndx, true) &&\r\n\t\t\t\t\tisValid(ndx, inputValue[ndx], true, undefined, undefined, true) === false) {\r\n\t\t\t\t\tmaskset.p++;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar keypress = new $.Event(\"_checkval\");\r\n\t\t\t\t\tkeypress.which = charCode.charCodeAt(0);\r\n\t\t\t\t\tcharCodes += charCode;\r\n\t\t\t\t\tvar lvp = getLastValidPosition(undefined, true);\r\n\t\t\t\t\tif (!isTemplateMatch(initialNdx, charCodes)) {\r\n\t\t\t\t\t\tresult = EventHandlers.keypressEvent.call(input, keypress, true, false, strict, inputmask.caretPos.begin);\r\n\r\n\t\t\t\t\t\tif (result) {\r\n\t\t\t\t\t\t\tinitialNdx = inputmask.caretPos.begin + 1;\r\n\t\t\t\t\t\t\tcharCodes = \"\";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tresult = EventHandlers.keypressEvent.call(input, keypress, true, false, strict, lvp + 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (result) {\r\n\t\t\t\t\t\tif (result.pos && maskset.validPositions[result.pos] && maskset.validPositions[result.pos].match.static === true) {\r\n\t\t\t\t\t\t\tstaticMatches.push(result.pos);\r\n\t\t\t\t\t\t\tresult.forwardPosition = result.pos + 1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\twriteBuffer(undefined, getBuffer(), result.forwardPosition, keypress, false);\r\n\t\t\t\t\t\tinputmask.caretPos = {begin: result.forwardPosition, end: result.forwardPosition};\r\n\t\t\t\t\t\tprevCaretPos = inputmask.caretPos;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tinputmask.caretPos = prevCaretPos;\r\n\t\t\t\t\t}  //restore the caret position from before the failed validation\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t\tif (staticMatches.length > 0) {\r\n\t\t\tvar sndx, validPos, nextValid;\r\n\t\t\tif (!isComplete(getBuffer())) {  //FIXME ENHANCE ME\r\n\t\t\t\twhile ((sndx = staticMatches.pop())) {\r\n\t\t\t\t\tvar keypress = new $.Event(\"_checkval\"),\r\n\t\t\t\t\t\tnextSndx = sndx + 1;\r\n\r\n\t\t\t\t\tvalidPos = maskset.validPositions[sndx];\r\n\t\t\t\t\tvalidPos.generatedInput = true;\r\n\t\t\t\t\tkeypress.which = validPos.input.charCodeAt(0);\r\n\t\t\t\t\twhile ((nextValid = maskset.validPositions[nextSndx]) && nextValid.input === validPos.input) {\r\n\t\t\t\t\t\tnextSndx++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tEventHandlers.keypressEvent.call(input, keypress, true, false, strict, nextSndx);\r\n\t\t\t\t\tif (isComplete(getBuffer())) break;\r\n\t\t\t\t}\r\n\t\t\t} else { //mark al statics as generated\r\n\t\t\t\twhile ((sndx = staticMatches.pop())) {\r\n\t\t\t\t\tvalidPos = maskset.validPositions[sndx];\r\n\t\t\t\t\tif (validPos) {\r\n\t\t\t\t\t\tvalidPos.generatedInput = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (writeOut) {\r\n\t\t\twriteBuffer(input, getBuffer(), result ? result.forwardPosition : undefined, initiatingEvent || new $.Event(\"checkval\"), initiatingEvent && initiatingEvent.type === \"input\");\r\n\t\t}\r\n\t}\r\n\r\n\tfunction unmaskedvalue(input) {\r\n\t\tif (input) {\r\n\t\t\tif (input.inputmask === undefined) {\r\n\t\t\t\treturn input.value;\r\n\t\t\t}\r\n\t\t\tif (input.inputmask && input.inputmask.refreshValue) { //forced refresh from the value form.reset\r\n\t\t\t\tapplyInputValue(input, input.inputmask._valueGet(true));\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar umValue = [],\r\n\t\t\tvps = maskset.validPositions;\r\n\t\tfor (var pndx in vps) {\r\n\t\t\tif (vps[pndx] && vps[pndx].match && vps[pndx].match.static != true) {\r\n\t\t\t\tumValue.push(vps[pndx].input);\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar unmaskedValue = umValue.length === 0 ? \"\" : (isRTL ? umValue.reverse() : umValue).join(\"\");\r\n\t\tif ($.isFunction(opts.onUnMask)) {\r\n\t\t\tvar bufferValue = (isRTL ? getBuffer().slice().reverse() : getBuffer()).join(\"\");\r\n\t\t\tunmaskedValue = opts.onUnMask.call(inputmask, bufferValue, unmaskedValue, opts);\r\n\t\t}\r\n\t\treturn unmaskedValue;\r\n\t}\r\n\r\n\tfunction caret(input, begin, end, notranslate) {\r\n\t\tfunction translatePosition(pos) {\r\n\t\t\tif (isRTL && typeof pos === \"number\" && (!opts.greedy || opts.placeholder !== \"\") && el) {\r\n\t\t\t\tpos = el.inputmask._valueGet().length - pos;\r\n\t\t\t}\r\n\t\t\treturn pos;\r\n\t\t}\r\n\r\n\t\tvar range;\r\n\t\tif (begin !== undefined) {\r\n\t\t\tif ($.isArray(begin)) {\r\n\t\t\t\tend = isRTL ? begin[0] : begin[1];\r\n\t\t\t\tbegin = isRTL ? begin[1] : begin[0];\r\n\t\t\t}\r\n\t\t\tif (begin.begin !== undefined) {\r\n\t\t\t\tend = isRTL ? begin.begin : begin.end;\r\n\t\t\t\tbegin = isRTL ? begin.end : begin.begin;\r\n\t\t\t}\r\n\t\t\tif (typeof begin === \"number\") {\r\n\t\t\t\tbegin = notranslate ? begin : translatePosition(begin);\r\n\t\t\t\tend = notranslate ? end : translatePosition(end);\r\n\t\t\t\tend = (typeof end == \"number\") ? end : begin;\r\n\t\t\t\t// if (!$(input).is(\":visible\")) {\r\n\t\t\t\t// \treturn;\r\n\t\t\t\t// }\r\n\r\n\t\t\t\tvar scrollCalc = parseInt(((input.ownerDocument.defaultView || window).getComputedStyle ? (input.ownerDocument.defaultView || window).getComputedStyle(input, null) : input.currentStyle).fontSize) * end;\r\n\t\t\t\tinput.scrollLeft = scrollCalc > input.scrollWidth ? scrollCalc : 0;\r\n\r\n\t\t\t\tinput.inputmask.caretPos = {begin: begin, end: end}; //track caret internally\r\n\t\t\t\tif (input === document.activeElement) {\r\n\t\t\t\t\tif (\"setSelectionRange\" in input) {\r\n\t\t\t\t\t\tinput.setSelectionRange(begin, end);\r\n\t\t\t\t\t} else if (window.getSelection) {\r\n\t\t\t\t\t\trange = document.createRange();\r\n\t\t\t\t\t\tif (input.firstChild === undefined || input.firstChild === null) {\r\n\t\t\t\t\t\t\tvar textNode = document.createTextNode(\"\");\r\n\t\t\t\t\t\t\tinput.appendChild(textNode);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\trange.setStart(input.firstChild, begin < input.inputmask._valueGet().length ? begin : input.inputmask._valueGet().length);\r\n\t\t\t\t\t\trange.setEnd(input.firstChild, end < input.inputmask._valueGet().length ? end : input.inputmask._valueGet().length);\r\n\t\t\t\t\t\trange.collapse(true);\r\n\t\t\t\t\t\tvar sel = window.getSelection();\r\n\t\t\t\t\t\tsel.removeAllRanges();\r\n\t\t\t\t\t\tsel.addRange(range);\r\n\t\t\t\t\t\t//input.focus();\r\n\t\t\t\t\t} else if (input.createTextRange) {\r\n\t\t\t\t\t\trange = input.createTextRange();\r\n\t\t\t\t\t\trange.collapse(true);\r\n\t\t\t\t\t\trange.moveEnd(\"character\", end);\r\n\t\t\t\t\t\trange.moveStart(\"character\", begin);\r\n\t\t\t\t\t\trange.select();\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\trenderColorMask(input, {\r\n\t\t\t\t\t\tbegin: begin,\r\n\t\t\t\t\t\tend: end\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (\"selectionStart\" in input && \"selectionEnd\" in input) {\r\n\t\t\t\tbegin = input.selectionStart;\r\n\t\t\t\tend = input.selectionEnd;\r\n\t\t\t} else if (window.getSelection) {\r\n\t\t\t\trange = window.getSelection().getRangeAt(0);\r\n\t\t\t\tif (range.commonAncestorContainer.parentNode === input || range.commonAncestorContainer === input) {\r\n\t\t\t\t\tbegin = range.startOffset;\r\n\t\t\t\t\tend = range.endOffset;\r\n\t\t\t\t}\r\n\t\t\t} else if (document.selection && document.selection.createRange) {\r\n\t\t\t\trange = document.selection.createRange();\r\n\t\t\t\tbegin = 0 - range.duplicate().moveStart(\"character\", -input.inputmask._valueGet().length);\r\n\t\t\t\tend = begin + range.text.length;\r\n\t\t\t}\r\n\r\n\t\t\t/*eslint-disable consistent-return */\r\n\t\t\treturn {\r\n\t\t\t\t\"begin\": notranslate ? begin : translatePosition(begin),\r\n\t\t\t\t\"end\": notranslate ? end : translatePosition(end)\r\n\t\t\t};\r\n\t\t\t/*eslint-enable consistent-return */\r\n\t\t}\r\n\t}\r\n\r\n\tfunction determineLastRequiredPosition(returnDefinition) {\r\n\t\tvar buffer = getMaskTemplate(true, getLastValidPosition(), true, true),\r\n\t\t\tbl = buffer.length,\r\n\t\t\tpos, lvp = getLastValidPosition(),\r\n\t\t\tpositions = {},\r\n\t\t\tlvTest = maskset.validPositions[lvp],\r\n\t\t\tndxIntlzr = lvTest !== undefined ? lvTest.locator.slice() : undefined,\r\n\t\t\ttestPos;\r\n\t\tfor (pos = lvp + 1; pos < buffer.length; pos++) {\r\n\t\t\ttestPos = getTestTemplate(pos, ndxIntlzr, pos - 1);\r\n\t\t\tndxIntlzr = testPos.locator.slice();\r\n\t\t\tpositions[pos] = $.extend(true, {}, testPos);\r\n\t\t}\r\n\r\n\t\tvar lvTestAlt = lvTest && lvTest.alternation !== undefined ? lvTest.locator[lvTest.alternation] : undefined;\r\n\t\tfor (pos = bl - 1; pos > lvp; pos--) {\r\n\t\t\ttestPos = positions[pos];\r\n\t\t\tif ((testPos.match.optionality ||\r\n\t\t\t\t\t(testPos.match.optionalQuantifier && testPos.match.newBlockMarker) ||\r\n\t\t\t\t\t(lvTestAlt &&\r\n\t\t\t\t\t\t(\r\n\t\t\t\t\t\t\t(lvTestAlt !== positions[pos].locator[lvTest.alternation] && testPos.match.static != true) ||\r\n\t\t\t\t\t\t\t(testPos.match.static === true &&\r\n\t\t\t\t\t\t\t\ttestPos.locator[lvTest.alternation] &&\r\n\t\t\t\t\t\t\t\tcheckAlternationMatch(testPos.locator[lvTest.alternation].toString().split(\",\"), lvTestAlt.toString().split(\",\")) &&\r\n\t\t\t\t\t\t\t\tgetTests(pos)[0].def !== \"\")\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t)\r\n\t\t\t\t) &&\r\n\t\t\t\tbuffer[pos] === getPlaceholder(pos, testPos.match)) {\r\n\t\t\t\tbl--;\r\n\t\t\t} else {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn returnDefinition ? {\r\n\t\t\t\"l\": bl,\r\n\t\t\t\"def\": positions[bl] ? positions[bl].match : undefined\r\n\t\t} : bl;\r\n\t}\r\n\r\n\tfunction clearOptionalTail(buffer) {\r\n\t\tbuffer.length = 0;\r\n\t\tvar template = getMaskTemplate(true, 0, true, undefined, true), lmnt;\r\n\t\twhile ((lmnt = template.shift()) !== undefined) buffer.push(lmnt);\r\n\t\treturn buffer;\r\n\t}\r\n\r\n\tfunction isComplete(buffer) { //return true / false / undefined (repeat *)\r\n\t\tif ($.isFunction(opts.isComplete)) return opts.isComplete(buffer, opts);\r\n\t\tif (opts.repeat === \"*\") return undefined;\r\n\t\tvar complete = false,\r\n\t\t\tlrp = determineLastRequiredPosition(true),\r\n\t\t\taml = seekPrevious(lrp.l);\r\n\r\n\t\tif (lrp.def === undefined || lrp.def.newBlockMarker || lrp.def.optionality || lrp.def.optionalQuantifier) {\r\n\t\t\tcomplete = true;\r\n\t\t\tfor (var i = 0; i <= aml; i++) {\r\n\t\t\t\tvar test = getTestTemplate(i).match;\r\n\t\t\t\tif ((test.static !== true && maskset.validPositions[i] === undefined && test.optionality !== true && test.optionalQuantifier !== true) || (test.static === true && buffer[i] !== getPlaceholder(i, test))) {\r\n\t\t\t\t\tcomplete = false;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn complete;\r\n\t}\r\n\r\n\r\n\tfunction handleRemove(input, k, pos, strict, fromIsValid) {\r\n\t\tif (opts.numericInput || isRTL) {\r\n\t\t\tif (k === Inputmask.keyCode.BACKSPACE) {\r\n\t\t\t\tk = Inputmask.keyCode.DELETE;\r\n\t\t\t} else if (k === Inputmask.keyCode.DELETE) {\r\n\t\t\t\tk = Inputmask.keyCode.BACKSPACE;\r\n\t\t\t}\r\n\r\n\t\t\tif (isRTL) {\r\n\t\t\t\tvar pend = pos.end;\r\n\t\t\t\tpos.end = pos.begin;\r\n\t\t\t\tpos.begin = pend;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (k === Inputmask.keyCode.BACKSPACE && (pos.end - pos.begin < 1)) {\r\n\t\t\tpos.begin = seekPrevious(pos.begin);\r\n\t\t\tif (maskset.validPositions[pos.begin] !== undefined && maskset.validPositions[pos.begin].input === opts.groupSeparator) {\r\n\t\t\t\tpos.begin--;\r\n\t\t\t}\r\n\t\t} else if (k === Inputmask.keyCode.DELETE && pos.begin === pos.end) {\r\n\t\t\tpos.end = isMask(pos.end, true) && (maskset.validPositions[pos.end] && maskset.validPositions[pos.end].input !== opts.radixPoint) ?\r\n\t\t\t\tpos.end + 1 :\r\n\t\t\t\tseekNext(pos.end) + 1;\r\n\t\t\tif (maskset.validPositions[pos.begin] !== undefined && maskset.validPositions[pos.begin].input === opts.groupSeparator) {\r\n\t\t\t\tpos.end++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\trevalidateMask(pos);\r\n\r\n\t\tif (strict !== true && opts.keepStatic !== false || opts.regex !== null) {\r\n\t\t\tvar result = alternate(true);\r\n\t\t\tif (result) {\r\n\t\t\t\tvar newPos = result.caret !== undefined ? result.caret : (result.pos ? seekNext(result.pos.begin ? result.pos.begin : result.pos) : getLastValidPosition(-1, true));\r\n\t\t\t\tif (k !== Inputmask.keyCode.DELETE || pos.begin > newPos) {\r\n\t\t\t\t\tpos.begin == newPos;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar lvp = getLastValidPosition(pos.begin, true);\r\n\t\tif (lvp < pos.begin || pos.begin === -1) {\r\n\t\t\t//if (lvp === -1) resetMaskSet();\r\n\t\t\tmaskset.p = seekNext(lvp);\r\n\t\t} else if (strict !== true) {\r\n\t\t\tmaskset.p = pos.begin;\r\n\t\t\tif (fromIsValid !== true) {\r\n\t\t\t\t//put position on first valid from pos.begin ~ #1351\r\n\t\t\t\twhile (maskset.p < lvp && maskset.validPositions[maskset.p] === undefined) {\r\n\t\t\t\t\tmaskset.p++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction initializeColorMask(input) {\r\n\t\tvar computedStyle = (input.ownerDocument.defaultView || window).getComputedStyle(input, null);\r\n\r\n\t\tfunction findCaretPos(clientx) {\r\n\t\t\t//calculate text width\r\n\t\t\tvar e = document.createElement(\"span\"),\r\n\t\t\t\tcaretPos;\r\n\t\t\tfor (var style in computedStyle) { //clone styles\r\n\t\t\t\tif (isNaN(style) && style.indexOf(\"font\") !== -1) {\r\n\t\t\t\t\te.style[style] = computedStyle[style];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\te.style.textTransform = computedStyle.textTransform;\r\n\t\t\te.style.letterSpacing = computedStyle.letterSpacing;\r\n\t\t\te.style.position = \"absolute\";\r\n\t\t\te.style.height = \"auto\";\r\n\t\t\te.style.width = \"auto\";\r\n\t\t\te.style.visibility = \"hidden\";\r\n\t\t\te.style.whiteSpace = \"nowrap\";\r\n\r\n\t\t\tdocument.body.appendChild(e);\r\n\t\t\tvar inputText = input.inputmask._valueGet(),\r\n\t\t\t\tpreviousWidth = 0,\r\n\t\t\t\titl;\r\n\t\t\tfor (caretPos = 0, itl = inputText.length; caretPos <= itl; caretPos++) {\r\n\t\t\t\te.innerHTML += inputText.charAt(caretPos) || \"_\";\r\n\t\t\t\tif (e.offsetWidth >= clientx) {\r\n\t\t\t\t\tvar offset1 = (clientx - previousWidth);\r\n\t\t\t\t\tvar offset2 = e.offsetWidth - clientx;\r\n\t\t\t\t\te.innerHTML = inputText.charAt(caretPos);\r\n\t\t\t\t\toffset1 -= (e.offsetWidth / 3);\r\n\t\t\t\t\tcaretPos = offset1 < offset2 ? caretPos - 1 : caretPos;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tpreviousWidth = e.offsetWidth;\r\n\t\t\t}\r\n\t\t\tdocument.body.removeChild(e);\r\n\t\t\treturn caretPos;\r\n\t\t}\r\n\r\n\t\tvar template = document.createElement(\"div\");\r\n\t\ttemplate.style.width = computedStyle.width;\r\n\t\ttemplate.style.textAlign = computedStyle.textAlign;\r\n\t\tcolorMask = document.createElement(\"div\");\r\n\t\tinput.inputmask.colorMask = colorMask;\r\n\t\tcolorMask.className = \"im-colormask\";\r\n\t\tinput.parentNode.insertBefore(colorMask, input);\r\n\t\tinput.parentNode.removeChild(input);\r\n\t\tcolorMask.appendChild(input);\r\n\t\tcolorMask.appendChild(template);\r\n\t\tinput.style.left = template.offsetLeft + \"px\";\r\n\r\n\t\t$(colorMask).on(\"mouseleave\", function (e) {\r\n\t\t\treturn EventHandlers.mouseleaveEvent.call(input, [e]);\r\n\t\t});\r\n\t\t$(colorMask).on(\"mouseenter\", function (e) {\r\n\t\t\treturn EventHandlers.mouseenterEvent.call(input, [e]);\r\n\t\t});\r\n\t\t$(colorMask).on(\"click\", function (e) {\r\n\t\t\tcaret(input, findCaretPos(e.clientX));\r\n\t\t\treturn EventHandlers.clickEvent.call(input, [e]);\r\n\t\t});\r\n\t}\r\n\r\n\r\n\tfunction renderColorMask(input, caretPos, clear) {\r\n\t\tvar maskTemplate = [],\r\n\t\t\tisStatic = false,\r\n\t\t\ttest, testPos, ndxIntlzr, pos = 0;\r\n\r\n\r\n\t\tfunction setEntry(entry) {\r\n\t\t\tif (entry === undefined) entry = \"\";\r\n\t\t\tif (!isStatic && (test.static === true || testPos.input === undefined)) {\r\n\t\t\t\tisStatic = true;\r\n\t\t\t\tmaskTemplate.push(\"<span class='im-static'>\" + entry);\r\n\t\t\t} else if (isStatic && ((test.static !== true && testPos.input !== undefined) || test.def === \"\")) {\r\n\t\t\t\tisStatic = false;\r\n\t\t\t\tvar mtl = maskTemplate.length;\r\n\t\t\t\tmaskTemplate[mtl - 1] = maskTemplate[mtl - 1] + \"</span>\";\r\n\t\t\t\tmaskTemplate.push(entry);\r\n\t\t\t} else {\r\n\t\t\t\tmaskTemplate.push(entry);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction setCaret() {\r\n\t\t\tif (document.activeElement === input) {\r\n\t\t\t\tmaskTemplate.splice(caretPos.begin, 0,\r\n\t\t\t\t\t(caretPos.begin === caretPos.end || caretPos.end > maskset.maskLength) ?\r\n\t\t\t\t\t\t\"<mark class=\\\"im-caret\\\" style=\\\"border-right-width: 1px;border-right-style: solid;\\\">\" :\r\n\t\t\t\t\t\t\"<mark class=\\\"im-caret-select\\\">\");\r\n\t\t\t\tmaskTemplate.splice(caretPos.end + 1, 0, \"</mark>\");\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (colorMask !== undefined) {\r\n\t\t\tvar buffer = getBuffer();\r\n\t\t\tif (caretPos === undefined) {\r\n\t\t\t\tcaretPos = caret(input);\r\n\t\t\t} else if (caretPos.begin === undefined) {\r\n\t\t\t\tcaretPos = {\r\n\t\t\t\t\tbegin: caretPos,\r\n\t\t\t\t\tend: caretPos\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tif (clear !== true) {\r\n\t\t\t\tvar lvp = getLastValidPosition();\r\n\t\t\t\tdo {\r\n\t\t\t\t\tif (maskset.validPositions[pos]) {\r\n\t\t\t\t\t\ttestPos = maskset.validPositions[pos];\r\n\t\t\t\t\t\ttest = testPos.match;\r\n\t\t\t\t\t\tndxIntlzr = testPos.locator.slice();\r\n\t\t\t\t\t\tsetEntry(buffer[pos]);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttestPos = getTestTemplate(pos, ndxIntlzr, pos - 1);\r\n\t\t\t\t\t\ttest = testPos.match;\r\n\t\t\t\t\t\tndxIntlzr = testPos.locator.slice();\r\n\t\t\t\t\t\tif (opts.jitMasking === false || pos < lvp || (typeof opts.jitMasking === \"number\" && isFinite(opts.jitMasking) && opts.jitMasking > pos)) {\r\n\t\t\t\t\t\t\tsetEntry(getPlaceholder(pos, test));\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tisStatic = false;\r\n\t\t\t\t\t\t} //break infinite loop\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpos++;\r\n\t\t\t\t} while ((maxLength === undefined || pos < maxLength) && (test.static !== true || test.def !== \"\") || lvp > pos || isStatic);\r\n\t\t\t\tif (isStatic) setEntry();\r\n\t\t\t\tsetCaret();\r\n\t\t\t}\r\n\r\n\t\t\tvar template = colorMask.getElementsByTagName(\"div\")[0];\r\n\t\t\ttemplate.innerHTML = maskTemplate.join(\"\");\r\n\t\t\tinput.inputmask.positionColorMask(input, template);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction applyInputValue(input, value) {\r\n\t\tinput.inputmask.refreshValue = false;\r\n\t\tif ($.isFunction(opts.onBeforeMask)) value = opts.onBeforeMask.call(inputmask, value, opts) || value;\r\n\t\tvalue = value.toString().split(\"\");\r\n\t\tcheckVal(input, true, false, value);\r\n\t\tundoValue = getBuffer().join(\"\");\r\n\t\tif ((opts.clearMaskOnLostFocus || opts.clearIncomplete) && input.inputmask._valueGet() === getBufferTemplate().join(\"\") && getLastValidPosition() === -1) {\r\n\t\t\tinput.inputmask._valueSet(\"\");\r\n\t\t}\r\n\t}\r\n\r\n\tfunction mask(elem) {\r\n\t\tfunction isElementTypeSupported(input, opts) {\r\n\t\t\tfunction patchValueProperty(npt) {\r\n\t\t\t\tvar valueGet;\r\n\t\t\t\tvar valueSet;\r\n\r\n\t\t\t\tfunction patchValhook(type) {\r\n\t\t\t\t\tif ($.valHooks && ($.valHooks[type] === undefined || $.valHooks[type].inputmaskpatch !== true)) {\r\n\t\t\t\t\t\tvar valhookGet = $.valHooks[type] && $.valHooks[type].get ? $.valHooks[type].get : function (elem) {\r\n\t\t\t\t\t\t\treturn elem.value;\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\tvar valhookSet = $.valHooks[type] && $.valHooks[type].set ? $.valHooks[type].set : function (elem, value) {\r\n\t\t\t\t\t\t\telem.value = value;\r\n\t\t\t\t\t\t\treturn elem;\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t$.valHooks[type] = {\r\n\t\t\t\t\t\t\tget: function (elem) {\r\n\t\t\t\t\t\t\t\tif (elem.inputmask) {\r\n\t\t\t\t\t\t\t\t\tif (elem.inputmask.opts.autoUnmask) {\r\n\t\t\t\t\t\t\t\t\t\treturn elem.inputmask.unmaskedvalue();\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tvar result = valhookGet(elem);\r\n\t\t\t\t\t\t\t\t\t\treturn getLastValidPosition(undefined, undefined, elem.inputmask.maskset.validPositions) !== -1 || opts.nullable !== true ? result : \"\";\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\treturn valhookGet(elem);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tset: function (elem, value) {\r\n\t\t\t\t\t\t\t\tvar result = valhookSet(elem, value);\r\n\t\t\t\t\t\t\t\tif (elem.inputmask) {\r\n\t\t\t\t\t\t\t\t\tapplyInputValue(elem, value);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\treturn result;\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tinputmaskpatch: true\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfunction getter() {\r\n\t\t\t\t\tif (this.inputmask) {\r\n\t\t\t\t\t\treturn this.inputmask.opts.autoUnmask ?\r\n\t\t\t\t\t\t\tthis.inputmask.unmaskedvalue() :\r\n\t\t\t\t\t\t\t(getLastValidPosition() !== -1 || opts.nullable !== true ?\r\n\t\t\t\t\t\t\t\t(document.activeElement === this && opts.clearMaskOnLostFocus ?\r\n\t\t\t\t\t\t\t\t\t(isRTL ? clearOptionalTail(getBuffer().slice()).reverse() : clearOptionalTail(getBuffer().slice())).join(\"\") :\r\n\t\t\t\t\t\t\t\t\tvalueGet.call(this)) :\r\n\t\t\t\t\t\t\t\t\"\");\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn valueGet.call(this);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfunction setter(value) {\r\n\t\t\t\t\tvalueSet.call(this, value);\r\n\t\t\t\t\tif (this.inputmask) {\r\n\t\t\t\t\t\tapplyInputValue(this, value);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfunction installNativeValueSetFallback(npt) {\r\n\t\t\t\t\tEventRuler.on(npt, \"mouseenter\", function () {\r\n\t\t\t\t\t\tvar input = this,\r\n\t\t\t\t\t\t\tvalue = input.inputmask._valueGet(true);\r\n\t\t\t\t\t\tif (value !== (isRTL ? getBuffer().reverse() : getBuffer()).join(\"\")) { //Is this correct? to apply RTL? TOCHECK\r\n\t\t\t\t\t\t\tapplyInputValue(input, value);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!npt.inputmask.__valueGet) {\r\n\t\t\t\t\tif (opts.noValuePatching !== true) {\r\n\t\t\t\t\t\tif (Object.getOwnPropertyDescriptor) {\r\n\t\t\t\t\t\t\tif (typeof Object.getPrototypeOf !== \"function\") {\r\n\t\t\t\t\t\t\t\tObject.getPrototypeOf = typeof \"test\".__proto__ === \"object\" ? function (object) {\r\n\t\t\t\t\t\t\t\t\treturn object.__proto__;\r\n\t\t\t\t\t\t\t\t} : function (object) {\r\n\t\t\t\t\t\t\t\t\treturn object.constructor.prototype;\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tvar valueProperty = Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(npt), \"value\") : undefined;\r\n\t\t\t\t\t\t\tif (valueProperty && valueProperty.get && valueProperty.set) {\r\n\t\t\t\t\t\t\t\tvalueGet = valueProperty.get;\r\n\t\t\t\t\t\t\t\tvalueSet = valueProperty.set;\r\n\t\t\t\t\t\t\t\tObject.defineProperty(npt, \"value\", {\r\n\t\t\t\t\t\t\t\t\tget: getter,\r\n\t\t\t\t\t\t\t\t\tset: setter,\r\n\t\t\t\t\t\t\t\t\tconfigurable: true\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t} else if (npt.tagName !== \"INPUT\") {\r\n\t\t\t\t\t\t\t\tvalueGet = function () {\r\n\t\t\t\t\t\t\t\t\treturn this.textContent;\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t\tvalueSet = function (value) {\r\n\t\t\t\t\t\t\t\t\tthis.textContent = value;\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t\tObject.defineProperty(npt, \"value\", {\r\n\t\t\t\t\t\t\t\t\tget: getter,\r\n\t\t\t\t\t\t\t\t\tset: setter,\r\n\t\t\t\t\t\t\t\t\tconfigurable: true\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else if (document.__lookupGetter__ && npt.__lookupGetter__(\"value\")) {\r\n\t\t\t\t\t\t\tvalueGet = npt.__lookupGetter__(\"value\");\r\n\t\t\t\t\t\t\tvalueSet = npt.__lookupSetter__(\"value\");\r\n\r\n\t\t\t\t\t\t\tnpt.__defineGetter__(\"value\", getter);\r\n\t\t\t\t\t\t\tnpt.__defineSetter__(\"value\", setter);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tnpt.inputmask.__valueGet = valueGet; //store native property getter\r\n\t\t\t\t\t\tnpt.inputmask.__valueSet = valueSet; //store native property setter\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnpt.inputmask._valueGet = function (overruleRTL) {\r\n\t\t\t\t\t\treturn isRTL && overruleRTL !== true ? valueGet.call(this.el).split(\"\").reverse().join(\"\") : valueGet.call(this.el);\r\n\t\t\t\t\t};\r\n\t\t\t\t\tnpt.inputmask._valueSet = function (value, overruleRTL) { //null check is needed for IE8 => otherwise converts to \"null\"\r\n\t\t\t\t\t\tvalueSet.call(this.el, (value === null || value === undefined) ? \"\" : ((overruleRTL !== true && isRTL) ? value.split(\"\").reverse().join(\"\") : value));\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tif (valueGet === undefined) { //jquery.val fallback\r\n\t\t\t\t\t\tvalueGet = function () {\r\n\t\t\t\t\t\t\treturn this.value;\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\tvalueSet = function (value) {\r\n\t\t\t\t\t\t\tthis.value = value;\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\tpatchValhook(npt.type);\r\n\t\t\t\t\t\tinstallNativeValueSetFallback(npt);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar elementType = input.getAttribute(\"type\");\r\n\t\t\tvar isSupported = (input.tagName === \"INPUT\" && $.inArray(elementType, opts.supportsInputType) !== -1) || input.isContentEditable || input.tagName === \"TEXTAREA\";\r\n\t\t\tif (!isSupported) {\r\n\t\t\t\tif (input.tagName === \"INPUT\") {\r\n\t\t\t\t\tvar el = document.createElement(\"input\");\r\n\t\t\t\t\tel.setAttribute(\"type\", elementType);\r\n\t\t\t\t\tisSupported = el.type === \"text\"; //apply mask only if the type is not natively supported\r\n\t\t\t\t\tel = null;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tisSupported = \"partial\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (isSupported !== false) {\r\n\t\t\t\tpatchValueProperty(input);\r\n\t\t\t} else {\r\n\t\t\t\tinput.inputmask = undefined;\r\n\t\t\t}\r\n\t\t\treturn isSupported;\r\n\t\t}\r\n\r\n\t\t//unbind all events - to make sure that no other mask will interfere when re-masking\r\n\t\tEventRuler.off(elem);\r\n\t\tvar isSupported = isElementTypeSupported(elem, opts);\r\n\t\tif (isSupported !== false) {\r\n\t\t\tel = elem;\r\n\t\t\t$el = $(el);\r\n\r\n\t\t\toriginalPlaceholder = el.placeholder;\r\n\r\n\t\t\t//read maxlength prop from el\r\n\t\t\tmaxLength = el !== undefined ? el.maxLength : undefined;\r\n\t\t\tif (maxLength === -1) maxLength = undefined;\r\n\r\n\t\t\tif (opts.colorMask === true) {\r\n\t\t\t\tinitializeColorMask(el);\r\n\t\t\t}\r\n\t\t\tif (mobile) {\r\n\t\t\t\tif (\"inputmode\" in el) {\r\n\t\t\t\t\tel.inputmode = opts.inputmode;\r\n\t\t\t\t\tel.setAttribute(\"inputmode\", opts.inputmode);\r\n\t\t\t\t}\r\n\t\t\t\tif (opts.disablePredictiveText === true) {\r\n\t\t\t\t\tif (\"autocorrect\" in el) {  //safari\r\n\t\t\t\t\t\tel.autocorrect = false;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (opts.colorMask !== true) {\r\n\t\t\t\t\t\t\tinitializeColorMask(el);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tel.type = \"password\";\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (isSupported === true) {\r\n\t\t\t\tel.setAttribute(\"data-im-insert\", opts.insertMode);\r\n\r\n\t\t\t\t//bind events\r\n\t\t\t\tEventRuler.on(el, \"submit\", EventHandlers.submitEvent);\r\n\t\t\t\tEventRuler.on(el, \"reset\", EventHandlers.resetEvent);\r\n\t\t\t\tEventRuler.on(el, \"invalid\", EventHandlers.invalidEvent);\r\n\t\t\t\tEventRuler.on(el, \"blur\", EventHandlers.blurEvent);\r\n\t\t\t\tEventRuler.on(el, \"focus\", EventHandlers.focusEvent);\r\n\t\t\t\tif (opts.colorMask !== true) {\r\n\t\t\t\t\tEventRuler.on(el, \"click\", EventHandlers.clickEvent);\r\n\t\t\t\t\tEventRuler.on(el, \"mouseleave\", EventHandlers.mouseleaveEvent);\r\n\t\t\t\t\tEventRuler.on(el, \"mouseenter\", EventHandlers.mouseenterEvent);\r\n\t\t\t\t}\r\n\t\t\t\tEventRuler.on(el, \"paste\", EventHandlers.pasteEvent);\r\n\t\t\t\tEventRuler.on(el, \"cut\", EventHandlers.cutEvent);\r\n\t\t\t\tEventRuler.on(el, \"complete\", opts.oncomplete);\r\n\t\t\t\tEventRuler.on(el, \"incomplete\", opts.onincomplete);\r\n\t\t\t\tEventRuler.on(el, \"cleared\", opts.oncleared);\r\n\t\t\t\tif (!mobile && opts.inputEventOnly !== true) {\r\n\t\t\t\t\tEventRuler.on(el, \"keydown\", EventHandlers.keydownEvent);\r\n\t\t\t\t\tEventRuler.on(el, \"keypress\", EventHandlers.keypressEvent);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tel.removeAttribute(\"maxLength\");\r\n\t\t\t\t}\r\n\t\t\t\tEventRuler.on(el, \"input\", EventHandlers.inputFallBackEvent);\r\n\t\t\t\tEventRuler.on(el, \"beforeinput\", EventHandlers.beforeInputEvent); //https://github.com/w3c/input-events - to implement\r\n\t\t\t}\r\n\t\t\tEventRuler.on(el, \"setvalue\", EventHandlers.setValueEvent);\r\n\r\n\t\t\t//apply mask\r\n\t\t\tundoValue = getBufferTemplate().join(\"\"); //initialize the buffer and getmasklength\r\n\t\t\tif (el.inputmask._valueGet(true) !== \"\" || opts.clearMaskOnLostFocus === false || document.activeElement === el) {\r\n\t\t\t\tvar initialValue = $.isFunction(opts.onBeforeMask) ? (opts.onBeforeMask.call(inputmask, el.inputmask._valueGet(true), opts) || el.inputmask._valueGet(true)) : el.inputmask._valueGet(true);\r\n\t\t\t\tif (initialValue !== \"\") checkVal(el, true, false, initialValue.split(\"\"));\r\n\t\t\t\tvar buffer = getBuffer().slice();\r\n\t\t\t\tundoValue = buffer.join(\"\");\r\n\t\t\t\t// Wrap document.activeElement in a try/catch block since IE9 throw \"Unspecified error\" if document.activeElement is undefined when we are in an IFrame.\r\n\t\t\t\tif (isComplete(buffer) === false) {\r\n\t\t\t\t\tif (opts.clearIncomplete) {\r\n\t\t\t\t\t\tresetMaskSet();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (opts.clearMaskOnLostFocus && document.activeElement !== el) {\r\n\t\t\t\t\tif (getLastValidPosition() === -1) {\r\n\t\t\t\t\t\tbuffer = [];\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tclearOptionalTail(buffer);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (opts.clearMaskOnLostFocus === false || (opts.showMaskOnFocus && document.activeElement === el) || el.inputmask._valueGet(true) !== \"\") {\r\n\t\t\t\t\twriteBuffer(el, buffer);\r\n\t\t\t\t}\r\n\t\t\t\tif (document.activeElement === el) { //position the caret when in focus\r\n\t\t\t\t\tcaret(el, seekNext(getLastValidPosition()));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t//action object\r\n\tvar valueBuffer;\r\n\tif (actionObj !== undefined) {\r\n\t\tswitch (actionObj.action) {\r\n\t\t\tcase \"isComplete\":\r\n\t\t\t\tel = actionObj.el;\r\n\t\t\t\treturn isComplete(getBuffer());\r\n\t\t\tcase \"unmaskedvalue\":\r\n\t\t\t\tif (el === undefined || actionObj.value !== undefined) {\r\n\t\t\t\t\tvalueBuffer = actionObj.value;\r\n\t\t\t\t\tvalueBuffer = ($.isFunction(opts.onBeforeMask) ? (opts.onBeforeMask.call(inputmask, valueBuffer, opts) || valueBuffer) : valueBuffer).split(\"\");\r\n\t\t\t\t\tcheckVal.call(this, undefined, false, false, valueBuffer);\r\n\t\t\t\t\tif ($.isFunction(opts.onBeforeWrite)) opts.onBeforeWrite.call(inputmask, undefined, getBuffer(), 0, opts);\r\n\t\t\t\t}\r\n\t\t\t\treturn unmaskedvalue(el);\r\n\t\t\tcase \"mask\":\r\n\t\t\t\tmask(el);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"format\":\r\n\t\t\t\tvalueBuffer = ($.isFunction(opts.onBeforeMask) ? (opts.onBeforeMask.call(inputmask, actionObj.value, opts) || actionObj.value) : actionObj.value).split(\"\");\r\n\t\t\t\tcheckVal.call(this, undefined, true, false, valueBuffer);\r\n\t\t\t\tif (actionObj.metadata) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tvalue: isRTL ? getBuffer().slice().reverse().join(\"\") : getBuffer().join(\"\"),\r\n\t\t\t\t\t\tmetadata: maskScope.call(this, {\r\n\t\t\t\t\t\t\t\"action\": \"getmetadata\"\r\n\t\t\t\t\t\t}, maskset, opts)\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn isRTL ? getBuffer().slice().reverse().join(\"\") : getBuffer().join(\"\");\r\n\t\t\tcase \"isValid\":\r\n\t\t\t\tif (actionObj.value) {\r\n\t\t\t\t\tvalueBuffer = actionObj.value.split(\"\");\r\n\t\t\t\t\tcheckVal.call(this, undefined, true, false, valueBuffer);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tactionObj.value = isRTL ? getBuffer().slice().reverse().join(\"\") : getBuffer().join(\"\");\r\n\t\t\t\t}\r\n\t\t\t\tvar buffer = getBuffer();\r\n\t\t\t\tvar rl = determineLastRequiredPosition(),\r\n\t\t\t\t\tlmib = buffer.length - 1;\r\n\t\t\t\tfor (; lmib > rl; lmib--) {\r\n\t\t\t\t\tif (isMask(lmib)) break;\r\n\t\t\t\t}\r\n\t\t\t\tbuffer.splice(rl, lmib + 1 - rl);\r\n\r\n\t\t\t\treturn isComplete(buffer) && actionObj.value === (isRTL ? getBuffer().slice().reverse().join(\"\") : getBuffer().join(\"\"));\r\n\t\t\tcase \"getemptymask\":\r\n\t\t\t\treturn getBufferTemplate().join(\"\");\r\n\t\t\tcase \"remove\":\r\n\t\t\t\tif (el && el.inputmask) {\r\n\t\t\t\t\t$.data(el, \"_inputmask_opts\", null); //invalidate\r\n\t\t\t\t\t$el = $(el);\r\n\t\t\t\t\t//writeout the value\r\n\t\t\t\t\tvar cv = opts.autoUnmask ? unmaskedvalue(el) : el.inputmask._valueGet(opts.autoUnmask);\r\n\t\t\t\t\tif (cv !== getBufferTemplate().join(\"\")) el.inputmask._valueSet(cv, opts.autoUnmask); else el.inputmask._valueSet(\"\");\r\n\t\t\t\t\t//unbind all events\r\n\t\t\t\t\tEventRuler.off(el);\r\n\t\t\t\t\t//remove colormask if used\r\n\t\t\t\t\tif (el.inputmask.colorMask) {\r\n\t\t\t\t\t\tcolorMask = el.inputmask.colorMask;\r\n\t\t\t\t\t\tcolorMask.removeChild(el);\r\n\t\t\t\t\t\tcolorMask.parentNode.insertBefore(el, colorMask);\r\n\t\t\t\t\t\tcolorMask.parentNode.removeChild(colorMask);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//restore the value property\r\n\t\t\t\t\tvar valueProperty;\r\n\t\t\t\t\tif (Object.getOwnPropertyDescriptor && Object.getPrototypeOf) {\r\n\t\t\t\t\t\tvalueProperty = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(el), \"value\");\r\n\t\t\t\t\t\tif (valueProperty) {\r\n\t\t\t\t\t\t\tif (el.inputmask.__valueGet) {\r\n\t\t\t\t\t\t\t\tObject.defineProperty(el, \"value\", {\r\n\t\t\t\t\t\t\t\t\tget: el.inputmask.__valueGet,\r\n\t\t\t\t\t\t\t\t\tset: el.inputmask.__valueSet,\r\n\t\t\t\t\t\t\t\t\tconfigurable: true\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (document.__lookupGetter__ && el.__lookupGetter__(\"value\")) {\r\n\t\t\t\t\t\tif (el.inputmask.__valueGet) {\r\n\t\t\t\t\t\t\tel.__defineGetter__(\"value\", el.inputmask.__valueGet);\r\n\t\t\t\t\t\t\tel.__defineSetter__(\"value\", el.inputmask.__valueSet);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//clear data\r\n\t\t\t\t\tel.inputmask = undefined;\r\n\t\t\t\t}\r\n\t\t\t\treturn el;\r\n\t\t\tcase \"getmetadata\":\r\n\t\t\t\tif ($.isArray(maskset.metadata)) {\r\n\t\t\t\t\tvar maskTarget = getMaskTemplate(true, 0, false).join(\"\");\r\n\t\t\t\t\t$.each(maskset.metadata, function (ndx, mtdt) {\r\n\t\t\t\t\t\tif (mtdt.mask === maskTarget) {\r\n\t\t\t\t\t\t\tmaskTarget = mtdt;\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t\treturn maskTarget;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn maskset.metadata;\r\n\t\t}\r\n\t}\r\n};\r\n\r\n","/*\r\n Input Mask plugin extensions\r\n http://github.com/RobinHerbots/jquery.inputmask\r\n Copyright (c) Robin Herbots\r\n Licensed under the MIT license\r\n */\r\nvar Inputmask = require(\"../inputmask\"), $ = Inputmask.dependencyLib,\r\n\t//supported codes for formatting\r\n\t//http://blog.stevenlevithan.com/archives/date-time-format\r\n\t//https://docs.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings?view=netframework-4.7\r\n\tformatCode = { //regex, valueSetter, type, displayformatter\r\n\t\td: [\"[1-9]|[12][0-9]|3[01]\", Date.prototype.setDate, \"day\", Date.prototype.getDate], //Day of the month as digits; no leading zero for single-digit days.\r\n\t\tdd: [\"0[1-9]|[12][0-9]|3[01]\", Date.prototype.setDate, \"day\", function () {\r\n\t\t\treturn pad(Date.prototype.getDate.call(this), 2);\r\n\t\t}], //Day of the month as digits; leading zero for single-digit days.\r\n\t\tddd: [\"\"], //Day of the week as a three-letter abbreviation.\r\n\t\tdddd: [\"\"], //Day of the week as its full name.\r\n\t\tm: [\"[1-9]|1[012]\", Date.prototype.setMonth, \"month\", function () {\r\n\t\t\treturn Date.prototype.getMonth.call(this) + 1;\r\n\t\t}], //Month as digits; no leading zero for single-digit months.\r\n\t\tmm: [\"0[1-9]|1[012]\", Date.prototype.setMonth, \"month\", function () {\r\n\t\t\treturn pad(Date.prototype.getMonth.call(this) + 1, 2);\r\n\t\t}], //Month as digits; leading zero for single-digit months.\r\n\t\tmmm: [\"\"], //Month as a three-letter abbreviation.\r\n\t\tmmmm: [\"\"], //Month as its full name.\r\n\t\tyy: [\"[0-9]{2}\", Date.prototype.setFullYear, \"year\", function () {\r\n\t\t\treturn pad(Date.prototype.getFullYear.call(this), 2);\r\n\t\t}], //Year as last two digits; leading zero for years less than 10.\r\n\t\tyyyy: [\"[0-9]{4}\", Date.prototype.setFullYear, \"year\", function () {\r\n\t\t\treturn pad(Date.prototype.getFullYear.call(this), 4);\r\n\t\t}],\r\n\t\th: [\"[1-9]|1[0-2]\", Date.prototype.setHours, \"hours\", Date.prototype.getHours], //Hours; no leading zero for single-digit hours (12-hour clock).\r\n\t\thh: [\"0[1-9]|1[0-2]\", Date.prototype.setHours, \"hours\", function () {\r\n\t\t\treturn pad(Date.prototype.getHours.call(this), 2);\r\n\t\t}], //Hours; leading zero for single-digit hours (12-hour clock).\r\n\t\thhh: [\"[0-9]+\", Date.prototype.setHours, \"hours\", Date.prototype.getHours], //Hours; no limit\r\n\t\tH: [\"1?[0-9]|2[0-3]\", Date.prototype.setHours, \"hours\", Date.prototype.getHours], //Hours; no leading zero for single-digit hours (24-hour clock).\r\n\t\tHH: [\"0[0-9]|1[0-9]|2[0-3]\", Date.prototype.setHours, \"hours\", function () {\r\n\t\t\treturn pad(Date.prototype.getHours.call(this), 2);\r\n\t\t}], //Hours; leading zero for single-digit hours (24-hour clock).\r\n\t\tHHH: [\"[0-9]+\", Date.prototype.setHours, \"hours\", Date.prototype.getHours], //Hours; no limit\r\n\t\tM: [\"[1-5]?[0-9]\", Date.prototype.setMinutes, \"minutes\", Date.prototype.getMinutes], //Minutes; no leading zero for single-digit minutes. Uppercase M unlike CF timeFormat's m to avoid conflict with months.\r\n\t\tMM: [\"0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]\", Date.prototype.setMinutes, \"minutes\", function () {\r\n\t\t\treturn pad(Date.prototype.getMinutes.call(this), 2);\r\n\t\t}], //Minutes; leading zero for single-digit minutes. Uppercase MM unlike CF timeFormat's mm to avoid conflict with months.\r\n\t\ts: [\"[1-5]?[0-9]\", Date.prototype.setSeconds, \"seconds\", Date.prototype.getSeconds], //Seconds; no leading zero for single-digit seconds.\r\n\t\tss: [\"0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]\", Date.prototype.setSeconds, \"seconds\", function () {\r\n\t\t\treturn pad(Date.prototype.getSeconds.call(this), 2);\r\n\t\t}], //Seconds; leading zero for single-digit seconds.\r\n\t\tl: [\"[0-9]{3}\", Date.prototype.setMilliseconds, \"milliseconds\", function () {\r\n\t\t\treturn pad(Date.prototype.getMilliseconds.call(this), 3);\r\n\t\t}], //Milliseconds. 3 digits.\r\n\t\tL: [\"[0-9]{2}\", Date.prototype.setMilliseconds, \"milliseconds\", function () {\r\n\t\t\treturn pad(Date.prototype.getMilliseconds.call(this), 2);\r\n\t\t}], //Milliseconds. 2 digits.\r\n\t\tt: [\"[ap]\"], //Lowercase, single-character time marker string: a or p.\r\n\t\ttt: [\"[ap]m\"], //two-character time marker string: am or pm.\r\n\t\tT: [\"[AP]\"], //single-character time marker string: A or P.\r\n\t\tTT: [\"[AP]M\"], //two-character time marker string: AM or PM.\r\n\t\tZ: [\"\"], //US timezone abbreviation, e.g. EST or MDT. With non-US timezones or in the Opera browser, the GMT/UTC offset is returned, e.g. GMT-0500\r\n\t\to: [\"\"], //GMT/UTC timezone offset, e.g. -0500 or +0230.\r\n\t\tS: [\"\"] //The date's ordinal suffix (st, nd, rd, or th).\r\n\t},\r\n\tformatAlias = {\r\n\t\tisoDate: \"yyyy-mm-dd\", //2007-06-09\r\n\t\tisoTime: \"HH:MM:ss\", //17:46:21\r\n\t\tisoDateTime: \"yyyy-mm-dd'T'HH:MM:ss\", //2007-06-09T17:46:21\r\n\t\tisoUtcDateTime: \"UTC:yyyy-mm-dd'T'HH:MM:ss'Z'\" //2007-06-09T22:46:21Z\r\n\t};\r\n\r\nfunction getTokenizer(opts) {\r\n\tif (!opts.tokenizer) {\r\n\t\tvar tokens = [];\r\n\t\tfor (var ndx in formatCode) {\r\n\t\t\tif (tokens.indexOf(ndx[0]) === -1) {\r\n\t\t\t\ttokens.push(ndx[0]);\r\n\t\t\t}\r\n\t\t}\r\n\t\topts.tokenizer = \"(\" + tokens.join(\"+|\") + \")+?|.\";\r\n\t\topts.tokenizer = new RegExp(opts.tokenizer, \"g\");\r\n\t}\r\n\r\n\treturn opts.tokenizer;\r\n}\r\n\r\nfunction isValidDate(dateParts, currentResult) {\r\n\treturn !isFinite(dateParts.rawday)\r\n\t|| (dateParts.day == \"29\" && !isFinite(dateParts.rawyear))\r\n\t|| new Date(dateParts.date.getFullYear(), isFinite(dateParts.rawmonth) ? dateParts.month : dateParts.date.getMonth() + 1, 0).getDate() >= dateParts.day\r\n\t\t? currentResult\r\n\t\t: false; //take corrective action if possible\r\n}\r\n\r\nfunction isDateInRange(dateParts, opts) {\r\n\tvar result = true;\r\n\tif (opts.min) {\r\n\t\tif (dateParts[\"rawyear\"]) {\r\n\t\t\tvar rawYear = dateParts[\"rawyear\"].replace(/[^0-9]/g, \"\"),\r\n\t\t\t\tminYear = opts.min.year.substr(0, rawYear.length);\r\n\t\t\tresult = minYear <= rawYear;\r\n\t\t}\r\n\t\tif (dateParts[\"year\"] === dateParts[\"rawyear\"]) {\r\n\t\t\tif (opts.min.date.getTime() === opts.min.date.getTime()) {\r\n\t\t\t\tresult = opts.min.date.getTime() <= dateParts.date.getTime();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (result && opts.max && opts.max.date.getTime() === opts.max.date.getTime()) {\r\n\t\tresult = opts.max.date.getTime() >= dateParts.date.getTime();\r\n\t}\r\n\treturn result;\r\n}\r\n\r\n//parse the given format and return a mask pattern\r\n//when a dateObjValue is passed a datestring in the requested format is returned\r\nfunction parse(format, dateObjValue, opts, raw) {\r\n\t//parse format to regex string\r\n\tvar mask = \"\", match;\r\n\twhile ((match = getTokenizer(opts).exec(format))) {\r\n\t\tif (dateObjValue === undefined) {\r\n\t\t\tif (formatCode[match[0]]) {\r\n\t\t\t\tmask += \"(\" + formatCode[match[0]][0] + \")\";\r\n\t\t\t} else {\r\n\t\t\t\tswitch (match[0]) {\r\n\t\t\t\t\tcase \"[\":\r\n\t\t\t\t\t\tmask += \"(\";\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"]\":\r\n\t\t\t\t\t\tmask += \")?\";\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tmask += Inputmask.escapeRegex(match[0]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (formatCode[match[0]]) {\r\n\t\t\t\tif (raw !== true && formatCode[match[0]][3]) {\r\n\t\t\t\t\tvar getFn = formatCode[match[0]][3];\r\n\t\t\t\t\tmask += getFn.call(dateObjValue.date);\r\n\t\t\t\t} else if (formatCode[match[0]][2]) {\r\n\t\t\t\t\tmask += dateObjValue[\"raw\" + formatCode[match[0]][2]];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tmask += match[0];\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tmask += match[0];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn mask;\r\n}\r\n\r\n//padding function\r\nfunction pad(val, len) {\r\n\tval = String(val);\r\n\tlen = len || 2;\r\n\twhile (val.length < len) val = \"0\" + val;\r\n\treturn val;\r\n}\r\n\r\nfunction analyseMask(maskString, format, opts) {\r\n\tvar dateObj = {\"date\": new Date(1, 0, 1)}, targetProp, mask = maskString, match, dateOperation;\r\n\r\n\tfunction extendProperty(value) {\r\n\t\tvar correctedValue = value.replace(/[^0-9]/g, \"0\");\r\n\t\t// if (correctedValue != value) { //only do correction on incomplete values\r\n\t\t//     //determine best validation match\r\n\t\t//     var enteredPart = value.replace(/[^0-9]/g, \"\"),\r\n\t\t//         enteredPartIndex = value.indexOf(enteredPart),\r\n\t\t//         minPart = (opts.min && opts.min[targetProp] || value).slice(enteredPartIndex, enteredPartIndex + enteredPart.length),\r\n\t\t//         maxPart = (opts.max && opts.max[targetProp] || value).slice(enteredPartIndex, enteredPartIndex + enteredPart.length),\r\n\t\t//         correctedPart = enteredPart < minPart ? minPart : (enteredPart > maxPart ? maxPart : correctedValue.slice(enteredPartIndex, enteredPartIndex + enteredPart.length));\r\n\t\t//     correctedValue = correctedValue.split(\"\");\r\n\t\t//     correctedValue.splice(enteredPartIndex, 1, correctedPart);\r\n\t\t//     correctedValue = correctedValue.join(\"\");\r\n\t\t// }\r\n\t\treturn correctedValue;\r\n\t}\r\n\r\n\tfunction setValue(dateObj, value, opts) {\r\n\t\tdateObj[targetProp] = extendProperty(value);\r\n\t\tdateObj[\"raw\" + targetProp] = value;\r\n\r\n\t\tif (dateOperation !== undefined) {\r\n\t\t\tdateOperation.call(dateObj.date, targetProp == \"month\" ? parseInt(dateObj[targetProp]) - 1 : dateObj[targetProp]);\r\n\t\t}\r\n\t}\r\n\r\n\tif (typeof mask === \"string\") {\r\n\t\twhile ((match = getTokenizer(opts).exec(format))) {\r\n\t\t\tvar value = mask.slice(0, match[0].length);\r\n\t\t\tif (formatCode.hasOwnProperty(match[0])) {\r\n\t\t\t\t// targetValidator = formatCode[match[0]][0];\r\n\t\t\t\ttargetProp = formatCode[match[0]][2];\r\n\t\t\t\tdateOperation = formatCode[match[0]][1];\r\n\t\t\t\tsetValue(dateObj, value, opts);\r\n\t\t\t}\r\n\t\t\tmask = mask.slice(value.length);\r\n\t\t}\r\n\r\n\t\treturn dateObj;\r\n\t} else if (mask && typeof mask === \"object\" && mask.hasOwnProperty(\"date\")) {\r\n\t\treturn mask;\r\n\t}\r\n\treturn undefined;\r\n}\r\n\r\nInputmask.extendAliases({\r\n\t\"datetime\": {\r\n\t\tmask: function (opts) {\r\n\t\t\t//localize\r\n\t\t\tformatCode.S = opts.i18n.ordinalSuffix.join(\"|\");\r\n\r\n\t\t\topts.inputFormat = formatAlias[opts.inputFormat] || opts.inputFormat; //resolve possible formatAlias\r\n\t\t\topts.displayFormat = formatAlias[opts.displayFormat] || opts.displayFormat || opts.inputFormat; //resolve possible formatAlias\r\n\t\t\topts.outputFormat = formatAlias[opts.outputFormat] || opts.outputFormat || opts.inputFormat; //resolve possible formatAlias\r\n\t\t\topts.placeholder = opts.placeholder !== \"\" ? opts.placeholder : opts.inputFormat.replace(/[[\\]]/, \"\");\r\n\t\t\topts.regex = parse(opts.inputFormat, undefined, opts);\r\n\t\t\t// console.log(opts.regex);\r\n\t\t\treturn null; //migrate to regex mask\r\n\t\t},\r\n\t\tplaceholder: \"\", //set default as none (~ auto); when a custom placeholder is passed it will be used\r\n\t\tinputFormat: \"isoDateTime\", //format used to input the date\r\n\t\tdisplayFormat: undefined, //visual format when the input looses focus\r\n\t\toutputFormat: undefined, //unmasking format\r\n\t\tmin: null, //needs to be in the same format as the inputfornat\r\n\t\tmax: null, //needs to be in the same format as the inputfornat,\r\n\t\t// Internationalization strings\r\n\t\ti18n: {\r\n\t\t\tdayNames: [\r\n\t\t\t\t\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\",\r\n\t\t\t\t\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"\r\n\t\t\t],\r\n\t\t\tmonthNames: [\r\n\t\t\t\t\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\",\r\n\t\t\t\t\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"\r\n\t\t\t],\r\n\t\t\tordinalSuffix: [\"st\", \"nd\", \"rd\", \"th\"]\r\n\t\t},\r\n\t\tpreValidation: function (buffer, pos, c, isSelection, opts, maskset) {\r\n\t\t\tvar calcPos = 0, targetMatch, match;\r\n\t\t\tif (isNaN(c) && buffer[pos] !== c) {\r\n\t\t\t\twhile ((match = getTokenizer(opts).exec(opts.inputFormat))) {\r\n\t\t\t\t\tcalcPos += match[0].length;\r\n\t\t\t\t\tif (calcPos >= pos) {\r\n\t\t\t\t\t\ttargetMatch = match;\r\n\t\t\t\t\t\tmatch = getTokenizer(opts).exec(opts.inputFormat);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (match && match[0] === c && targetMatch[0].length > 1) {\r\n\t\t\t\t\tbuffer[pos] = buffer[pos - 1];\r\n\t\t\t\t\tbuffer[pos - 1] = \"0\";\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tfuzzy: true,\r\n\t\t\t\t\t\tbuffer: buffer,\r\n\t\t\t\t\t\trefreshFromBuffer: {start: pos - 1, end: pos + 1},\r\n\t\t\t\t\t\tpos: pos + 1\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t},\r\n\t\tpostValidation: function (buffer, pos, currentResult, opts) {\r\n\t\t\topts.min = analyseMask(opts.min, opts.inputFormat, opts);\r\n\t\t\topts.max = analyseMask(opts.max, opts.inputFormat, opts);\r\n\r\n\t\t\tif (currentResult.fuzzy) {\r\n\t\t\t\tbuffer = currentResult.buffer;\r\n\t\t\t\tpos = currentResult.pos;\r\n\t\t\t}\r\n\r\n\t\t\tvar result = currentResult, dateParts = analyseMask(buffer.join(\"\"), opts.inputFormat, opts);\r\n\t\t\tif (result && dateParts.date.getTime() === dateParts.date.getTime()) { //check for a valid date ~ an invalid date returns NaN which isn't equal\r\n\t\t\t\tresult = isValidDate(dateParts, result);\r\n\t\t\t\tresult = result && isDateInRange(dateParts, opts);\r\n\t\t\t}\r\n\r\n\t\t\tif (pos && result && currentResult.pos !== pos) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tbuffer: parse(opts.inputFormat, dateParts, opts),\r\n\t\t\t\t\trefreshFromBuffer: {start: pos, end: currentResult.pos}\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\t\t},\r\n\t\tonKeyDown: function (e, buffer, caretPos, opts) {\r\n\t\t\tvar input = this;\r\n\t\t\tif (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {\r\n\t\t\t\tvar today = new Date(), match, date = \"\";\r\n\r\n\t\t\t\twhile ((match = getTokenizer(opts).exec(opts.inputFormat))) {\r\n\t\t\t\t\tif (match[0].charAt(0) === \"d\") {\r\n\t\t\t\t\t\tdate += pad(today.getDate(), match[0].length);\r\n\t\t\t\t\t} else if (match[0].charAt(0) === \"m\") {\r\n\t\t\t\t\t\tdate += pad((today.getMonth() + 1), match[0].length);\r\n\t\t\t\t\t} else if (match[0] === \"yyyy\") {\r\n\t\t\t\t\t\tdate += today.getFullYear().toString();\r\n\t\t\t\t\t} else if (match[0].charAt(0) === \"y\") {\r\n\t\t\t\t\t\tdate += pad(today.getYear(), match[0].length);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tinput.inputmask._valueSet(date);\r\n\t\t\t\t$(input).trigger(\"setvalue\");\r\n\t\t\t}\r\n\t\t},\r\n\t\tonUnMask: function (maskedValue, unmaskedValue, opts) {\r\n\t\t\treturn unmaskedValue ? parse(opts.outputFormat, analyseMask(maskedValue, opts.inputFormat, opts), opts, true) : unmaskedValue;\r\n\t\t},\r\n\t\tcasing: function (elem, test, pos, validPositions) {\r\n\t\t\tif (test.nativeDef.indexOf(\"[ap]\") == 0) return elem.toLowerCase();\r\n\t\t\tif (test.nativeDef.indexOf(\"[AP]\") == 0) return elem.toUpperCase();\r\n\t\t\treturn elem;\r\n\t\t},\r\n\t\tinsertMode: false,\r\n\t\tshiftPositions: false\r\n\t}\r\n});\r\n\r\nmodule.exports = Inputmask;\r\n","/*\r\n Input Mask plugin extensions\r\n http://github.com/RobinHerbots/jquery.inputmask\r\n Copyright (c) Robin Herbots\r\n Licensed under the MIT license\r\n */\r\nvar Inputmask = require(\"../inputmask\"), $ = Inputmask.dependencyLib;\r\n\r\nfunction autoEscape(txt, opts) {\r\n\tvar escapedTxt = \"\";\r\n\tfor (var i = 0; i < txt.length; i++) {\r\n\t\tif (Inputmask.prototype.definitions[txt.charAt(i)] ||\r\n\t\t\topts.definitions[txt.charAt(i)] ||\r\n\t\t\topts.optionalmarker.start === txt.charAt(i) ||\r\n\t\t\topts.optionalmarker.end === txt.charAt(i) ||\r\n\t\t\topts.quantifiermarker.start === txt.charAt(i) ||\r\n\t\t\topts.quantifiermarker.end === txt.charAt(i) ||\r\n\t\t\topts.groupmarker.start === txt.charAt(i) ||\r\n\t\t\topts.groupmarker.end === txt.charAt(i) ||\r\n\t\t\topts.alternatormarker === txt.charAt(i)) {\r\n\t\t\tescapedTxt += \"\\\\\" + txt.charAt(i);\r\n\t\t} else {\r\n\t\t\tescapedTxt += txt.charAt(i);\r\n\t\t}\r\n\t}\r\n\treturn escapedTxt;\r\n}\r\n\r\nfunction alignDigits(buffer, digits, opts) {\r\n\tif (digits > 0 && !opts.digitsOptional && buffer.length > 0) {\r\n\t\tvar radixPosition = $.inArray(opts.radixPoint, buffer);\r\n\t\tif (radixPosition === -1) {\r\n\t\t\tbuffer.push(opts.radixPoint);\r\n\t\t\tradixPosition = buffer.length - 1;\r\n\t\t}\r\n\t\tfor (var i = 1; i <= digits; i++) {\r\n\t\t\tbuffer[radixPosition + i] = buffer[radixPosition + i] || \"0\";\r\n\t\t}\r\n\t}\r\n\treturn buffer;\r\n}\r\n\r\nfunction findValidator(symbol, maskset) {\r\n\tvar posNdx = 0;\r\n\tfor (posNdx in maskset.validPositions) ;\r\n\tposNdx = parseInt(posNdx);\r\n\tfor (var tstNdx in maskset.tests) {\r\n\t\ttstNdx = parseInt(tstNdx);\r\n\t\tif (tstNdx >= posNdx) {\r\n\t\t\tfor (var ndx = 0, ndxl = maskset.tests[tstNdx].length; ndx < ndxl; ndx++) {\r\n\t\t\t\tif (maskset.validPositions[tstNdx] === undefined && maskset.tests[tstNdx][ndx].match.def === symbol) {\r\n\t\t\t\t\treturn tstNdx + (maskset.validPositions[tstNdx] !== undefined ? 1 : 0);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn posNdx;\r\n}\r\n\r\nfunction findValid(symbol, maskset) {\r\n\tvar ret = -1;\r\n\t$.each(maskset.validPositions, function (ndx, tst) {\r\n\t\tif (tst.match.def === symbol) {\r\n\t\t\tret = parseInt(ndx);\r\n\t\t\treturn false;\r\n\t\t}\r\n\t});\r\n\treturn ret;\r\n}\r\n\r\nfunction parseMinMaxOptions(opts) {\r\n\tif (opts.parseMinMaxOptions === undefined) {\r\n\t\t// convert min and max options\r\n\t\tif (opts.min !== null) {\r\n\t\t\topts.min = opts.min.toString().replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), \"g\"), \"\");\r\n\t\t\tif (opts.radixPoint === \",\") opts.min = opts.min.replace(opts.radixPoint, \".\");\r\n\t\t\topts.min = isFinite(opts.min) ? parseFloat(opts.min) : NaN;\r\n\t\t\tif (isNaN(opts.min)) opts.min = Number.MIN_VALUE;\r\n\t\t}\r\n\t\tif (opts.max !== null) {\r\n\t\t\topts.max = opts.max.toString().replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), \"g\"), \"\");\r\n\t\t\tif (opts.radixPoint === \",\") opts.max = opts.max.replace(opts.radixPoint, \".\");\r\n\t\t\topts.max = isFinite(opts.max) ? parseFloat(opts.max) : NaN;\r\n\t\t\tif (isNaN(opts.max)) opts.max = Number.MAX_VALUE;\r\n\t\t}\r\n\t\topts.parseMinMaxOptions = \"done\";\r\n\t}\r\n}\r\n\r\nfunction genMask(opts) {\r\n\topts.repeat = 0;\r\n\t//treat equal separator and radixpoint\r\n\tif (opts.groupSeparator === opts.radixPoint && opts.digits && opts.digits !== \"0\") {\r\n\t\tif (opts.radixPoint === \".\") {\r\n\t\t\topts.groupSeparator = \",\";\r\n\t\t} else if (opts.radixPoint === \",\") {\r\n\t\t\topts.groupSeparator = \".\";\r\n\t\t} else {\r\n\t\t\topts.groupSeparator = \"\";\r\n\t\t}\r\n\t}\r\n\t//prevent conflict with default skipOptionalPartCharacter\r\n\tif (opts.groupSeparator === \" \") {\r\n\t\topts.skipOptionalPartCharacter = undefined;\r\n\t}\r\n\r\n\t//enforce placeholder to single\r\n\tif (opts.placeholder.length > 1) {\r\n\t\topts.placeholder = opts.placeholder.charAt(0);\r\n\t}\r\n\t//only allow radixfocus when placeholder = 0\r\n\tif (opts.positionCaretOnClick === \"radixFocus\" && opts.placeholder === \"\") {\r\n\t\topts.positionCaretOnClick = \"lvp\";\r\n\t}\r\n\r\n\tvar decimalDef = \"0\";\r\n\tif (opts.numericInput === true && opts.__financeInput === undefined) { //finance people input style\r\n\t\tdecimalDef = \"1\";\r\n\t\topts.positionCaretOnClick = opts.positionCaretOnClick === \"radixFocus\" ? \"lvp\" : opts.positionCaretOnClick;\r\n\t\t// opts.digitsOptional = false;\r\n\t\tif (isNaN(opts.digits)) opts.digits = 2;\r\n\t\topts._radixDance = false;\r\n\t} else {\r\n\t\topts.__financeInput = false; //needed to keep original selection when remasking\r\n\t\topts.numericInput = true;\r\n\t}\r\n\r\n\tvar mask = \"[+]\", altMask;\r\n\tmask += autoEscape(opts.prefix, opts);\r\n\tif (opts.groupSeparator !== \"\") {\r\n\t\tmask += opts._mask(opts);\r\n\t} else {\r\n\t\tmask += \"9{+}\";\r\n\t}\r\n\tif (opts.digits !== undefined) {\r\n\t\tvar dq = opts.digits.toString().split(\",\");\r\n\t\tif (isFinite(dq[0]) && dq[1] && isFinite(dq[1])) {\r\n\t\t\tmask += opts.radixPoint + decimalDef + \"{\" + opts.digits + \"}\";\r\n\t\t} else if (isNaN(opts.digits) || parseInt(opts.digits) > 0) {\r\n\t\t\tif (opts.digitsOptional) {\r\n\t\t\t\taltMask = mask + opts.radixPoint + decimalDef + \"{0,\" + opts.digits + \"}\";\r\n\t\t\t\t// mask += \"[\" + opts.radixPoint + \"]\";\r\n\t\t\t\topts.keepStatic = true;\r\n\t\t\t} else {\r\n\t\t\t\tmask += opts.radixPoint + decimalDef + \"{\" + opts.digits + \"}\";\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tmask += autoEscape(opts.suffix, opts);\r\n\tmask += \"[-]\";\r\n\r\n\tif (altMask) {\r\n\t\tmask = [(altMask + autoEscape(opts.suffix, opts) + \"[-]\"), mask];\r\n\t}\r\n\r\n\r\n\topts.greedy = false; //enforce greedy false\r\n\r\n\tparseMinMaxOptions(opts);\r\n\treturn mask;\r\n}\r\n\r\nfunction hanndleRadixDance(pos, c, radixPos, opts) {\r\n\tif (opts._radixDance && opts.numericInput) {\r\n\t\tif (pos <= radixPos && (radixPos > 0 || c == opts.radixPoint)) {\r\n\t\t\tpos -= 1;\r\n\t\t}\r\n\t}\r\n\treturn pos;\r\n}\r\n\r\nfunction decimalValidator(chrs, maskset, pos, strict, opts) {\r\n\tvar radixPos = maskset.buffer.indexOf(opts.radixPoint),\r\n\t\tresult = radixPos !== -1 && new RegExp(\"[0-9\\uFF11-\\uFF19]\").test(chrs);\r\n\tif (opts._radixDance && result && maskset.validPositions[radixPos] == undefined) {\r\n\t\treturn {\r\n\t\t\tinsert: {\r\n\t\t\t\tpos: radixPos === pos ? radixPos + 1 : radixPos,\r\n\t\t\t\tc: opts.radixPoint\r\n\t\t\t},\r\n\t\t\tpos: pos\r\n\t\t};\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\n//number aliases\r\nInputmask.extendAliases({\r\n\t\"numeric\": {\r\n\t\tmask: genMask,\r\n\t\t_mask: function (opts) {\r\n\t\t\treturn \"(\" + opts.groupSeparator + \"999){+|1}\";\r\n\t\t},\r\n\t\tplaceholder: \"0\",\r\n\t\tgreedy: false,\r\n\t\tdigits: \"*\", //number of fractionalDigits\r\n\t\tdigitsOptional: true,\r\n\t\tenforceDigitsOnBlur: false,\r\n\t\tradixPoint: \".\",\r\n\t\tpositionCaretOnClick: \"radixFocus\",\r\n\t\t_radixDance: true,\r\n\t\tgroupSeparator: \"\",\r\n\t\tallowMinus: true,\r\n\t\tnegationSymbol: {\r\n\t\t\tfront: \"-\", //\"(\"\r\n\t\t\tback: \"\" //\")\"\r\n\t\t},\r\n\t\tprefix: \"\",\r\n\t\tsuffix: \"\",\r\n\t\trightAlign: true,\r\n\t\tmin: null, //minimum value\r\n\t\tmax: null, //maximum value\r\n\t\tstep: 1,\r\n\t\tinsertMode: true,\r\n\t\tautoUnmask: false,\r\n\t\tunmaskAsNumber: false,\r\n\t\tinputmode: \"numeric\",\r\n\t\tdefinitions: {\r\n\t\t\t\"0\": {\r\n\t\t\t\tvalidator: decimalValidator\r\n\t\t\t},\r\n\t\t\t\"1\": {\r\n\t\t\t\tvalidator: decimalValidator,\r\n\t\t\t\tdefinitionSymbol: \"*\"\r\n\t\t\t},\r\n\t\t\t\"+\": {\r\n\t\t\t\tvalidator: function (chrs, maskset, pos, strict, opts) {\r\n\t\t\t\t\treturn (opts.allowMinus && (chrs === \"-\" || chrs === opts.negationSymbol.front));\r\n\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t\"-\": {\r\n\t\t\t\tvalidator: function (chrs, maskset, pos, strict, opts) {\r\n\t\t\t\t\treturn (opts.allowMinus && chrs === opts.negationSymbol.back);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tpreValidation: function (buffer, pos, c, isSelection, opts, maskset) {\r\n\t\t\tvar radixPos = $.inArray(opts.radixPoint, buffer);\r\n\t\t\tpos = hanndleRadixDance(pos, c, radixPos, opts);\r\n\t\t\tif (c === \"-\" || c === opts.negationSymbol.front) {\r\n\t\t\t\tif (opts.allowMinus !== true) return false;\r\n\t\t\t\tvar isNegative = false,\r\n\t\t\t\t\tfront = findValid(\"+\", maskset), back = findValid(\"-\", maskset);\r\n\t\t\t\tif (front !== -1) {\r\n\t\t\t\t\tisNegative = [front, back];\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn isNegative !== false ? {\r\n\t\t\t\t\tremove: isNegative,\r\n\t\t\t\t\tcaret: radixPos > pos ? pos + 1 : pos\r\n\t\t\t\t} : {\r\n\t\t\t\t\tinsert: [\r\n\t\t\t\t\t\t{pos: findValidator(\"+\", maskset), c: opts.negationSymbol.front, fromIsValid: true},\r\n\t\t\t\t\t\t{pos: findValidator(\"-\", maskset), c: opts.negationSymbol.back, fromIsValid: true}],\r\n\t\t\t\t\tcaret: radixPos > pos ? pos + 1 : pos\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t\tif (radixPos !== -1 && (opts._radixDance === true && isSelection === false && c === opts.radixPoint && (opts.digits !== undefined && (isNaN(opts.digits) || parseInt(opts.digits) > 0)) && radixPos !== pos)) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\t\"caret\": opts._radixDance && pos === radixPos - 1 ? radixPos + 1 : radixPos\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\treturn {rewritePosition: pos};\r\n\t\t},\r\n\t\tpostValidation: function (buffer, pos, currentResult, opts) {\r\n\t\t\tif (opts.min !== null || opts.max !== null) {\r\n\t\t\t\tvar unmasked = opts.onUnMask(buffer.slice().reverse().join(\"\"), undefined, $.extend({}, opts, {\r\n\t\t\t\t\tunmaskAsNumber: true\r\n\t\t\t\t}));\r\n\t\t\t\tif (opts.min !== null && unmasked < opts.min && unmasked.toString().length >= opts.min.toString().length) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\tif (opts.max !== null && unmasked > opts.max) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn currentResult;\r\n\t\t},\r\n\t\tonUnMask: function (maskedValue, unmaskedValue, opts) {\r\n\t\t\tif (unmaskedValue === \"\" && opts.nullable === true) {\r\n\t\t\t\treturn unmaskedValue;\r\n\t\t\t}\r\n\t\t\tvar processValue = maskedValue.replace(opts.prefix, \"\");\r\n\t\t\tprocessValue = processValue.replace(opts.suffix, \"\");\r\n\t\t\tprocessValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), \"g\"), \"\");\r\n\t\t\tif (opts.placeholder.charAt(0) !== \"\") {\r\n\t\t\t\tprocessValue = processValue.replace(new RegExp(opts.placeholder.charAt(0), \"g\"), \"0\");\r\n\t\t\t}\r\n\t\t\tif (opts.unmaskAsNumber) {\r\n\t\t\t\tif (opts.radixPoint !== \"\" && processValue.indexOf(opts.radixPoint) !== -1) processValue = processValue.replace(Inputmask.escapeRegex.call(this, opts.radixPoint), \".\");\r\n\t\t\t\tprocessValue = processValue.replace(new RegExp(\"^\" + Inputmask.escapeRegex(opts.negationSymbol.front)), \"-\");\r\n\t\t\t\tprocessValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + \"$\"), \"\");\r\n\t\t\t\treturn Number(processValue);\r\n\t\t\t}\r\n\t\t\treturn processValue;\r\n\t\t},\r\n\t\tisComplete: function (buffer, opts) {\r\n\t\t\tvar maskedValue = (opts.numericInput ? buffer.slice().reverse() : buffer).join(\"\");\r\n\t\t\tmaskedValue = maskedValue.replace(new RegExp(\"^\" + Inputmask.escapeRegex(opts.negationSymbol.front)), \"-\");\r\n\t\t\tmaskedValue = maskedValue.replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + \"$\"), \"\");\r\n\t\t\tmaskedValue = maskedValue.replace(opts.prefix, \"\");\r\n\t\t\tmaskedValue = maskedValue.replace(opts.suffix, \"\");\r\n\t\t\tmaskedValue = maskedValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator) + \"([0-9]{3})\", \"g\"), \"$1\");\r\n\t\t\tif (opts.radixPoint === \",\") maskedValue = maskedValue.replace(Inputmask.escapeRegex(opts.radixPoint), \".\");\r\n\t\t\treturn isFinite(maskedValue);\r\n\t\t},\r\n\t\tonBeforeMask: function (initialValue, opts) {\r\n\t\t\tvar radixPoint = opts.radixPoint || \",\";\r\n\r\n\t\t\tif ((typeof initialValue == \"number\" || opts.inputType === \"number\") && radixPoint !== \"\") {\r\n\t\t\t\tinitialValue = initialValue.toString().replace(\".\", radixPoint);\r\n\t\t\t}\r\n\r\n\t\t\tvar valueParts = initialValue.split(radixPoint),\r\n\t\t\t\tintegerPart = valueParts[0].replace(/[^\\-0-9]/g, \"\"),\r\n\t\t\t\tdecimalPart = valueParts.length > 1 ? valueParts[1].replace(/[^0-9]/g, \"\") : \"\";\r\n\r\n\t\t\tinitialValue = integerPart + (decimalPart !== \"\" ? radixPoint + decimalPart : decimalPart);\r\n\r\n\t\t\tvar digits = 0;\r\n\t\t\tif (radixPoint !== \"\") {\r\n\t\t\t\tdigits = decimalPart.length;\r\n\t\t\t\tif (decimalPart !== \"\") {\r\n\t\t\t\t\tvar digitsFactor = Math.pow(10, digits || 1);\r\n\t\t\t\t\tif (isFinite(opts.digits)) {\r\n\t\t\t\t\t\tdigits = parseInt(opts.digits);\r\n\t\t\t\t\t\tdigitsFactor = Math.pow(10, digits);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t//make the initialValue a valid javascript number for the parsefloat\r\n\t\t\t\t\tinitialValue = initialValue.replace(Inputmask.escapeRegex(radixPoint), \".\");\r\n\t\t\t\t\tif (isFinite(initialValue)) {\r\n\t\t\t\t\t\tinitialValue = Math.round(parseFloat(initialValue) * digitsFactor) / digitsFactor;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tinitialValue = initialValue.toString().replace(\".\", radixPoint);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t//this needs to be in a separate part and not directly in decimalPart to allow rounding\r\n\t\t\tif (opts.digits === 0 && initialValue.indexOf(Inputmask.escapeRegex(radixPoint)) !== -1) {\r\n\t\t\t\tinitialValue = initialValue.substring(0, initialValue.indexOf(Inputmask.escapeRegex(radixPoint)));\r\n\t\t\t}\r\n\t\t\treturn alignDigits(initialValue.toString().split(\"\"), digits, opts).join(\"\");\r\n\t\t},\r\n\t\tonBeforeWrite: function (e, buffer, caretPos, opts) {\r\n\t\t\tvar result;\r\n\t\t\t//check leading zeros\r\n\t\t\tvar numberMatches = new RegExp(\"^\" + (opts.negationSymbol.front != \"\" ? Inputmask.escapeRegex(opts.negationSymbol.front) + \"?\" : \"\") + Inputmask.escapeRegex(opts.prefix) + \"(?<number>.*)\" + Inputmask.escapeRegex(opts.suffix) + (opts.negationSymbol.back != \"\" ? Inputmask.escapeRegex(opts.negationSymbol.back) + \"?\" : \"\") + \"$\").exec(buffer.slice().reverse().join(\"\")),\r\n\t\t\t\tnumber = numberMatches ? numberMatches.groups.number : \"\";\r\n\t\t\tif (number) {\r\n\t\t\t\tnumber = number.split(opts.radixPoint.charAt(0))[0];\r\n\r\n\t\t\t\tvar leadingzeroes = new RegExp(\"^[0\" + opts.groupSeparator + \"]*\").exec(number);\r\n\r\n\t\t\t\tif (leadingzeroes[0].length > 1 || leadingzeroes[0].length > 0 && leadingzeroes[0].length < number.length) {\r\n\t\t\t\t\tvar buf = buffer.slice().reverse(), caretNdx = buf.join(\"\").indexOf(leadingzeroes[0]);\r\n\t\t\t\t\tbuf.splice(caretNdx, leadingzeroes[0].length);\r\n\t\t\t\t\tvar newCaretPos = buf.length - caretNdx;\r\n\t\t\t\t\tresult = {\r\n\t\t\t\t\t\trefreshFromBuffer: true,\r\n\t\t\t\t\t\tbuffer: buf.reverse(),\r\n\t\t\t\t\t\tcaret: caretPos < newCaretPos ? caretPos : newCaretPos\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\r\n\t\t\tif (e) {\r\n\t\t\t\tswitch (e.type) {\r\n\t\t\t\t\tcase \"blur\":\r\n\t\t\t\t\tcase \"checkval\":\r\n\t\t\t\t\t\tif (opts.radixPoint !== \"\" && buffer[0] === opts.radixPoint) {\r\n\t\t\t\t\t\t\tif (result && result.buffer) {\r\n\t\t\t\t\t\t\t\tresult.buffer.shift();\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tbuffer.shift();\r\n\t\t\t\t\t\t\t\tresult =\r\n\t\t\t\t\t\t\t\t\t{refreshFromBuffer: true, buffer: buffer};\r\n\t\t\t\t\t\t\t\t;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result;\r\n\t\t},\r\n\t\tonKeyDown: function (e, buffer, caretPos, opts) {\r\n\t\t\tvar $input = $(this);\r\n\t\t\tif (e.ctrlKey) {\r\n\t\t\t\tswitch (e.keyCode) {\r\n\t\t\t\t\tcase Inputmask.keyCode.UP:\r\n\t\t\t\t\t\tthis.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) + parseInt(opts.step));\r\n\t\t\t\t\t\t$input.trigger(\"setvalue\");\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\tcase Inputmask.keyCode.DOWN:\r\n\t\t\t\t\t\tthis.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) - parseInt(opts.step));\r\n\t\t\t\t\t\t$input.trigger(\"setvalue\");\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (e.keyCode === Inputmask.keyCode.DELETE || e.keyCode === Inputmask.keyCode.BACKSPACE || e.keyCode === Inputmask.keyCode.BACKSPACE_SAFARI) {\r\n\t\t\t\tif (opts._radixDance === true && !opts.digitsOptional) {\r\n\t\t\t\t\tvar radixPos = $.inArray(opts.radixPoint, buffer);\r\n\t\t\t\t\tif (radixPos !== -1 && (caretPos < radixPos || (e.keyCode === Inputmask.keyCode.DELETE && caretPos === radixPos))) {\r\n\t\t\t\t\t\tif (e.keyCode === Inputmask.keyCode.BACKSPACE || e.keyCode === Inputmask.keyCode.BACKSPACE_SAFARI) {\r\n\t\t\t\t\t\t\tcaretPos++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar bffr = buffer.slice().reverse();\r\n\t\t\t\t\t\tbffr.splice(bffr.length - caretPos, 1);\r\n\t\t\t\t\t\t$input.trigger(\"setvalue\", [alignDigits(bffr, opts.digits, opts).join(\"\"), caretPos]);\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\t\"currency\": {\r\n\t\tprefix: \"$ \",\r\n\t\tgroupSeparator: \",\",\r\n\t\talias: \"numeric\",\r\n\t\tplaceholder: \"0\",\r\n\t\tdigits: 2,\r\n\t\tdigitsOptional: false\r\n\t},\r\n\t\"decimal\": {\r\n\t\talias: \"numeric\"\r\n\t},\r\n\t\"integer\": {\r\n\t\talias: \"numeric\",\r\n\t\tdigits: 0\r\n\t},\r\n\t\"percentage\": {\r\n\t\talias: \"integer\",\r\n\t\tmin: 0,\r\n\t\tmax: 100,\r\n\t\tsuffix: \" %\",\r\n\t\tallowMinus: false\r\n\t},\r\n\t\"indianns\": { //indian numbering system\r\n\t\talias: \"numeric\",\r\n\t\t_mask: function (opts) {\r\n\t\t\treturn \"(\" + opts.groupSeparator + \"99){*|1}(\" + opts.groupSeparator + \"999){1|1}\";\r\n\t\t},\r\n\t\tgroupSeparator: \",\",\r\n\t\tradixPoint: \".\",\r\n\t\tplaceholder: \"0\",\r\n\t\tdigits: 2,\r\n\t\tdigitsOptional: false\r\n\t}\r\n});\r\nmodule.exports = Inputmask;\r\n"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n"],"sourceRoot":""}