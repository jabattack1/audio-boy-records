{"version":3,"file":"static/webpack/static/development/pages/index.js.5f16102ee1ce91bc73af.hot-update.js","sources":["webpack:///./scrollStore.js"],"sourcesContent":["if (process.browser){\nwindow.onload = function(){\n\nvar SETTINGSStore = {\n    navBarTravelling: false,\n    navBarTravelDirection: \"\",\n    navBarTravelDistance: 250\n}\n\nvar coloursStore = {\n    0: \"#867100\",\n    1: \"#7F4200\",\n    2: \"#99813D\",\n    3: \"#40FEFF\",\n    4: \"#14CC99\",\n    5: \"#00BAFF\",\n    6: \"#0082B2\",\n    7: \"#B25D7A\",\n    8: \"#00FF17\",\n    9: \"#006B49\",\n    10: \"#00B27A\",\n    11: \"#996B3D\",\n    12: \"#CC7014\",\n    13: \"#40FF8C\",\n    14: \"#FF3400\",\n    15: \"#ECBB5E\",\n    16: \"#ECBB0C\",\n    17: \"#B9D912\",\n    18: \"#253A93\",\n    19: \"#125FB9\",\n}\n\ndocument.documentElement.classList.remove(\"no-js\");\ndocument.documentElement.classList.add(\"js\");\nconsole.log('lion');\nconsole.log(document.getElementById(\"pnAdvancerLeftStore\"));\n// Out advancer buttons\nvar pnAdvancerLeftStore = document.getElementById(\"pnAdvancerLeftStore\");\nvar pnAdvancerRightStore = document.getElementById(\"pnAdvancerRightStore\");\n// the indicator\nvar pnIndicatorStore = document.getElementById(\"pnIndicatorStore\");\n\nvar pnProductNavStore = document.getElementById(\"pnProductNavStore\");\nvar pnProductNavContentsStore = document.getElementById(\"pnProductNavContentsStore\");\n\npnProductNavStore.setAttribute(\"data-overflowing\", determineOverflowStore(pnProductNavContentsStore, pnProductNavStore));\n\n// Set the indicator\nmoveIndicatorStore(pnProductNavStore.querySelector(\"[aria-selected=\\\"true\\\"]\"), coloursStore[0]);\n\n// Handle the scroll of the horizontal container\nvar last_known_scroll_positionStore = 0;\nvar tickingStore = false;\n\nfunction doSomethingStore(scroll_pos) {\n    pnProductNavStore.setAttribute(\"data-overflowing\", determineOverflowStore(pnProductNavContentsStore, pnProductNavStore));\n}\n\npnProductNavStore.addEventListener(\"scroll\", function() {\n    last_known_scroll_positionStore = window.scrollY;\n    if (!tickingStore) {\n        window.requestAnimationFrame(function() {\n            doSomethingStore(last_known_scroll_positionStore);\n            tickingStore = false;\n        });\n    }\n    tickingStore = true;\n});\n\n\npnAdvancerLeftStore.addEventListener(\"click\", function() {\n    // If in the middle of a move return\n    if (SETTINGSStore.navBarTravelling === true) {\n        return;\n    }\n    // If we have content overflowing both sides or on the left\n    if (determineOverflowStore(pnProductNavContentsStore, pnProductNavStore) === \"left\" || determineOverflowStore(pnProductNavContentsStore, pnProductNavStore) === \"both\") {\n        // Find how far this panel has been scrolled\n        var availableScrollLeftStore = pnProductNavStore.scrollLeft;\n        // If the space available is less than two lots of our desired distance, just move the whole amount\n        // otherwise, move by the amount in the settingsStore\n        if (availableScrollLeftStore < SETTINGSStore.navBarTravelDistance * 2) {\n            pnProductNavContentsStore.style.transform = \"translateX(\" + availableScrollLeftStore + \"px)\";\n        } else {\n            pnProductNavContentsStore.style.transform = \"translateX(\" + SETTINGSStore.navBarTravelDistance + \"px)\";\n        }\n        // We do want a transition (this is set in CSS) when moving so remove the class that would prevent that\n        pnProductNavContentsStore.classList.remove(\"pn-ProductNav_Contents-no-transition\");\n        // Update our settingsStore\n        SETTINGSStore.navBarTravelDirection = \"left\";\n        SETTINGSStore.navBarTravelling = true;\n    }\n    // Now update the attribute in the DOM\n    pnProductNavStore.setAttribute(\"data-overflowing\", determineOverflowStore(pnProductNavContentsStore, pnProductNavStore));\n});\n\npnAdvancerRightStore.addEventListener(\"click\", function() {\n    // If in the middle of a move return\n    if (SETTINGSStore.navBarTravelling === true) {\n        return;\n    }\n    // If we have content overflowing both sides or on the right\n    if (determineOverflowStore(pnProductNavContentsStore, pnProductNavStore) === \"right\" || determineOverflowStore(pnProductNavContentsStore, pnProductNavStore) === \"both\") {\n        // Get the right edge of the container and content\n        var navBarRightEdgeStore = pnProductNavContentsStore.getBoundingClientRect().right;\n        var navBarScrollerRightEdgeStore = pnProductNavStore.getBoundingClientRect().right;\n        // Now we know how much space we have available to scroll\n        var availableScrollRightStore = Math.floor(navBarRightEdgeStore - navBarScrollerRightEdgeStore);\n        // If the space available is less than two lots of our desired distance, just move the whole amount\n        // otherwise, move by the amount in the settingsStore\n        if (availableScrollRightStore < SETTINGSStore.navBarTravelDistance * 2) {\n            pnProductNavContentsStore.style.transform = \"translateX(-\" + availableScrollRightStore + \"px)\";\n        } else {\n            pnProductNavContentsStore.style.transform = \"translateX(-\" + SETTINGSStore.navBarTravelDistance + \"px)\";\n        }\n        // We do want a transition (this is set in CSS) when moving so remove the class that would prevent that\n        pnProductNavContentsStore.classList.remove(\"pn-ProductNav_Contents-no-transition\");\n        // Update our settingsStore\n        SETTINGSStore.navBarTravelDirection = \"right\";\n        SETTINGSStore.navBarTravelling = true;\n    }\n    // Now update the attribute in the DOM\n    pnProductNavStore.setAttribute(\"data-overflowing\", determineOverflowStore(pnProductNavContentsStore, pnProductNavStore));\n});\n\npnProductNavContentsStore.addEventListener(\n    \"transitionend\",\n    function() {\n        // get the value of the transform, apply that to the current scroll position (so get the scroll pos first) and then remove the transform\n        var styleOfTransformStore = window.getComputedStyle(pnProductNavContentsStore, null);\n        var trStore = styleOfTransformStore.getPropertyValue(\"-webkit-transform\") || styleOfTransformStore.getPropertyValue(\"transform\");\n        // If there is no transition we want to default to 0 and not null\n        var amountStore = Math.abs(parseInt(trStore.split(\",\")[4]) || 0);\n        pnProductNavContentsStore.style.transform = \"none\";\n        pnProductNavContentsStore.classList.add(\"pn-ProductNav_Contents-no-transition\");\n        // Now lets set the scroll position\n        if (SETTINGSStore.navBarTravelDirection === \"left\") {\n            pnProductNavStore.scrollLeft = pnProductNavStore.scrollLeft - amountStore;\n        } else {\n            pnProductNavStore.scrollLeft = pnProductNavStore.scrollLeft + amountStore;\n        }\n        SETTINGSStore.navBarTravelling = false;\n    },\n    false\n);\n\n// Handle setting the currently active link\npnProductNavContentsStore.addEventListener(\"click\", function(e) {\n    var linksStore = [].slice.call(document.querySelectorAll(\".pn-ProductNav_LinkStore\"));\n    linksStore.forEach(function(item) {\n        item.setAttribute(\"aria-selected\", \"false\");\n    })\n    e.target.setAttribute(\"aria-selected\", \"true\");\n    // Pass the clicked item and it's colour to the move indicator function\n    moveIndicatorStore(e.target, coloursStore[linksStore.indexOf(e.target)]);\n});\n\n// var count = 0;\nfunction moveIndicatorStore(item, color) {\n    var textPosition = item.getBoundingClientRect();\n    var container = pnProductNavContentsStore.getBoundingClientRect().left;\n    var distance = textPosition.left - container;\n     var scroll = pnProductNavContentsStore.scrollLeft;\n    pnIndicatorStore.style.transform = \"translateX(\" + (distance + scroll) + \"px) scaleX(\" + textPosition.width * 0.01 + \")\";\n    // count = count += 100;\n    // pnIndicator.style.transform = \"translateX(\" + count + \"px)\";\n    \n    if (color) {\n        pnIndicatorStore.style.backgroundColor = color;\n    }\n}\n\nfunction determineOverflowStore(content, container) {\n    var containerMetrics = container.getBoundingClientRect();\n    var containerMetricsRight = Math.floor(containerMetrics.right);\n    var containerMetricsLeft = Math.floor(containerMetrics.left);\n    var contentMetrics = content.getBoundingClientRect();\n    var contentMetricsRight = Math.floor(contentMetrics.right);\n    var contentMetricsLeft = Math.floor(contentMetrics.left);\n     if (containerMetricsLeft > contentMetricsLeft && containerMetricsRight < contentMetricsRight) {\n        return \"both\";\n    } else if (contentMetricsLeft < containerMetricsLeft) {\n        return \"left\";\n    } else if (contentMetricsRight > containerMetricsRight) {\n        return \"right\";\n    } else {\n        return \"none\";\n    }\n}\n\n/**\n * @fileoverview dragscroll - scroll area by dragging\n * @version 0.0.8\n * \n * @license MIT, see https://github.com/asvd/dragscroll\n * @copyright 2015 asvd <heliosframework@gmail.com> \n */\n\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define(['exports'], factory);\n    } else if (typeof exports !== 'undefined') {\n        factory(exports);\n    } else {\n        factory((root.dragscroll = {}));\n    }\n}(this, function (exports) {\n    var _windowStore = window;\n    var _documentStore = document;\n    var mousemove = 'mousemove';\n    var mouseup = 'mouseup';\n    var mousedown = 'mousedown';\n    var EventListener = 'EventListener';\n    var addEventListener = 'add'+EventListener;\n    var removeEventListener = 'remove'+EventListener;\n    var newScrollX, newScrollY;\n\n    var dragged = [];\n    var reset = function(i, el) {\n        for (i = 0; i < dragged.length;) {\n            el = dragged[i++];\n            el = el.container || el;\n            el[removeEventListener](mousedown, el.md, 0);\n            _windowStore[removeEventListener](mouseup, el.mu, 0);\n            _windowStore[removeEventListener](mousemove, el.mm, 0);\n        }\n\n        // cloning into array since HTMLCollection is updated dynamically\n        dragged = [].slice.call(_documentStore.getElementsByClassName('dragscroll'));\n        for (i = 0; i < dragged.length;) {\n            (function(el, lastClientX, lastClientY, pushed, scroller, cont){\n                (cont = el.container || el)[addEventListener](\n                    mousedown,\n                    cont.md = function(e) {\n                        if (!el.hasAttribute('nochilddrag') ||\n                            _document.elementFromPoint(\n                                e.pageX, e.pageY\n                            ) == cont\n                        ) {\n                            pushed = 1;\n                            lastClientX = e.clientX;\n                            lastClientY = e.clientY;\n\n                            e.preventDefault();\n                        }\n                    }, 0\n                );\n\n                _windowStore[addEventListener](\n                    mouseup, cont.mu = function() {pushed = 0;}, 0\n                );\n\n                _windowStore[addEventListener](\n                    mousemove,\n                    cont.mm = function(e) {\n                        if (pushed) {\n                            (scroller = el.scroller||el).scrollLeft -=\n                                newScrollX = (- lastClientX + (lastClientX=e.clientX));\n                            scroller.scrollTop -=\n                                newScrollY = (- lastClientY + (lastClientY=e.clientY));\n                            if (el == _document.body) {\n                                (scroller = _document.documentElement).scrollLeft -= newScrollX;\n                                scroller.scrollTop -= newScrollY;\n                            }\n                        }\n                    }, 0\n                );\n             })(dragged[i++]);\n        }\n    }\n\n      \n    if (_document.readyState == 'complete') {\n        reset();\n    } else {\n        _windowStore[addEventListener]('load', reset, 0);\n    }\n\n    exports.reset = reset;\n}));\n}\n}"],"mappings":";;;;;;;;;;;;;;;AAAA;AACA;AAEA;AACA;AACA;AACA;AAHA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApBA;AAuBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAGA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}